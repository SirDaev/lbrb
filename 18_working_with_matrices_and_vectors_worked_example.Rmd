---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Manipulating matrices and vectors: worked example

**By** Nathan Brouwer

<!-- use DNA matrix first? distance matrix? other? -->

## Introduction 

In this exercise we will practice manipulating matrices and vectors by exploring the structure of **scoring matrices**.

## Preliminaries


### Packages 

* BiocManager
* Biostrings
* combio4all

### Vocab

#### Math / R vocab

* triangular matrix
* square matrix
* lower triangle
* upper triangle
* symmetric matrix
* matrix diagonal
* named vectors
* named matrices
* accessing items in named vectors or matrices
* square bracket notation

#### Bioinformatics vocab 
* scoring matrix
* BLOSUM scoring matrix


### Functions used

#### Base R functions
* `data()`
* `is()`
* `nrow()`, `ncol()`, 
* `dim()`,
* `names()`, `colnames()`, `rownames()`, 
* `head()`,  `tail()`


### Packages

```{r}
library(Biostrings)
```

### Data

```{r}
data(BLOSUM62)
```


## Matrix elements can be accessed with square bracket notation

We often want to access just subsets of data from a matrix or a dataframe.  This can take some getting used to.  We can use **square brackets** to get certain subsets or ranges of cells. If we want just the upper left-hand cell we can do this:

```{r}
BLOSUM62[1,1]
```

If we want the first four cells in the upper left hand corner we can do this

```{r}
BLOSUM62[c(1:4), c(1:4)]
```


If we want to get rid of the **ambiguity code** cells on the bottom which are `B`, `J`, `Z`, `X` and `*` we can specify that we want elements 1 through 20.  Let me step through this.

First, run the code below; what happens?
```{r}

1:4

```

Now do the same thing for 1 to 20:
```{r}



```

Note that this next line should provide the same result as what you just did.
```{r}
c(1:20)
```


If we *really* wanted to type all of this out, we would have to do this:
```{r}
c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20)
```



We can get just the first row of the BLOSUM matrix by telling *R* we want row 1 and columns 1 to 20.

We get just *row* 1 like this:

```{r}
BLOSUM62[1, ]
```

We get columns 1:20 like this:
```{r}
BLOSUM62[ , c(1:20)]
```

Note that leaving the first part blank gives us ALL the rows.

If we want just the first row AND the first 20 columns, we do this:
```{r}

BLOSUM62[1 , c(1:20)]

```

Assign the output of the code `c(1:20)` to an object called `i` using the assignment operator `<-`.  The code should like like this `i <- c(1:20)`.

```{r, echo = T}
i <- c(1:20)
```


```{r}



```

This thing `i` we just  made is a **vector** of numbers.  Vectors are a 1-dimensional sequence of numbers.  You can think of a matrix as a bunch of vectors stacked on top of each other.

Unfortunately, if you call `is()` in the `i` object you don't get a totally clear picture of what it is.  Where does the word `vector` show up?
```{r}



```

I'm not sure why `vector` isn't the first thing to be printed.  We can check whether `i` is a vector more directly by asking it "hey i, are you a vector" using the `is.vector()` command

```{r}
is.vector(i)
```

Its a vector, so it shouldn't be a matrix, but we can check with `is.matrix()`
```{r}
is.matrix(i)
```

Math books may tell you that a vector is a 1-dimensional matrix, but in *R* land vectors are distinct from matrices.

Vectors show up *everywhere* in R.  In this case I've defined a vector, `i`, which is holding the row and column numbers I want to isolated from the BLOSUM62 matrix.

I can call up just these rows and columns like this


```{r}
BLOSUM62[i , i]
```

If I hadn't defined the vector `i`, I could write

```{r}
BLOSUM62[c(1:20) ,c(1:20)  ]
```

Let's isolate just the first 20 rows and columns and put them into a new object called `BLOSUM62.subset`.

```{r}
BLOSUM62.subset <-  BLOSUM62[i ,i ]
```


We can get the scores for when there is no change in an amino acid from the diagonal with `diag()`
```{r}
diag(BLOSUM62.subset)
```

If you're scoring an alignment by hand you can pull up the diagonal of the matrix this way so you don't have to squint at the whole matrix.  We can make it even easier if we alphabetize thing, though this requires some extra code which you don't need to worry about.  (I'm making a new vector, `i2`, which will do the alphabetizing).
```{r}
# get column names
n <- colnames(BLOSUM62.subset)

# sort
i2 <- sort(n)
```


Now things are in alphabetical order
```{r}
diag(BLOSUM62.subset)[i2]
```

Save this alphabetized diagonal to an `R` object called `BLOSUM62.diag` using the assignment operator `<-`

```{r, echo = T}
BLOSUM62.diag <- diag(BLOSUM62.subset)[i2]
```

```{r}



```

What are the names attached to this `BLOSUM62.diag` object? Unfortunately *R* is picky about how you do this so you need to figure out whether the functions `names()`, `rownames()`, or `colnames()` gets you want you want
```{r}
rownames(BLOSUM62.diag)
colnames(BLOSUM62.diag)
names(BLOSUM62.diag)
```


## R object names

When an *R* object has "names" assigned to it we can use the name to call up elements of the object.

### Accessing items in names vectors

We can call up just the score for an E to E transition stored in our matrix diagonal like this, which is a way of saying "Hey R, give me the value in this `BLOSUM62.diag` object that is in the slot labeled "E".
```{r}
BLOSUM62.diag["E"]
```


E is the 4th slot so we can also get this value like this with the slot number.
```{r}

BLOSUM62.diag[4]

```


We could get the first four values using `c(1:4)`.  Try it
```{r}



```


What type of object is this diagonal thingy anyway?  The command starts with "i".
```{r}



```


### Accessing items in names matrices

If we want to get something from the main matrix (the full BLOSUM matrix, not the diagonal) we can also specify things using the row and column names.  This will give us the value for an E to E transition:

```{r}

BLOSUM62.subset["E","E"]

```


How could you get the whole "E" *column*?
```{r}


```


How could you get the whole "E" *row*?
```{r}


```

We can use numbers too if we want.  "E" is in the 7th column, so we can get the E to E value like this:
```{r}

BLOSUM62.subset[7,7]

```

How would you get the whole "E" column?
```{r}



```

How would you get the whole "E" row?
```{r}
BLOSUM62.subset[7, ]
```

We can of course specify any score we want.  For a P to A transition we could do this:
```{r}
BLOSUM62.subset["P","A"]

```


Or specify the row and column numbers
```{r}
BLOSUM62.subset[15,1]
```

What happens when you do ["A","P"] instead (reverse of what was above?

```{r}



```

So, if you are doing an alignment by hand, you can quickly query the matrix and pull up the scores.  If you have a sequence "EPEERPEWRDRPGSP" and "EAEREASWSEDRPGT" you can get the score for the E to E matching again like this

```{r}
BLOSUM62.subset["E","E"]
```


and P to A like this

```{r}
BLOSUM62.subset["P","A"]
```

and so on.  
