---
title: "Simulate male fertility data- functions"
author: "Nathan Brouwer"
date: "10/16/2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```




```{r}
find_hits <- function(n.its = 10000, n,
                      target.mean, target.sd,
                      tolerance.mean = 0.25,
                      tolerance.sd = 0.25){
  
# storage matrix
rand.data <- matrix(data = NA,
          nrow = n.its,
          ncol = n)
rand.data <- data.frame(rand.data)


#loop
for(i in 1:n.its){
  # generate random data

rand.data.i <- rnorm(n = n,
      mean = target.mean,
      sd= target.sd)

#make sure all values > 0
while(any(rand.data.i< 0) == TRUE){
  i.0 <- which(rand.data.i < 0)
  rand.data.i[i.0] <- rnorm(n = length(i.0),
                              mean = target.mean,
                              sd   = target.sd)
  }

rand.data[i,] <- rand.data.i

  
}

means <- apply(rand.data,1,mean)
sds <- apply(rand.data,1,sd)

diff.means <- abs(means-target.mean)
diff.sds   <- abs(sds-target.sd)

useable <- which(diff.means < tolerance.mean &
                 diff.sds   < tolerance.sd)

return(rand.data[useable,])
}



```


```{r}
means <- apply(rand.data,1,mean)
sds <- apply(rand.data,1,sd)

plot(means ~ sds)
abline(v= sd.fp.base, col = 2)
abline(h= mean.fp.base, col =2)
abline(v= sd.fp.base+0.25, col = 2)
abline(v= sd.fp.base-0.25, col = 2)
abline(h= mean.fp.base, col =2)
abline(h= mean.fp.base+0.25, col =2)
abline(h= mean.fp.base-0.25, col =2)
```


```{r}
i.hit.base <-which(e.mean < 0.25 & 
        e.sd < 0.25)

data.base.summary[i.hit.base, ]

hist(t(rand.data[i.hit.base[3],-c(1:4)]))

data.base.hits <- rand.data[i.hit.base, ]


```



hit h
value j within hit
iteration i of optimization of hit



```{r}
pythag <- function(x1,x2,y1,y2){
  a2 <-(x1-x2)^2
  b2 <-(y1-y2)^2
  c2 <- a2+b2
  c <- sqrt(c2)
  return(c)
}
```


```{r}

optimize_hit <- function(hit, n.its = 20,min.its = 20, noise = 0.1,n,
                         target.mean, target.sd,
                         tolerance.mean,
                         tolerance.sd){
 
# storage matrix
data.hit.opt.h <- matrix(data = NA, ncol = n.its+1, nrow = n)

# add hit to storage matrix
data.hit.opt.h[,1] <- hit


# diagnostic
scale. <- 0.05
x.lim <- c(mean(data.hit.opt.h[,1])-mean(data.hit.opt.h[,1])*scale.,
           mean(data.hit.opt.h[,1]+ mean(data.hit.opt.h[,1])*scale.))

y.lim <- c(sd(data.hit.opt.h[,1])  -sd(data.hit.opt.h[,1])*scale.,
           sd(data.hit.opt.h[,1]) + sd(data.hit.opt.h[,1]*scale.))


# plot mean and sd of hit
plot(mean(data.hit.opt.h[,1]) , sd(data.hit.opt.h[,1]), 
       xlim = x.lim,
       ylim = y.lim,pch =14)

# add observed mean and sd
points(target.mean , target.sd,pch =16, col =2,cex= 1.4)
abline(v = target.mean, col =2)
abline(h = target.sd,   col =2) 

#install.packages("plotrix")
library(plotrix)




draw.circle(target.mean, target.sd,radius = max(tolerance.mean,tolerance.sd))
draw.circle(target.mean, target.sd,radius = min(tolerance.mean,tolerance.sd))

  
for(i in 1:n.its){

  #take current best hit
  ## calculate summary stats
  seed.ij.1 <- data.hit.opt.h[,i]
  mean.ij.1 <- mean(seed.ij.1)
  sd.ij.1   <- sd(seed.ij.1)
  
  #calculate current distnace
  dist.1 <- pythag(target.mean, mean.ij.1,
                   target.sd,   sd.ij.1)
  
  # add noise
  seed.ij.2 <- seed.ij.1 + abs(runif(n = n, min = -noise, max = noise))
  
  #calcualte new summary stats
  mean.ij.2 <- mean(seed.ij.2)
  sd.ij.2   <- sd(seed.ij.2)
  

  dist.2 <- pythag(target.mean, mean.ij.2,
                   target.sd,   sd.ij.2)
  
  
  
  while(dist.2>dist.1){
        
       seed.ij.2 <- abs(seed.ij.1 +runif(n = n, min = -noise, max = noise))
       
       mean.ij.2 <- mean(seed.ij.2)
       sd.ij.2   <- sd(seed.ij.2)
       dist.2 <- pythag(target.mean, mean.ij.2,
                   target.sd,   sd.ij.2)
       
       if(dist.2<0.005 ){ #& i > min.its
         print("terminating early b/c close to opt")
         break
       }
  }
  
  points(mean.ij.2, sd.ij.2,col =i)
  
  data.hit.opt.h[,i+1] <- seed.ij.2
  
  if(dist.2<0.005 ){ #& i > min.its
         print("terminating early b/c close to opt")
         break
       }

}


means <- apply(data.hit.opt.h,2,mean)
sds   <- apply(data.hit.opt.h,2,sd)

diff.means <- abs(means-target.mean)
diff.sds   <- abs(sds-target.sd)

useable <- which(diff.means < tolerance.mean &
                 diff.sds   < tolerance.sd)

cat(length(useable)," usable datasets")
return(data.hit.opt.h[,useable])
 
}
  




```




