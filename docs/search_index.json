[["blast-alignment-score-distribution.html", "Chapter 35 BLAST Alignment score distribution 35.1 Packages 35.2 Distributions of alignment scores 35.3 Simulating data 35.4 Lots of data in biology is normal 35.5 Simulating the normal distribution 35.6 The extreme value distribution 35.7 Replicating Figure 4.14 35.8 Why do we care?", " Chapter 35 BLAST Alignment score distribution By: Nathan Brouwer eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGNvbXBiaW80YWxsKSJ9 35.1 Packages eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjaW5zdGFsbC5wYWNrYWdlcyhcIkhpc3REYXRhXCIpXG5saWJyYXJ5KEhpc3REYXRhKVxubGlicmFyeShnZ3B1YnIpXG5cbiNpbnN0YWxsLnBhY2thZ2VzKFwiZXZkXCIpXG5saWJyYXJ5KGV2ZCkifQ== 35.2 Distributions of alignment scores Imagine we could keep track of all of the steps of a BLAST search. At a certain point, BLAST will have made many local alignments of a few dozen to a couple hundred bases between the query sequence you submitted and sequences in the database. Each of these local, pairwise alignments met all the criteria for being worthy of consideration and so are recored as hits. Now we want to judge objectively how good these hits are and which ones are most worthy of further consideration. We can do this by working of an E-value. With our collection of hits, we could take their scores and plot them. Many things in biology when plotted will take on a bell-curve or normal distribution. Scores for alignments, however, take on an extreme value distribution (EVD). That is, compared to a symmetric normal distribution an EVD has too few low numbers (lower alignment scores) and extra high scores. Now imagine that instead of BLASTing our sequence against a database of real sequence, we made up a bunch of random sequences. We could invent a random sequene by writing all the letters representing amino acids, tossing them into a hat, and pulling out an letter and writiing it down. We would then toss the letter back in, mix up the letters, and pull out another one. Repeat this 100 times and we’d have a perfectly random sequence the would be about the length of a protein, but wouldn’t code for anything (or be very very very very very unlikely to code for anything). If we invent, say 1000 sequence we could make a database of random sequences and would could aline our focal query sequence against our made up database. When could then score the local alignment between the query and each random sequence. Because these sequences are made up, the alignments will be pretty bad and teh scores low. However, occassionally there might be a fairly high score due to chance. So, just due to luck we could accidently invent a sequence that is a pretty good alignment with our query sequence. The question the E-values are trying to get at is how often this could happen, and how much better are our the scoures of our BLAST hits than the scores we’d get from BLASTing again random sequences. The following code will illustrate these concepts. 35.3 Simulating data The easiest way to think about simulating data is to roll a dice. Six-sided die allows you to draw numbers from a uniform distribution. With a uniform distribution, all values have the same likelihood of occuring. On a die, you have a 1/6 change of getting a 1, a 1/6 change of a 2, etc. We can simulate a 6-sided die in R using the runif() function, which doesn’t mean “run-if” but rather “r-unif”, for random-uniform. We can simulate rolling a die once with this code. n is the number of rolls. Min is the minimum possible value, max is the max possible value. Note that the min is set to 0.5 and the max to 6. This will be explained in a second. So, this code generates a number between 0.5 and 6.5 eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJydW5pZihuID0gMSwgbWluID0gMC41LCBtYXggPSA2LjUpIn0= This code generates 10 numbers from 0.5 to 6.5. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJydW5pZihuID0gMTAsIG1pbiA9IDAuNSwgbWF4ID0gNi41KSJ9 runif() allows for non-integers, so we can make this like a real dice using round() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyb3VuZChydW5pZihuID0gMSwgbWluID0gMC41MDAwMDAwMCwgbWF4ID0gNi41MDAwMDAwMCkpIn0= If we want to simulate what would happen if 50 people in class all rolled a dice we set n to 50 eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyb3VuZChydW5pZihuID0gNTAsIG1pbiA9IDAuNSwgbWF4ID0gNi41KSkifQ== If we had 10000 people in our class: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyb3VuZChydW5pZihuID0gMTAwMDAsIG1pbiA9IDAuNSwgbWF4ID0gNi41KSkifQ== We can save this and plot it: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHNhdmUgaXRcbnJhbmRvbS51bmlmb3JtIDwtIHJvdW5kKHJ1bmlmKG4gPSAxMDAwMCwgbWluID0gMC41LCBtYXggPSA2LjQ5OTk5OTkpKVxuXG4jIHBsb3QgaXRcbmhpc3QocmFuZG9tLnVuaWZvcm0pIn0= The height of the histogram is almost level, indicating that this is a uniform distribution. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHNhdmUgaXRcbnJhbmRvbS51bmlmb3JtIDwtIHJvdW5kKHJ1bmlmKG4gPSAxMDAwLCBtaW4gPSAwLjUsIG1heCA9IDYuNSkpXG5cbiMgcGxvdCBpdFxuaGlzdChyYW5kb20udW5pZm9ybSkifQ== The code above works if the probability of each number (1, 2, 3…) is the same for all values, as for a fair dice. We can get a similar result more dirctly using the function sample(), which acts like a virtual “pulling numbers from a hat” or rolling a dice. First I make a vector to represent my die eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkaWNlIDwtIGMoMSwyLDMsNCw1LDYpIn0= I can roll it once like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzYW1wbGUoZGljZSwgc2l6ZSA9IDEpIn0= I can roll it twice like this; replace = T means that the same value can occur (its like pulling numbers from a hat and putting each number back in to make it available again). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzYW1wbGUoZGljZSwgc2l6ZSA9IDEsIHJlcGxhY2UgPSBUKSJ9 I can simulate 50 dice like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzYW1wbGUoZGljZSwgc2l6ZSA9IDUwLCByZXBsYWNlID0gVCkifQ== If I want to represent an unfair dice I can add a new arguement which allows me to define the probabilites. A fair dice would be this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwcm9icy5mYWlyIDwtIGMoMS82LCAxLzYsMS82LDEvNiwxLzYsMS82KVxuc2FtcGxlKGRpY2UsIHNpemUgPSAxLCByZXBsYWNlID0gVCwgIHByb2IgPSBwcm9icy5mYWlyKSJ9 A dice biased for 1could look like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwcm9icy5iaWFzZWQgPC0gYygyLzYsIDEvNiwgMS82LCAxLzYsIDEvNiwgMS82KVxuc2FtcGxlKGRpY2UsIHNpemUgPSAxLCByZXBsYWNlID0gVCwgIHByb2IgPSBwcm9icy5iaWFzZWQpIn0= Let me see if its biased. I simulate 1000 dice eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4IDwtIHNhbXBsZShkaWNlLCBzaXplID0gMTAwMCwgcmVwbGFjZSA9IFQsICBwcm9iID0gcHJvYnMuYmlhc2VkKVxuaGlzdCh4KSJ9 35.4 Lots of data in biology is normal Data from a dice are discrete: you can only have certain numbers (1, 2, 3…) and can’t have values in between (0.6). Also dice produce uniform striguation. In contrast, the normal distribution is common in the world. Many things are normal or normal-ish. The follow code plots human heights (note: this doesn’t distinquish XY from XX but is still fairly normal) eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYXRhKEdhbHRvbilcbmxpYnJhcnkoZ2dwdWJyKVxuZ2doaXN0b2dyYW0oZGF0YSA9IEdhbHRvbiwgeCA9IFwiY2hpbGRcIikifQ== The code below plots data on the size of flower petals by species. The middle panel is fairly normal. The left panel is normalish, but squished becuase the values are small and you can’t have flower sizes &lt;0. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYXRhKGlyaXMpXG5nZ2hpc3RvZ3JhbShkYXRhID0gaXJpcywgeCA9IFwiUGV0YWwuTGVuZ3RoXCIsIGZhY2V0LmJ5ID0gXCJTcGVjaWVzXCIpIn0= 35.5 Simulating the normal distribution We can simulate normal data in R using the rnorm function. Normal data is described by a mean (set here to 0) and a standard deviation (set here to 1). It has a typical bell-shaped curve. It is symmetrical - left of the mean has the same general shape as the data right of the mean. There is a mathematical formula that describes the shape of the curve, and you can generate random numbers from this. When you look at a normal distribution, the higher a given part of a curve is, the more likely a value under that part is to be randomly select. So values near the mean occur most commonly, while values far from the mean become increasinly less likely to occur. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJuIDwtIDEwMDBcbm1lYW4wIDwtIDBcbnNkMSA8LSAxXG5cbm5vcm1hbC5kYXRhIDwtIHJub3JtKG4gPSBuLCBcbiAgICAgICAgICAgICAgICAgICAgIG1lYW4gPSBtZWFuMCwgXG4gICAgICAgICAgICAgICAgICAgICBzZCA9IHNkMSkifQ== We can quickly plot it with hist() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoaXN0KG5vcm1hbC5kYXRhKVxuYWJsaW5lKHYgPSBtZWFuMCwgY29sID0gMikifQ== 35.6 The extreme value distribution Extreme value distributions are skewed and have a long tail. The evd package allows us to simulate extreme value data s BLAST theory uses a particular extreme value distribution, the Gumbel distribution. We can simulate data from this distribution with rgumbel() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJleHRyZW1lLmRhdGEgPC0gcmd1bWJlbChuID0gbiwgbG9jPW1lYW4wLCBzY2FsZT0xKSJ9 We can plot the data like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoaXN0KGV4dHJlbWUuZGF0YSlcbmFibGluZSh2ID0gbWVhbjAsIGNvbCA9IDIpIn0= If you’ve taken a stats class you may have taken the log of a data set to make it more normal-like. If you do this with data that follows the extreme value distribution it doens’t help - the data still don’t look normal. Instead of being skewed one way, the skew is just flipped the other. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoaXN0KGxvZyhleHRyZW1lLmRhdGEpKVxuYWJsaW5lKHYgPSBtZWFuMCwgY29sID0gMikifQ== 35.7 Replicating Figure 4.14 This code evokes Pevsner Figrure 4.14. You don’t need to know these functions. Note that the main differences correspond to values around -2 and 2. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyYW5nZS54LmF4aXMgPC0gc2VxKGZyb20gPSAtNSx0byA9IDUsbGVuZ3RoLm91dCA9IDEwMDApXG5ub3JtLmN1cnZlICAgIDwtIGRub3JtKCAgeCA9IHJhbmdlLnguYXhpcywgbWVhbiA9IG1lYW4wLCBzZCA9IHNkMSlcbmV4dHJlbWUuY3VydmUgPC0gZGd1bWJlbCh4ID0gcmFuZ2UueC5heGlzLCBsb2MgPSBtZWFuMCwgc2NhbGUgPSAxKVxuXG5wbG90KG5vcm0uY3VydmV+cmFuZ2UueC5heGlzLHR5cGUgPSBcImxcIilcbnBvaW50cyhleHRyZW1lLmN1cnZlfnJhbmdlLnguYXhpcyx0eXBlID0gXCJsXCIsIGx0eSA9IDIsIGNvbCA9IDIpIn0= 35.8 Why do we care? The starting point for most statistics is the normal distribution. This is where we get z-scores, most p-values, standard errors, and most 95% confidence intervals. When we don’t use normal distributions, we use other common distributions (eg the binomial distribution for binary data, the poisson for count data). None of these common distributions work if we want to do any statistics with DNA alginment; we need tow rok with the extreme value distribution. (Indeed, in 10 years of spending lots of time doing statiscs, this is the only application I’ve run in to of the EVD) "]]
