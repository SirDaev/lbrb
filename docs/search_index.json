[["index.html", "A Little Book of R for Bioinformatics 2.0 Preface to version 2.0", " A Little Book of R for Bioinformatics 2.0 Avirl Coghlan, with contributions by Nathan L. Brouwer 2021-07-15 Preface to version 2.0 Welcome to A Little Book of R for Bioinformatics 2.0!. This book is based on the original A Little Book of R for Bioinformatics by Dr. Avril Coghlan (Hereafter “ALBRB 1.0”). Dr. Coghlan’s book was one of the first and most thorough introductions to using R for bioinformatics, and was generously published under the Creative Commons 3.0 Attribution License (CC BY 3.0). In addition to describing how to do bioinformatics in R, Coghlan provided numerous functions to facilitate important tasks, practice questions, and references to further reading. ALBRB 1.0 was extremely useful to me when I was learning bioinformatics and computational biology. In this version of the book, which I’ll refer to as ALBRB 2.0, I have adapted Dr. Coghlan’s original book to suit my own teaching needs. Below I’ve outlined the general types of changes I’ve made to the original book. I have tried to link back to the original content that these updates are derived from and note how changes were made. Any errors or inconsistencies should be ascribed to me, not Dr. Coghlan. If you have any feedback, please email me at brouwern@gmail.com Nathan Brouwer, June 2021 Changes implemented in ALBRB 2.0 by Nathan Brouwer Converted the entire book to RMarkdown and published it via bookdown. Added instructions for using RStudio and RStudio Cloud. Updated instructions to reflect any changes in software, including changes to how the bioinformatics repository Bioconductor now works. Split up chapters into smaller units. Reorganized the order of some material. Added links to the book I am developing, Computational Biology for All. Moved most functions and datasets to my teaching package compbio4all. Changed some plotting to ggplot2 or ggpubr. Added additional subheadings Added vocab and function lists to the beginning of many chapters At times replaced non-biological examples with biological ones. Change from British to American English (Sorry!Couldn’t help myself.) Provided additional links to external resources. Added use or rentrez for querying NCBI databases "],["how-to-review-this-book.html", "Chapter 1 How to review this book 1.1 File format 1.2 What can you do? 1.3 Adding comments", " Chapter 1 How to review this book 1.1 File format These lessons are written in RStudio using RMarkdown. Each .RMd file is a mix of test, written in plain format, and code chunks, which look like this Code chunks start with there apostrophes and {r}, like this: ```{r}. They end with three apostrophes```. They will appear gray when opened up in RStudio but be white in the normal R code editor or other text editor. 1.2 What can you do? Read and fix typos : ) Add comments within the file Email me general comments about the files (structure, topics, confusing parts etc) 1.3 Adding comments You’re welcome to add comments anywhere to the files, do the exercises and type up the key, propose you own exercises, etc. 1.3.1 HTML-tagged comments The easiest way is to type a comment into the normal text part of the .Rmd file and then surround it with an html comment tag. A comment saying “A comment” will therefore look like this: In RStudio you can type up a comment, highlight it then hit Shift+Control+C on a PC or Shift+Command+C on a mac. 1.3.2 Code chunk comments Another way to add a comment is to make a RMarkdown code chunk thne type up your comments in it by commenting out each line, like the one below. Key to doing this is to put eval = F, echo = F in the braces after the r. eval = F, echo = F tells RStudio to leave that alone when the .Rmd file gets rendered into and web page or PDF. In RStudio you can add code chunks with a shortcut key. On a Mac the shortcut is OPTION + COMMAND + I. 1.3.3 Keys to exercise Some files will have exercises at the end. I don’t always include the key, and you’re welcome to try the exercise and type up a key (or fix any errors in mine). As for code chunk comments include eval = F, echo = F in the braces so the key won’t appear when rendered. So a problem and its key would look something like this 1.3.4 Problem - fix this code print(correct answer) "],["test-audio-link.html", "Chapter 2 Test audio link", " Chapter 2 Test audio link Here is an example of an audio link embedded in a bookdown book. knitr::include_url(&quot;https://www.genome.gov/sites/default/files/tg/en/narration/single_nucleotide_polymorphisms_snps.mp3&quot;, height = &quot;50px&quot;) "],["test-shiny-app.html", "Chapter 3 Test shiny app", " Chapter 3 Test shiny app Here is an example of a Shiny app embedded in a bookdown book. knitr::include_app(url = &quot;https://wrightaprilm.shinyapps.io/treesiftr_app/&quot;) "],["test-youtube-vidoe.html", "Chapter 4 Test YouTube vidoe", " Chapter 4 Test YouTube vidoe Here is an example of a YouTube video embedded in a bookdown book. via knitr chunk knitr::include_url(&quot;https://www.youtube.com/watch?v=zNzZ1PfUDNk&amp;feature=youtu.be&quot;) "],["test-webpage-insertion.html", "Chapter 5 Test webpage insertion", " Chapter 5 Test webpage insertion knitr::include_url(url =&quot;https://docs.google.com/spreadsheets/d/18dt7cYHAaszV5Iq8Y-7YOEFnv6hIXbD39Vn75-c3fQo/edit?usp=sharing&quot;) "],["datacamp-test.html", "Chapter 6 Datacamp test", " Chapter 6 Datacamp test By default, tutorial will convert all R chunks. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJhIDwtIDJcbmIgPC0gM1xuXG5hICsgYiJ9 "],["downloading-r.html", "Chapter 7 Downloading R 7.1 Preface 7.2 Introduction to R 7.3 Installing R 7.4 Starting R", " Chapter 7 Downloading R By: Avril Coghlan Adapted, edited and expanded: Nathan Brouwer (brouwern@gmail.com) under the Creative Commons 3.0 Attribution License (CC BY 3.0). 7.1 Preface The following introduction to R is based on the first part of “How to install R and a Brief Introduction to R” by Avril Coghlan, which was released under the Creative Commons 3.0 Attribution License (CC BY 3.0). For additional information see the Appendices and “Getting R onto your computer”. 7.2 Introduction to R R (www.r-project.org) is a commonly used free statistics software. R allows you to carry out statistical analyses in an interactive mode, as well as allowing programming. 7.3 Installing R To use R, you first need to install the R program on your computer. 7.3.1 Installing R on a Windows PC These instructions will focus on installing R on a Windows PC. However, I will also briefly mention how to install R on a Macintosh or Linux computer (see below). These steps have not been checked as of 8/13/2019 so there may be small variations in what the prompts are. Installing R, however, is basically that same as any other program. Clicking “Yes” etc on everything should work. PROTIP: Even if you have used R before its good to regularly update it to avoid conflicts with recently produced software. Minor updates of R are made very regularly (approximately every 6 months), as R is actively being improved all the time. It is worthwhile installing new versions of R a couple times a year, to make sure that you have a recent version of R (to ensure compatibility with all the latest versions of the R packages that you have downloaded). To install R on your Windows computer, follow these steps: Go to https://cran.r-project.org/ Under “Download and Install R”, click on the “Windows” link. Under “Subdirectories”, click on the “base” link. On the next page, you should see a link saying something like “Download R 4.1.0 for Windows” (or R X.X.X, where X.X.X gives the version of the program). Click on this link. You may be asked if you want to save or run a file “R-x.x.x-win32.exe”. Choose “Save” and save the file. Then double-click on the icon for the file to run it. You will be asked what language to install it in. The R Setup Wizard will appear in a window. Click “Next” at the bottom of the R Setup wizard window. The next page says “Information” at the top. Click “Next” again. The next page says “Select Destination Location” at the top. By default, it will suggest to install R on the C drive in the “Program Files” directory on your computer. Click “Next” at the bottom of the R Setup wizard window. The next page says “Select components” at the top. Click “Next” again. The next page says “Startup options” at the top. Click “Next” again. The next page says “Select start menu folder” at the top. Click “Next” again. The next page says “Select additional tasks” at the top. Click “Next” again. R should now be installing. This will take about a minute. When R has finished, you will see “Completing the R for Windows Setup Wizard” appear. Click “Finish”. To start R, you can do one of the following steps: Check if there is an “R” icon on the desktop of the computer that you are using. If so, double-click on the “R” icon to start R. If you cannot find an “R” icon, try the next step instead. Click on the “Start” button at the bottom left of your computer screen, and then choose “All programs”, and start R by selecting “R” (or R X.X.X, where X.X.X gives the version of R) from the menu of programs. The R console (a rectangle) should pop up: 7.3.2 How to install R on non-Windows computers (eg. Macintosh or Linux computers) These steps have not been checked as of 8/13/2019 so there may be small variations in what the prompts are. Installing R, however, is basically that same as any other program. Clicking “Yes” etc on everything should work. The instructions above are for installing R on a Windows PC. If you want to install R on a computer that has a non-Windows operating system (for example, a Macintosh or computer running Linux, you should download the appropriate R installer for that operating system at https://cran.r-project.org/ and follow the R installation instructions for the appropriate operating system at https://cran.r-project.org/doc/FAQ/R-FAQ.html#How-can-R-be-installed_003f . 7.4 Starting R To start R, Check if there is an R icon on the desktop of the computer that you are using. If so, double-click on the R icon to start R. If you cannot find an R icon, try the next step instead. You can also start R from the Start menu in Windows. Click on the “Start” button at the bottom left of your computer screen, and then choose “All programs”, and start R by selecting “R” (or R X.X.X, where X.X.X gives the version of R, e.g.. R 2.10.0) from the menu of programs. Say “Hi” to R and take a quick look at how it looks. Now say “Goodbye”, because we will never actually do any work in this version of R; instead, we’ll use the RStudio IDE (integrated development environment). "],["installing-the-rstudio-ide.html", "Chapter 8 Installing the RStudio IDE 8.1 Getting to know RStudio 8.2 RStudio versus RStudio Cloud", " Chapter 8 Installing the RStudio IDE By: Nathan Brouwer The name “R” refers both to the programming language and the program that runs that language. When you download itR* there is also a basic GUI (graphical user interface) that you can access via the R icon. Other GUIs are available, and the most popular currently is RStudio. RStudio a for-profit company that is a main driver of development of R. Much of what they produce has free basic versions or is entirely free. They produce software (RStudio), cloud-based applications (RStudio Cloud), and web server infrastructure for business applications of R. A brief overview of installing RStudio can be found here “Getting RStudio on to your computer” 8.1 Getting to know RStudio For a brief overview of RStudio see “Getting started with RStudio” A good overview of what the different parts of RStudio can be seen in the image in this tweet: https://twitter.com/RLadiesNCL/status/1138812826917724160?s=20 8.2 RStudio versus RStudio Cloud RStudio and RStudio cloud work almost identically, so anything you read about RStudio will apply to RStudio Cloud. RStudio is easy to download an use, but RStudio Cloud eliminates even the minor hiccups that occur. Free accounts with RStudio Cloud allow up to 15 hours per month, which is enough for you to get a taste for using R. "],["installing-r-packages.html", "Chapter 9 Installing R packages 9.1 Downloading packages with the RStudio IDE 9.2 Downloading packages with the function install.packages() 9.3 Using packages after they are downloaded", " Chapter 9 Installing R packages By: Avril Coghlan. Adapted, edited and expanded: Nathan Brouwer under the Creative Commons 3.0 Attribution License (CC BY 3.0). R is a programming language, and packages (aka libraries) are bundles of software built using R. Most sessions using R involve using additional R packages. This is especially true for bioinformatics and computational biology. NOTE: If you are working in an RStudio Cloud environment organized by someone else (e.g. a course instructor), they likely are taking care of many of the package management issues. The following information is still useful to be familiar with. 9.1 Downloading packages with the RStudio IDE There is a point-and-click interface for installing R packages in RStudio. There is a brief introduction to downloading packages on this site: http://web.cs.ucla.edu/~gulzar/rstudio/ I’ve summarized it here: “Click on the”Packages\" tab in the bottom-right section and then click on “Install”. The following dialog box will appear. In the “Install Packages” dialog, write the package name you want to install under the Packages field and then click install. This will install the package you searched for or give you a list of matching package based on your package text. 9.2 Downloading packages with the function install.packages() The easiest way to install a package if you know its name is to use the R function install.packages()`. Note that it might be better to call this “download.packages” since after you install it, you also have to load it! Frequently I will include install.packages(...) at the beginning of a chapter the first time we use a package to make sure the package is downloaded. Note, however, that if you already have downloaded the package, running install.packages(...) will download a new copy. While packages do get updated from time to time, but its best to re-run install.packages(...) only occassionaly. We’ll download a package used for plotting called ggplot2, which stands for “Grammar of Graphics.” ggplot2 was developed by Dr. Hadley Wickham, who is now the Chief Scientists for RStudio. To download ggplot2, run the following command: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpbnN0YWxsLnBhY2thZ2VzKFwiZ2dwbG90MlwiKSAjIG5vdGUgdGhlIFwiIFwiIn0= Often when you download a package you’ll see a fair bit of angry-looking red text, and sometime other things will pop up. Usually there’s nothing of interest here, but sometimes you need to read things carefully over it for hints about why something didn’t work. 9.3 Using packages after they are downloaded To actually make the functions in package accessible you need to use the library() command. Note that this is not in quotes. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGdncGxvdDIpICMgbm90ZTogTk8gXCIgXCIifQ== "],["installing-bioconductor.html", "Chapter 10 Installing Bioconductor 10.1 Bioconductor 10.2 Installing BiocManager 10.3 The ins and outs of package installation 10.4 Actually loading a package", " Chapter 10 Installing Bioconductor By: Avril Coghlan. Adapted, edited and expanded: Nathan Brouwer under the Creative Commons 3.0 Attribution License (CC BY 3.0), including details on install Bioconductor and common prompts and error messages that appear during installation. 10.1 Bioconductor R packages (aka “libraries”) can live in many places. Most are accessed via CRAN, the Comprehensive R Archive Network. The bioinformatics and computational biology community also has its own package hosting system called Bioconductor. R has played an important part in the development and application of bioinformatics techniques in the 21th century. Bioconductor 1.0 was released in 2002 with 15 packages. As of winter 2021, there are almost 2000 packages in the current release! NOTE: If you are working in an RStudio Cloud environment organized by someone else (eg a course instructor), they likely are taking care of most of package management issues, inlcuding setting up Bioconductor. The following information is still useful to be familiar with. To interface with Bioconductor you need the BiocManager package. The Bioconductor people have put BiocManager on CRAN to allow you to set up interactions with Bioconductor. See the BiocManager documentation for more information (https://cran.r-project.org/web/packages/BiocManager/vignettes/BiocManager.html). Note that if you have an old version of R you will need to update it to interact with Bioconductor. 10.2 Installing BiocManager BiocManager can be installed using the install.packages() packages command. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpbnN0YWxsLnBhY2thZ2VzKFwiQmlvY01hbmFnZXJcIikgIyBSZW1lbWJlciB0aGUgXCIgIFwiOyBkb24ndCB3b3JyeSBhYm91dCB0aGUgcmVkIHRleHQifQ== Once downloaded, BioManager needs to be explicitly loaded into your active R session using library() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KEJpb2NNYW5hZ2VyKSAjIG5vIHF1b3RlczsgYWdhaW4sIGlnbm9yZSB0aGUgcmVkIHRleHQifQ== Individual Bioconductor packages can then be downloaded using the install() command. An essential packages is Biostrings. To do this , eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCaW9jTWFuYWdlcjo6aW5zdGFsbChcIkJpb3N0cmluZ3NcIikifQ== 10.3 The ins and outs of package installation IMPORANT Bioconductor has many dependencies - other packages which is relies on. When you install Bioconductor packages you may need to update these packages. If something seems to not be working during this process, restart R and begin the Bioconductor installation process until things seem to work. Below I discuss the series of prompts I had to deal with while re-installing Biostrings while editing this chapter. 10.3.1 Updating other packages when downloading a package When I re-installed Biostrings while writing this I was given a HUGE blog of red test that contained this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiInZ2V0T3B0aW9uKFwicmVwb3NcIiknIHJlcGxhY2VzIEJpb2NvbmR1Y3RvciBzdGFuZGFyZCByZXBvc2l0b3JpZXMsIHNlZSAnP3JlcG9zaXRvcmllcycgZm9yXG5kZXRhaWxzXG5cbnJlcGxhY2VtZW50IHJlcG9zaXRvcmllczpcbiAgICBDUkFOOiBodHRwczovL2NyYW4ucnN0dWRpby5jb20vXG5cbkJpb2NvbmR1Y3RvciB2ZXJzaW9uIDMuMTEgKEJpb2NNYW5hZ2VyIDEuMzAuMTYpLCBSIDQuMC41ICgyMDIxLTAzLTMxKVxuT2xkIHBhY2thZ2VzOiAnYWRlNCcsICdhcGUnLCAnYXN0ZXInLCAnYmF5ZXN0ZXN0UicsICdiaW8zZCcsICdiaXRvcHMnLCAnYmxvZ2Rvd24nLFxuICAnYm9va2Rvd24nLCAnYnJpbycsICdicm9vbScsICdicm9vbS5taXhlZCcsICdicm9vbUV4dHJhJywgJ2JzbGliJywgJ2NhY2hlbScsICdjYWxscicsXG4gICdjYXInLCAnY2lyY2xpemUnLCAnY2xhc3MnLCAnY2xpJywgJ2NsdXN0ZXInLCAnY29sb3JzcGFjZScsICdjb3JycGxvdCcsICdjcHAxMScsICdjdXJsJyxcbiAgJ2RldnRvb2xzJywgJ0RIQVJNYScsICdkb0J5JywgJ2RwbHlyJywgJ0RUJywgJ2UxMDcxJywgJ2VsbGlwc2lzJywgJ2VtbWVhbnMnLCAnZW1vamlmb250JyxcbiAgJ2V4dFJlbWVzJywgJ2ZhbnNpJywgJ2ZsZXh0YWJsZScsICdmb3JlY2FzdCcsICdmb3JtYXRSJywgJ2dhcCcsICdnYXJnbGUnLCAnZ2VydCcsICdHR2FsbHknLFxuICAnZ2dmb3J0aWZ5JywgJ2dncGxvdDInLCAnZ2dzaWduaWYnLCAnZ2dWZW5uRGlhZ3JhbScsICdnaCcsICdnbG1tVE1CJywgJ2dvb2dsZWRyaXZlJyxcbiAgJ2d0b29scycsICdoYXZlbicsICdoaWdocicsICdobXMnLCAnaHRtbFRhYmxlJywgJ2h0dHB1dicsICdodXh0YWJsZScsICdqcXVlcnlsaWInLFxuICAnS2VyblNtb290aCcsICdrbml0cicsICdsYXRlcicsICdsYXR0aWNlJywgJ2xtZTQnLCAnbWFnaWNrJywgJ21hbmlwdWxhdGVXaWRnZXQnLCAnTUFTUycsXG4gICdNYXRyaXgnLCAnbWF0cml4Y2FsYycsICdtYXRyaXhTdGF0cycsICdtZ2N2JywgJ21pbWUnLCAnbXVsdGNvbXAnLCAnbXZ0bm9ybScsICdubmV0JyxcbiAgJ29wZW5zc2wnLCAnb3Blbnhsc3gnLCAncGFyYW1ldGVycycsICdwQnJhY2tldHMnLCAncGRmdG9vbHMnLCAncGhhbmdvcm4nLCAncGh5dG9vbHMnLFxuICAncGlsbGFyJywgJ3Bsb3RseScsICdwcm9jZXNzeCcsICdwcm94eScsICdxZ2FtJywgJ3F1YW50cmVnJywgJ3JhZ2cnLCAnUmNwcCcsXG4gICdSY3BwQXJtYWRpbGxvJywgJ3JlbW90ZXMnLCAncmdsJywgJ3JpbycsICdySmF2YScsICdybGFuZycsICdybWFya2Rvd24nLCAncm9idXN0YmFzZScsXG4gICdyc2Nvbm5lY3QnLCAncnZlcnNpb25zJywgJ3NhbmR3aWNoJywgJ3Nhc3MnLCAnc2VnbWVudGVkJywgJ3NlcWlucicsICdzZXFtYWdpY2snLCAnc2VydnInLFxuICAnc2YnLCAnc2hhcGUnLCAnc3BhdGlhbCcsICdzdGF0bW9kJywgJ3N0cmluZ2knLCAnc3lzdGVtZm9udHMnLCAndGVzdHRoYXQnLCAndGV4dHNoYXBpbmcnLFxuICAndGliYmxlJywgJ3RpZHlzZWxlY3QnLCAndGlkeXRyZWUnLCAndGlueXRleCcsICd0dWZ0ZScsICdVbmlwcm90UicsICd1bml0cycsICd2Y3RycycsXG4gICd2aXJpZGlzJywgJ3ZpcmlkaXNMaXRlJywgJ3dpdGhyJywgJ3hmdW4nLCAnemlwJyJ9 Hidden at the bottom was a prompt: “Update all/some/none? [a/s/n]:” Its a little vague, but what it wants me to do is type in a, s or n and press enter to tell it what to do. I almost always chose “a”, though this may take a while to update everything. 10.3.2 Packages “from source” You are likely to get lots of random-looking feedback from R when doing Bioconductor-related installations. Look carefully for any prompts as the very last line. While updating Biostrings I was told: “There are binary versions available but the source versions are later:” and given a table of packages. I was then asked “Do you want to install from sources the packages which need compilation? (Yes/no/cancel)” I almost always chose “no”. 10.3.3 More on angry red text After the prompt about packages from source, R proceeded to download a lot of updates to packages, which took a few minutes. Lots of red text scrolled by, but this is normal. 10.4 Actually loading a package Again, to actually load the Biostrings package into your active R sessions requires the libary() command: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KEJpb3N0cmluZ3MpIn0= As you might expect, there’s more red text scrolling up my screen! I can tell that is actually worked because at the end of all the red stuff is the R prompt of “&gt;” and my cursor. "],["a-brief-introduction-to-r.html", "Chapter 11 A Brief introduction to R 11.1 Vocabulary 11.2 R functions 11.3 Interacting with R 11.4 Variables in R 11.5 Arguments 11.6 Help files with help() and ? 11.7 Searching for functions with help.search() and RSiteSearch() 11.8 More on functions 11.9 Quiting R 11.10 Links and Further Reading", " Chapter 11 A Brief introduction to R By: Avril Coghlan. Adapted, edited and expanded: Nathan Brouwer under the Creative Commons 3.0 Attribution License (CC BY 3.0). This chapter provides a brief introduction to R. At the end of are links to additional resources for getting started with R. 11.1 Vocabulary scalar vector list class numeric character assignment elements of an object indices attributes of an object argument of a function 11.2 R functions &lt;- [ ] $ table() function c() log10() help(), ? help.search() RSiteSearch() mean() return() q() 11.3 Interacting with R You will type R commands into the RStudio console in order to carry out analyses in R. In the RStudio console you will see the R prompt starting with the symbol “&gt;”. “&gt;” will always be there at the beginning of each new command - don’t try to delete it! Moreover, you never need to type it. We type the commands needed for a particular task after this prompt. The command is carried out by R after you hit the Return key. Once you have started R, you can start typing commands into the RStudio console, and the results will be calculated immediately, for example: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIyKjMifQ== Note that prior to the output of “6” it shows “[1]”. Now subtraction: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIxMC0zIn0= Again, prior to the output of “7” it shows “[1]”. R can act like a basic calculator that you type commands in to. You can also use it like a more advanced scientific calculator and create variables that store information. All variables created by R are called objects. In R, we assign values to variables using an arrow-looking function &lt;- the assignment operator. For example, we can assign the value 2*3 to the variable x using the command: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4IDwtIDIqMyJ9 To view the contents of any R object, just type its name, press enter, and the contents of that R object will be displayed: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4In0= 11.4 Variables in R There are several different types of objects in R with fancy math names, including scalars, vectors, matrices (singular: matrix), arrays, dataframes, tables, and lists. The scalar** variable x above is one example of an R object. While a scalar variable such as x has just one element, a vector consists of several elements. The elements in a vector are all of the same type (e.g.. numbers or alphabetic characters), while lists may include elements such as characters as well as numeric quantities. Vectors and dataframes are the most common variables you’ll use. You’ll also encounter matrices often, and lists are ubiquitous in R but beginning users often don’t encounter them because they remain behind the scenes. 11.4.1 Vectors To create a vector, we can use the c() (combine) function. For example, to create a vector called myvector that has elements with values 8, 6, 9, 10, and 5, we type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3RvciA8LSBjKDgsIDYsIDksIDEwLCA1KSAjIG5vdGU6IGNvbW1hcyBiZXR3ZWVuIGVhY2ggbnVtYmVyISJ9 To see the contents of the variable myvector, we can just type its name and press enter: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3RvciJ9 11.4.2 Vector indexing The [1] is the index of the first element in the vector. We can extract any element of the vector by typing the vector name with the index of that element given in square brackets [...]. For example, to get the value of the 4th element in the vector myvector, we type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3Rvcls0XSJ9 11.4.3 Character vectors Vectors can contain letters, such as those designating nucleic acids eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteS5zZXEgPC0gYyhcIkFcIixcIlRcIixcIkNcIixcIkdcIikifQ== They can also contain multi-letter strings: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteS5vbGlnb3MgPC0gYyhcIkFUQ0dDXCIsXCJUVFRDR0NcIixcIkNDQ0dDR1wiLFwiR0dHQ0dDXCIpIn0= 11.4.4 Lists NOTE: below is a discussion of lists in R. This is excellent information, but not necessary if this is your very very first time using R. In contrast to a vector, a list can contain elements of different types, for example, both numbers and letters. A list can even include other variables such as a vector. The list() function is used to create a list. For example, we could create a list mylist by typing: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteWxpc3QgPC0gbGlzdChuYW1lPVwiQ2hhcmxlcyBEYXJ3aW5cIiwgXG4gICAgICAgICAgICAgICB3aWZlPVwiRW1tYSBEYXJ3aW5cIiwgXG4gICAgICAgICAgICAgICBteXZlY3RvcikifQ== We can then print out the contents of the list mylist by typing its name: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteWxpc3QifQ== The elements in a list are numbered, and can be referred to using indices. We can extract an element of a list by typing the list name with the index of the element given in double square brackets (in contrast to a vector, where we only use single square brackets). We can extract the second element from mylist by typing: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteWxpc3RbWzJdXSAgIyBub3RlIHRoZSBkb3VibGUgc3F1YXJlIGJyYWNrZXRzIFtbLi4uXV0ifQ== As a baby step towards our next task, we can wrap index values as in the c() command like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteWxpc3RbW2MoMildXSAgIyBub3RlIHRoZSBkb3VibGUgc3F1YXJlIGJyYWNrZXRzIFtbLi4uXV0ifQ== The number 2 and c(2) mean the same thing. Now, we can extract the second AND third elements from mylist. First, we put the indices 2 and 3 into a vector c(2,3), then wrap that vector in double square brackets: [c(2,3)]. All together it looks like this. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteWxpc3RbYygyLDMpXSAjIG5vdGUgdGhlIGRvdWJsZSBicmFja2V0cyJ9 Elements of lists may also be named, resulting in a named lists. The elements may then be referred to by giving the list name, followed by “$”, followed by the element name. For example, mylist$name is the same as mylist[[1]] and mylist$wife is the same as mylist[[2]]: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteWxpc3Qkd2lmZSJ9 We can find out the names of the named elements in a list by using the attributes() function, for example: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJhdHRyaWJ1dGVzKG15bGlzdCkifQ== When you use the attributes() function to find the named elements of a list variable, the named elements are always listed under a heading “$names”. Therefore, we see that the named elements of the list variable mylist are called “name” and “wife”, and we can retrieve their values by typing mylist$name and mylist$wife, respectively. 11.4.5 Tables Another type of object that you will encounter in R is a table. The table() function allows you to total up or tabulate the number of times a value occurs within a vector. Tables are typically used on vectors containing character data, such as letters, words, or names, but can work on numeric data data. 11.4.5.1 Tables - The basics If we made a vector variable “nucleotides” containing the of a DNA molecule, we can use the table() function to produce a table variable that contains the number of bases with each possible nucleotides: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJiYXNlcyA8LSBjKFwiQVwiLCBcIlRcIiwgXCJBXCIsIFwiQVwiLCBcIlRcIiwgXCJDXCIsIFwiR1wiLCBcIkNcIiwgXCJHXCIpIn0= Now make the table eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0YWJsZShiYXNlcykifQ== We can store the table variable produced by the function table(), and call the stored table “bases.table”, by typing: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJiYXNlcy50YWJsZSA8LSB0YWJsZShiYXNlcykifQ== Tables also work on vectors containing numbers. First, a vector of numbers. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJudW1lcmljLnZlY3RlciA8LSBjKDEsMSwxLDEsMyw0LDQsNCw0KSJ9 Second, a table, showing how many times each number occurs. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0YWJsZShudW1lcmljLnZlY3RlcikifQ== 11.4.5.2 Tables - further details To access elements in a table variable, you need to use double square brackets, just like accessing elements in a list. For example, to access the fourth element in the table bases.table (the number of Ts in the sequence), we type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJiYXNlcy50YWJsZVtbNF1dICAjIGRvdWJsZSBicmFja2V0cyEifQ== Alternatively, you can use the name of the fourth element in the table (“John”) to find the value of that table element: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJiYXNlcy50YWJsZVtbXCJUXCJdXSJ9 11.5 Arguments Functions in R usually require arguments, which are input variables (i.e.. objects) that are passed to them, which they then carry out some operation on. For example, the log10() function is passed a number, and it then calculates the log to the base 10 of that number: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsb2cxMCgxMDApIn0= There’s a more generic function, log(), where we pass it not only a number to take the log of, but also the specific base of the logarithm. To take the log base 10 with the log() function we do this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsb2coMTAwLCBiYXNlID0gMTApIn0= We can also take logs with other bases, such as 2: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsb2coMTAwLCBiYXNlID0gMikifQ== 11.6 Help files with help() and ? In R, you can get help about a particular function by using the help() function. For example, if you want help about the log10() function, you can type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoZWxwKFwibG9nMTBcIikifQ== When you use the help() function, a box or web pag will show up in one of the panes of RStudio with information about the function that you asked for help with. You can also use the ? next to the function like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiI/bG9nMTAifQ== Help files are a mixed bag in R, and it can take some getting used to them. An excellent overview of this is Kieran Healy’s “How to read an R help page.” 11.7 Searching for functions with help.search() and RSiteSearch() If you are not sure of the name of a function, but think you know part of its name, you can search for the function name using the help.search() and RSiteSearch() functions. The help.search() function searches to see if you already have a function installed (from one of the R packages that you have installed) that may be related to some topic you’re interested in. RSiteSearch() searches all R functions (including those in packages that you haven’t yet installed) for functions related to the topic you are interested in. For example, if you want to know if there is a function to calculate the standard deviation (SD) of a set of numbers, you can search for the names of all installed functions containing the word “deviation” in their description by typing: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoZWxwLnNlYXJjaChcImRldmlhdGlvblwiKSJ9 Among the functions that were found, is the function sd() in the stats package (an R package that comes with the base R installation), which is used for calculating the standard deviation. Now, instead of searching just the packages we’ve have on our computer let’s search all R packages on CRAN. Let’s look for things related to DNA. Note that RSiteSearch() doesn’t provide output within RStudio, but rather opens up your web browser for you to display the results. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJSU2l0ZVNlYXJjaChcIkROQVwiKSJ9 The results of the RSiteSearch() function will be hits to descriptions of R functions, as well as to R mailing list discussions of those functions. 11.8 More on functions We can perform computations with R using objects such as scalars and vectors. For example, to calculate the average of the values in the vector myvector (i.e.. the average of 8, 6, 9, 10 and 5), we can use the mean() function: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJtZWFuKG15dmVjdG9yKSAjIG5vdGU6IG5vIFwiIFwiIn0= We have been using built-in R functions such as mean(), length(), print(), plot(), etc. 11.8.1 Writing your own functions NOTE: *Writing your own functions is an advanced skills. New users can skip this section. We can also create our own functions in R to do calculations that you want to carry out very often on different input data sets. For example, we can create a function to calculate the value of 20 plus square of some input number: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteWZ1bmN0aW9uIDwtIGZ1bmN0aW9uKHgpIHsgcmV0dXJuKDIwICsgKHgqeCkpIH0ifQ== This function will calculate the square of a number (x), and then add 20 to that value. The return() statement returns the calculated value. Once you have typed in this function, the function is then available for use. For example, we can use the function for different input numbers (e.g.. 10, 25): eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteWZ1bmN0aW9uKDEwKSJ9 11.9 Quiting R To quit R either close the program, or type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJxKCkifQ== 11.10 Links and Further Reading Some links are included here for further reading. For a more in-depth introduction to R, a good online tutorial is available on the “Kickstarting R” website, cran.r-project.org/doc/contrib/Lemon-kickstart. There is another nice (slightly more in-depth) tutorial to R available on the “Introduction to R” website, cran.r-project.org/doc/manuals/R-intro.html. Chapter 3 of Danielle Navarro’s book is an excellent intro to the basics of R. "],["dna-descriptive-statics-part-1.html", "Chapter 12 DNA descriptive statics - Part 1 12.1 Preface 12.2 Writing TODO: 12.3 Introduction 12.4 Vocabulary 12.5 Functions 12.6 Preliminaries 12.7 Converting DNA from FASTA format 12.8 Length of a DNA sequence 12.9 Acknowledgements", " Chapter 12 DNA descriptive statics - Part 1 By: Avril Coghlan Adapted, edited and expanded: Nathan Brouwer (brouwern@gmail.com) under the Creative Commons 3.0 Attribution License (CC BY 3.0). 12.1 Preface This is a modification of “DNA Sequence Statistics (1)” from Avril Coghlan’s A little book of R for bioinformatics.. The text and code were originally written by Dr. Coghlan and distributed under the Creative Commons 3.0 license. 12.2 Writing TODO: Add biology introduction Work on flow organize intial sections (intro, vocab, preliminaries) 12.3 Introduction 12.4 Vocabulary GC content DNA words scatterplots, histograms, piecharts, and boxplots 12.5 Functions seqinr::GC() seqinr::count() 12.6 Preliminaries eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGNvbXBiaW80YWxsKVxubGlicmFyeShzZXFpbnIpIn0= 12.7 Converting DNA from FASTA format In a previous exercise we downloaded and examined DNA sequence in the FASTA format. The sequence we worked with is also stored as a data file within the compbio4all pa package and can be brought into memory using the data() command. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYXRhKFwiZGVuZ3Vlc2VxX2Zhc3RhXCIpIn0= We can look at this data object with the str() command eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHIoZGVuZ3Vlc2VxX2Zhc3RhKSJ9 This isn’t in a format we can work with directly so we’ll use the function fasta_cleaner() to set it up. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoZWFkZXIuIDwtIFwiPk5DXzAwMTQ3Ny4xIERlbmd1ZSB2aXJ1cyAxLCBjb21wbGV0ZSBnZW5vbWVcIlxuZGVuZ3Vlc2VxX3ZlY3RvciA8LSBjb21wYmlvNGFsbDo6ZmFzdGFfY2xlYW5lcihkZW5ndWVzZXFfZmFzdGEpIn0= Now check it out. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHIoZGVuZ3Vlc2VxX3ZlY3RvcikifQ== What we have here is each base of the sequence in a seperate slot of our vector. The first four bases are “AGTT” We can see the first one like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkZW5ndWVzZXFfdmVjdG9yWzFdIn0= The second one like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkZW5ndWVzZXFfdmVjdG9yWzJdIn0= The first and second like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkZW5ndWVzZXFfdmVjdG9yWzE6Ml0ifQ== and all four like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkZW5ndWVzZXFfdmVjdG9yWzE6NF0ifQ== 12.8 Length of a DNA sequence Once you have retrieved a DNA sequence, we can obtain some simple statistics to describe that sequence, such as the sequence’s total length in nucleotides. In the above example, we retrieved the DEN-1 Dengue virus genome sequence, and stored it in the vector variable dengueseq_vector To obtain the length of the genome sequence, we would use the length() function, typing: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsZW5ndGgoZGVuZ3Vlc2VxX3ZlY3RvcikifQ== The length() function will give you back the length of the sequence stored in variable dengueseq_vector, in nucleotides. The length() function actually gives the number of elements (slots) in the input vector that you passed to it, which in this case in the number of elements in the vector dengueseq_vector. Since each element of the vector dengueseq_vector contains one nucleotide of the DEN-1 Dengue virus sequence, the result for the DEN-1 Dengue virus genome tells us the length of its genome sequence (ie. 10735 nucleotides long). 12.8.1 Base composition of a DNA sequence An obvious first analysis of any DNA sequence is to count the number of occurrences of the four different nucleotides (“A”, “C”, “G”, and “T”) in the sequence. This can be done using the the table() function. For example, to find the number of As, Cs, Gs, and Ts in the DEN-1 Dengue virus sequence (which you have put into vector variable dengueseq_vector, using the commands above), you would type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0YWJsZShkZW5ndWVzZXFfdmVjdG9yKSJ9 This means that the DEN-1 Dengue virus genome sequence has 3426 As occurring throughout the genome, 2240 Cs, and so forth. 12.8.2 GC Content of DNA One of the most fundamental properties of a genome sequence is its GC content, the fraction of the sequence that consists of Gs and Cs, ie. the %(G+C). The GC content can be calculated as the percentage of the bases in the genome that are Gs or Cs. That is, GC content = (number of Gs + number of Cs)100/(genome length). For example, if the genome is 100 bp, and 20 bases are Gs and 21 bases are Cs, then the GC content is (20 + 21)100/100 = 41%. You can easily calculate the GC content based on the number of As, Gs, Cs, and Ts in the genome sequence. For example, for the DEN-1 Dengue virus genome sequence, we know from using the table() function above that the genome contains 3426 As, 2240 Cs, 2770 Gs and 2299 Ts. Therefore, we can calculate the GC content using the command: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIoMjI0MCsyNzcwKSoxMDAvKDM0MjYrMjI0MCsyNzcwKzIyOTkpIn0= Alternatively, if you are feeling lazy, you can use the GC() function in the SeqinR package, which gives the fraction of bases in the sequence that are Gs or Cs. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFpbnI6OkdDKGRlbmd1ZXNlcV92ZWN0b3IpIn0= The result above means that the fraction of bases in the DEN-1 Dengue virus genome that are Gs or Cs is 0.4666977. To convert the fraction to a percentage, we have to multiply by 100, so the GC content as a percentage is 46.66977%. 12.8.3 DNA words As well as the frequency of each of the individual nucleotides (“A”, “G”, “T”, “C”) in a DNA sequence, it is also interesting to know the frequency of longer DNA words, also referred to as genomic words. The individual nucleotides are DNA words that are 1 nucleotide long, but we may also want to find out the frequency of DNA words that are 2 nucleotides long (ie. “AA”, “AG”, “AC”, “AT”, “CA”, “CG”, “CC”, “CT”, “GA”, “GG”, “GC”, “GT”, “TA”, “TG”, “TC”, and “TT”), 3 nucleotides long (eg. “AAA”, “AAT”, “ACG”, etc.), 4 nucleotides long, etc. To find the number of occurrences of DNA words of a particular length, we can use the count() function from the R SeqinR package. The count() function only works with lower-case letters, so first we have to use the tolower() function to convert our upper class genome to lower case eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkZW5ndWVzZXFfdmVjdG9yIDwtdG9sb3dlcihkZW5ndWVzZXFfdmVjdG9yKSJ9 Now we can look for words. For example, to find the number of occurrences of DNA words that are 1 nucleotide long in the sequence dengueseq_vector, we type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFpbnI6OmNvdW50KGRlbmd1ZXNlcV92ZWN0b3IsIDEpIn0= As expected, this gives us the number of occurrences of the individual nucleotides. To find the number of occurrences of DNA words that are 2 nucleotides long, we type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFpbnI6OmNvdW50KGRlbmd1ZXNlcV92ZWN0b3IsIDIpIn0= Note that by default the count() function includes all overlapping DNA words in a sequence. Therefore, for example, the sequence “ATG” is considered to contain two words that are two nucleotides long: “AT” and “TG”. If you type help(‘count’), you will see that the result (output) of the function count() is a table object. This means that you can use double square brackets to extract the values of elements from the table. For example, to extract the value of the third element (the number of Gs in the DEN-1 Dengue virus sequence), you can type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkZW5ndWV0YWJsZV8yIDwtIHNlcWlucjo6Y291bnQoZGVuZ3Vlc2VxX3ZlY3RvciwyKVxuZGVuZ3VldGFibGVfMltbM11dIn0= The command above extracts the third element of the table produced by count(dengueseq_vector,1), which we have stored in the table variable denguetable. Alternatively, you can find the value of the element of the table in column “g” by typing: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkZW5ndWV0YWJsZV8yW1tcImFhXCJdXSJ9 Once you have table you can make a basic plot eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJiYXJwbG90KGRlbmd1ZXRhYmxlXzIpIn0= We can sort by the number of words using the sort() command eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzb3J0KGRlbmd1ZXRhYmxlXzIpIn0= Let’s save over the original object eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkZW5ndWV0YWJsZV8yIDwtIHNvcnQoZGVuZ3VldGFibGVfMikifQ== eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJiYXJwbG90KGRlbmd1ZXRhYmxlXzIpIn0= R will automatically try to optimize the appearance of the labels on the graph so you may not see all of them; no worries. R can also make pie charts. Piecharts only really work when there are a few items being plots, like the four bases. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkZW5ndWV0YWJsZV8xIDwtIHNlcWlucjo6Y291bnQoZGVuZ3Vlc2VxX3ZlY3RvciwxKSJ9 Make a piechart with pie() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwaWUoZGVuZ3VldGFibGVfMSkifQ== 12.8.4 Summary In this practical, have learned to use the following R functions: length() for finding the length of a vector or list table() for printing out a table of the number of occurrences of each type of item in a vector or list. These functions belong to the standard installation of R. You have also learnt the following R functions that belong to the SeqinR package: GC() for calculating the GC content for a DNA sequence count() for calculating the number of occurrences of DNA words of a particular length in a DNA sequence 12.9 Acknowledgements This is a modification of “DNA Sequence Statistics (1)” from Avril Coghlan’s A little book of R for bioinformatics.. Almost all of text and code was originally written by Dr. Coghlan and distributed under the Creative Commons 3.0 license. In “A little book…” Coghlan noted: “Many of the ideas for the examples and exercises for this chapter were inspired by the Matlab case studies on Haemophilus influenzae (www.computational-genomics.net/case_studies/haemophilus_demo.html) and Bacteriophage lambda (http://www.computational-genomics.net/case_studies/lambdaphage_demo.html) from the website that accompanies the book Introduction to Computational Genomics: a case studies approach by Cristianini and Hahn (Cambridge University Press; www.computational-genomics.net/book/).” 12.9.1 License The content in this book is licensed under a Creative Commons Attribution 3.0 License. https://creativecommons.org/licenses/by/3.0/us/ 12.9.2 Exercises Answer the following questions, using the R package. For each question, please record your answer, and what you typed into R to get this answer. Model answers to the exercises are given in Answers to the exercises on DNA Sequence Statistics (1). What are the last twenty nucleotides of the Dengue virus genome sequence? What is the length in nucleotides of the genome sequence for the bacterium Mycobacterium leprae strain TN (accession NC_002677)? Note: Mycobacterium leprae is a bacterium that is responsible for causing leprosy, which is classified by the WHO as a neglected tropical disease. As the genome sequence is a DNA sequence, if you are retrieving its sequence via the NCBI website, you will need to look for it in the NCBI Nucleotide database. How many of each of the four nucleotides A, C, T and G, and any other symbols, are there in the Mycobacterium leprae TN genome sequence? Note: other symbols apart from the four nucleotides A/C/T/G may appear in a sequence. They correspond to positions in the sequence that are are not clearly one base or another and they are due, for example, to sequencing uncertainties. or example, the symbol ‘N’ means ‘aNy base’, while ‘R’ means ‘A or G’ (puRine). There is a table of symbols at www.bioinformatics.org/sms/iupac.html. What is the GC content of the Mycobacterium leprae TN genome sequence, when (i) all non-A/C/T/G nucleotides are included, (ii) non-A/C/T/G nucleotides are discarded? Hint: look at the help page for the GC() function to find out how it deals with non-A/C/T/G nucleotides. How many of each of the four nucleotides A, C, T and G are there in the complement of the Mycobacterium leprae TN genome sequence? Hint: you will first need to search for a function to calculate the complement of a sequence. Once you have found out what function to use, remember to use the help() function to find out what are the arguments (inputs) and results (outputs) of that function. How does the function deal with symbols other than the four nucleotides A, C, T and G? Are the numbers of As, Cs, Ts, and Gs in the complementary sequence what you would expect? How many occurrences of the DNA words CC, CG and GC occur in the Mycobacterium leprae TN genome sequence? How many occurrences of the DNA words CC, CG and GC occur in the (i) first 1000 and (ii) last 1000 nucleotides of the Mycobacterium leprae TN genome sequence? 1.How can you check that the subsequence that you have looked at is 1000 nucleotides long? "],["programming-in-r-for-loops.html", "Chapter 13 Programming in R: for loops 13.1 Preface 13.2 Vocab 13.3 Functions 13.4 Basic for loops in in R 13.5 Challenge: complicated vectors of values", " Chapter 13 Programming in R: for loops By: Avril Coghlan Adapted, edited and expanded: Nathan Brouwer (brouwern@gmail.com) under the Creative Commons 3.0 Attribution License (CC BY 3.0). 13.1 Preface This is a modification of “DNA Sequence Statistics (1)” from Avril Coghlan’s A little book of R for bioinformatics.. The text and code was originally written by Dr. Coghlan and distributed under the Creative Commons 3.0 license. 13.2 Vocab for loop curly brackets 13.3 Functions for() print() 13.4 Basic for loops in in R In R, just as in programming languages such as Python, it is possible to write a for loop to carry out the same command several times. For example, say we have a pressing need to calculate the square the square of each number between 1 and 4. We could write for lines of code like this to do it: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIxXjJcbjJeMlxuM14yXG40XjIifQ== If we know how to write a for loop, we could do the same think like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJmb3IgKGkgaW4gMTo0KSB7IFxuICBwcmludCAoaSppKSBcbiAgfSJ9 In the for loop above, the variable i is a counter or index for the number of cycles through the loop. In the first cycle through the loop, the value of i is 1, and so i * i = 1 is printed out. In the second cycle through the loop, the value of i is 2, and so i * i = 4 is printed out. In the third cycle through the loop, the value of i is 3, and so i * i = 9 is printed out. The loop continues until the value of i is 4. Note that the commands that are to be carried out at each cycle of the for loop must be enclosed within curly brackets (“{” and “}”). You may be thinking “ok, so it took four lines of code to do 12 through 42 each on their own, and three lines to do it wit the loop; what’s the big deal?”. What if you need to do 1 through 100 squared for some reason? Now the for loop is a lot less work. You can also give a for loop a vector of numbers containing the values that you want the counter i to take in subsequent cycles. For example, you can make a vector containing the numbers 1, 2, 3, and 4, and write a for loop to print out the square of each number in vector avector: ## [1] 1 ## [1] 4 ## [1] 9 ## [1] 16 The results should be the same as before. 13.5 Challenge: complicated vectors of values Here’s a more complex example. If you don’t understand it don’t worry, its not something you’d probably do in practice. Challenge: How can we use a for loop to print out the square of every second number between, say, 1 and 10? The answer is to use the seq() function with “by = 2” to tell the for loop to take every second number between 1 and 10: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJmb3IgKGkgaW4gc2VxKDEsIDEwLCBieSA9IDIpKSB7IFxuICBwcmludCAoaSppKSBcbiAgfSJ9 In the first cycle of this loop, the value of i is 1, and so i * i = 1 is printed out. In the second cycle through the loop, the value of i is 3, and so i * i = 9 is printed out. The loop continues until the value of i is 9. In the fifth cycle through the loop, the value of i is 9, and so i * i = 81 is printed out. "],["mini-tutorial-vectors-in-r.html", "Chapter 14 Mini tutorial: Vectors in R 14.1 Preface 14.2 Vocab", " Chapter 14 Mini tutorial: Vectors in R By: Avril Coghlan Adapted, edited and expanded: Nathan Brouwer (brouwern@gmail.com) under the Creative Commons 3.0 Attribution License (CC BY 3.0). 14.1 Preface This is a modification of part of“DNA Sequence Statistics (2)” from Avril Coghlan’s A little book of R for bioinformatics.. Most of text and code was originally written by Dr. Coghlan and distributed under the Creative Commons 3.0 license. 14.2 Vocab base R scalar, vector, matrix regular expressions "],["functions-2.html", "Chapter 15 Functions 15.1 Vectors in R 15.2 Math on vectors 15.3 Functions on vectors 15.4 Operations with two vectors 15.5 Subsetting vectors 15.6 Sequences of numbers 15.7 Vectors can hold numeric or character data 15.8 Regular expressions can modify character data", " Chapter 15 Functions seq() is(), is.vector(), is.matrix() gsub() 15.1 Vectors in R Variables in R include scalars, vectors, and lists. Functions in R carry out operations on variables, for example, using the log10() function to calculate the log to the base 10 of a scalar variable x, or using the mean() function to calculate the average of the values in a vector variable myvector. For example, we can use log10() on a scalar object like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHN0b3JlIHZhbHVlIGluIG9iamVjdFxueCA8LSAxMDBcblxuIyB0YWtlIGxvZyBiYXNlIDEwIG9mIG9iamVjdFxubG9nMTAoeCkifQ== Note that while mathematically x is a single number, or a scalar, R considers it to be a vector: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpcy52ZWN0b3IoeCkifQ== There are many “is” commands. What is returned when you run is.matrix() on a vector? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpcy5tYXRyaXgoeCkifQ== Mathematically this is a bit odd, since often a vector is defined as a one-dimensional matrix, e.g., a single column or single row of a matrix. But in R land, a vector is a vector, and matrix is a matrix, and there are no explicit scalars. 15.2 Math on vectors Vectors can serve as the input for mathematical operations. When this is done R does the mathematical operation separately on each element of the vector. This is a unique feature of R that can be hard to get used to even for people with previous programming experience. Let’s make a vector of numbers: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3RvciA8LSBjKDMwLDE2LDMwMyw5OSwxMSwxMTEpIn0= What happens when we multiply myvector by 10? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3RvcioxMCJ9 R has taken each of the 6 values, 30 through 111, of myvector and multiplied each one by 10, giving us 6 results. That is, what R did was eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIzMCoxMCAgICAjIGZpcnN0IHZhbHVlIG9mIG15dmVjdG9yXG4xNioxMCAgICAjIHNlY29uZCB2YWx1ZSBvZiBteXZlY3RvclxuMzAzKjEwICAgIyAuLi4uXG45OSoxMFxuMTExKjEwICAgIyBsYXN0IHZhbHVlIG9mIG15dmVjdG9yIn0= The normal order of operations rules apply to vectors as they do to operations we’re more used to. So multiplying myvector by 10 is the same whether you put he 10 before or after vector. That is myvector\\*10 is the same as 10\\*myvector. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3RvcioxMFxuMTAqbXl2ZWN0b3IifQ== What happen when you subtract 30 from myvector? Write the code below. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3Rvci0zMCJ9 So, what R did was eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIzMC0zMCAgICAjIGZpcnN0IHZhbHVlIG9mIG15dmVjdG9yXG4xNi0zMCAgICAjIHNlY29uZCB2YWx1ZSBvZiBteXZlY3RvclxuMzAzLTMwICAgIyAuLi4uXG45OS0zMFxuMTExLTMwICAgIyBsYXN0IHZhbHVlIG9mIG15dmVjdG9yIn0= You can also square a vector eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3Rvcl4yIn0= Which is the same as eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIzMF4yICAgICMgZmlyc3QgdmFsdWUgb2YgbXl2ZWN0b3JcbjE2XjIgICAgIyBzZWNvbmQgdmFsdWUgb2YgbXl2ZWN0b3JcbjMwM14yICAgIyAuLi4uXG45OV4yXG4xMTFeMiAgICMgbGFzdCB2YWx1ZSBvZiBteXZlY3RvciJ9 Also you can take the square root of a vector… eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzcXJ0KG15dmVjdG9yKSJ9 …and take the log of a vector… eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsb2cobXl2ZWN0b3IpIn0= …and just about any other mathematical operation. Here we are working on a separate vector object; all of these rules apply to a column in a matrix or a dataframe. This attribution of R is called vectorization. 15.3 Functions on vectors We can use functions on vectors. Typically these use the vectors as an input and all the numbers are processed into an output. Call the mean() function on the vector we made called myvector. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJtZWFuKG15dmVjdG9yKSJ9 Note how we get a single value back - the mean of all the values in the vector. R saw that we had a vector of multiple and knew that the mean is a function that doesn’t get applied to single number, but sets of numbers. The function sd() calculates the standard deviation. Apply the sd() to myvector: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZChteXZlY3RvcikifQ== 15.4 Operations with two vectors You can also subtract one vector from another vector. This can be a little weird when you first see it. Make another vector with the numbers 5, 10, 15, 20, 25, 30. Call this myvector2: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3RvcjIgPC0gYyg1LCAxMCwgMTUsIDIwLCAyNSwgMzApIn0= Now subtract myvector2 from myvector. What happens? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3Rvci1teXZlY3RvcjIifQ== 15.5 Subsetting vectors You can extract an element of a vector by typing the vector name with the index of that element given in square brackets. For example, to get the value of the 3rd element in the vector myvector, we type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3RvclszXSJ9 Extract the 4th element of the vector: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3Rvcls0XSJ9 You can extract more than one element by using a vector in the brackets: First, say I want to extract the 3rd and the 4th element. I can make a vector with 3 and 4 in it: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJudW1zIDwtIGMoMyw0KSJ9 Then put that vector in the brackets: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3RvcltudW1zXSJ9 We can also do it directly like this, skipping the vector-creation step: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3RvcltjKDMsNCldIn0= In the chunk below extract the 1st and 2nd elements: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3RvcltjKDEsMildIn0= 15.6 Sequences of numbers Often we want a vector of numbers in sequential order. That is, a vector with the numbers 1, 2, 3, 4, … or 5, 10, 15, 20, … The easiest way to do this is using a colon eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIxOjEwIn0= Note that in R 1:10 is equivalent to c(1:10) eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjKDE6MTApIn0= Usually to emphasize that a vector is being created I will use c(1:10) We can do any number to any numbers eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjKDIwOjMwKSJ9 We can also do it in reverse. In the code below put 30 before 20: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjKDMwOjIwKSJ9 A useful function in R is the seq() function, which is an explicit function that can be used to create a vector containing a sequence of numbers that run from a particular number to another particular number. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXEoMSwgMTApIn0= Using seq() instead of a : can be useful for readability to make it explicit what is going on. More importantly, seq has an argument by = ... so you can make a sequence of number with any interval between For example, if we want to create the sequence of numbers from 1 to 10 in steps of 1 (i.e.. 1, 2, 3, 4, … 10), we can type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXEoMSwgMTAsXG4gICAgYnkgPSAxKSJ9 We can change the step size by altering the value of the by argument given to the function seq(). For example, if we want to create a sequence of numbers from 1-100 in steps of 20 (i.e.. 1, 21, 41, … 101), we can type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXEoMSwgMTAxLFxuICAgIGJ5ID0gMjApIn0= 15.7 Vectors can hold numeric or character data The vector we created above holds numeric data, as indicated by class() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjbGFzcyhteXZlY3RvcikifQ== Vectors can also holder character data, like the genetic code: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHZlY3RvciBvZiBjaGFyYWN0ZXIgZGF0YVxubXl2ZWN0b3IgPC0gYyhcIkFcIixcIlRcIixcIkdcIilcblxuIyBob3cgaXQgbG9va3Ncbm15dmVjdG9yXG5cbiMgd2hhdCBpcyBcImlzXCJcbmNsYXNzKG15dmVjdG9yKSJ9 15.8 Regular expressions can modify character data We can use regular expressions to modify character data. For example, change the Ts to Us eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3RvciA8LSBnc3ViKFwiVFwiLCBcIlVcIiwgbXl2ZWN0b3IpIn0= Now check it out eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteXZlY3RvciJ9 Regular expressions are a deep subject in computing. You can find some more information about them here. "],["plotting-vectors-in-base-r.html", "Chapter 16 Plotting vectors in base R 16.1 Preface 16.2 Plotting numeric data 16.3 Other plotting packages", " Chapter 16 Plotting vectors in base R By: Avril Coghlan Adapted, edited and expanded: Nathan Brouwer (brouwern@gmail.com) under the Creative Commons 3.0 Attribution License (CC BY 3.0). 16.1 Preface This is a modification of part of“DNA Sequence Statistics (2)” from Avril Coghlan’s A little book of R for bioinformatics.. Most of text and code was originally written by Dr. Coghlan and distributed under the Creative Commons 3.0 license. 16.2 Plotting numeric data R allows the production of a variety of plots, including scatterplots, histograms, piecharts, and boxplots. Usually we make plots from dataframes with 2 or more columns, but we can also make them from two separate vectors. This flexibility is useful, but also can cause some confusion. For example, if you have two equal-length vectors of numbers numeric.vect1 and numeric.vect1, you can plot a scatterplot of the values in myvector1 against the values in myvector2 using the base R plot()function. First, let’s make up some data in put it in vectors: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJudW1lcmljLnZlY3QxIDwtIGMoMTAsIDE1LCAyMiwgMzUsIDQzKVxubnVtZXJpYy52ZWN0MiA8LSBjKDMsIDMuMiwgMy45LCA0LjEsIDUuMikifQ== Not plot with the base R plot() function: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KG51bWVyaWMudmVjdDEsIG51bWVyaWMudmVjdDIpIn0= Note that there is a comma between the two vector names. When building plots from dataframes you usually see a tilde (~), but when you have two vectors you can use just a comma. Also note the order of the vectors within the plot() command and which axes they appear on. The first vector is numeric.vect1 and it appears on the horizontal x-axis. If you want to label the axes on the plot, you can do this by giving the plot() function values for its optional arguments xlab = and ylab =: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KG51bWVyaWMudmVjdDEsICAgIyBub3RlIGFnYWluIHRoZSBjb21tYSwgbm90IGEgflxuICAgICBudW1lcmljLnZlY3QyLCBcbiAgICAgeGxhYj1cInZlY3RvcjFcIiwgXG4gICAgIHlsYWI9XCJ2ZWN0b3IyXCIpIn0= We can store character data in vectors so if we want we could do this to set up our labels: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteWxhYmVscyA8LSAgYyhcIm51bWVyaWMudmVjdDFcIixcIm51bWVyaWMudmVjdDJcIikifQ== Then use bracket notation to call the labels from the vector eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KG51bWVyaWMudmVjdDEsIFxuICAgICBudW1lcmljLnZlY3QyLCBcbiAgICAgeGxhYj1teWxhYmVsc1sxXSxcbiAgICAgeWxhYj1teWxhYmVsc1syXSkifQ== If we want we can use a tilde to make our plot like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KG51bWVyaWMudmVjdDIgfiBudW1lcmljLnZlY3QxKSJ9 Note that now, numeric.vect2 is on the left and numeric.vect1 is on the right. This flexibility can be tricky to keep track of. We can also combine these vectors into a dataframe and plot the data by referencing the data frame. First, we combine the two separate vectors into a dataframe using the cbind() command. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkZiA8LSBjYmluZChudW1lcmljLnZlY3QxLCBudW1lcmljLnZlY3QyKSJ9 Then we plot it like this, referencing the dataframe df via the data = ... argument. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KG51bWVyaWMudmVjdDIgfiBudW1lcmljLnZlY3QxLCBkYXRhID0gZGYpIn0= 16.3 Other plotting packages Base R has lots of plotting functions; additionally, people have written packages to implement new plotting capabilities. The package ggplot2 is currently the most popular plotting package, and ggpubr is a package which makes ggplot2 easier to use. For quick plots we’ll use base R functions, and when we get to more important things we’ll use ggplot2 and ggpubr. "],["programming-in-r-functions.html", "Chapter 17 Programming in R: functions 17.1 Preface 17.2 Vocab 17.3 Functions 17.4 Functions in R 17.5 Comments in R", " Chapter 17 Programming in R: functions By: Avril Coghlan Adapted, edited and expanded: Nathan Brouwer (brouwern@gmail.com) under the Creative Commons 3.0 Attribution License (CC BY 3.0). 17.1 Preface This is a modification of “DNA Sequence Statistics (1)” from Avril Coghlan’s A little book of R for bioinformatics.. The text and code was originally written by Dr. Coghlan and distributed under the Creative Commons 3.0 license. 17.2 Vocab function curly brackets 17.3 Functions function() 17.4 Functions in R We have been using built-in functions such as mean(), length(), print(), plot(), etc. We can also create our own functions in R to do calculations that you want to carry out very often on different input data sets. For example, we can create a function to calculate the value of 20 plus the square of some input number: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteWZ1bmN0aW9uIDwtIGZ1bmN0aW9uKHgpIHsgXG4gIG91dHB1dCA8LSAoMjAgKyAoeCp4KSkgXG4gIHJldHVybihvdXRwdXQpXG4gIH0ifQ== This function will calculate the square of a number (x), and then add 20 to that value. It stores this in a temporary object called output. The return() statement returns the calculated value. Once you have typed in this function, the function is then available for use. For example, we can use the function for different input numbers (e.g.. 10, 25): eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteWZ1bmN0aW9uKDEwKVxubXlmdW5jdGlvbigyNSkifQ== You can view the code that makes up a function by typing its name (without any parentheses). For example, we can try this by typing “myfunction”: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteWZ1bmN0aW9uIn0= 17.5 Comments in R When you are typing R, if you want to, you can write comments by writing the comment text after the “#” sign. This can be useful if you want to write some R commands that other people need to read and understand. R will ignore the comments when it is executing the commands. For example, you may want to write a comment to explain what the function log10() does: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4IDwtIDEwMFxubG9nMTAoeCkgIyBGaW5kcyB0aGUgbG9nIHRvIHRoZSBiYXNlIDEwIG9mIHZhcmlhYmxlIHguIn0= "],["fasta-files.html", "Chapter 18 FASTA Files 18.1 Example FASTA file 18.2 Multiple sequences in a single FASTA file 18.3 Multiple sequence alignments can be stored in FASTA format 18.4 FASTQ Format", " Chapter 18 FASTA Files Adapted from Wikipedia: https://en.wikipedia.org/wiki/FASTA_format \"In bioinformatics, the FASTA format is a text-based format for representing either nucleotide sequences or amino acid (protein) sequences, in which nucleotides or amino acids are represented using single-letter codes. The format allows for sequence names and comments to precede the sequences. The format originates from the FASTA alignment software, but has now become a near universal standard in the field of bioinformatics. \"The simplicity of FASTA format makes it easy to manipulate and parse sequences using text-processing tools and scripting languages like the R programming language and Python. “The first line in a FASTA file starts with a”&gt;\" (greater-than) symbol and holds summary information about the sequence, often starting with a unique accession number and followed by information like the name of the gene, the type of sequence, and the organism it is from. \"On the next is the sequence itself in a standard one-letter character string. Anything other than a valid character is be ignored (including spaces, tabs, asterisks, etc…). \"A multiple sequence FASTA format can be obtained by concatenating several single sequence FASTA files in a common file (also known as multi-FASTA format). \"Following the header line, the actual sequence is represented. Sequences may be protein sequences or nucleic acid sequences, and they can contain gaps or alignment characters. Sequences are expected to be represented in the standard amino acid and nucleic acid codes. Lower-case letters are accepted and are mapped into upper-case; a single hyphen or dash can be used to represent a gap character; and in amino acid sequences, U and * are acceptable letters. \"FASTQ format is a form of FASTA format extended to indicate information related to sequencing. It is created by the Sanger Centre in Cambridge. \"Bioconductor.org’s Biostrings package can be used to read and manipulate FASTA files in R from https://zhanglab.dcmb.med.umich.edu/FASTA/ “FASTA format is a text-based format for representing either nucleotide sequences or peptide sequences, in which base pairs or amino acids are represented using single-letter codes. A sequence in FASTA format begins with a single-line description, followed by lines of sequence data. The description line is distinguished from the sequence data by a greater-than (”&gt;“) symbol in the first column. It is recommended that all lines of text be shorter than 80 characters in length.” 18.1 Example FASTA file Here is an example of the contents of a FASTA file. (If your are viewing this chapter in the form of the source .Rmd file, the cat() function is included just to print out the content properly and is not part of the FASTA format). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjYXQoXCI+Z2l8MTg2NjgxMjI4fHJlZnxZUF8wMDE4NjQ0MjQuMXwgcGh5Y29lcnl0aHJvYmlsaW46ZmVycmVkb3hpbiBveGlkb3JlZHVjdGFzZVxuTU5TRVJTRFZUTFlRUEZMRFlBSUFZTVJTUkxETEVQWVBJUFRHRkVTTlNBVlZHS0dLTlFFRVZWVFRTWUFGUVRBS0xSUUlSQVxuQUhWUUdHTlNMUVZMTkZWSUZQSExOWURMUEZGR0FETFZUTFBHR0hMSUFMRE1RUExGUkREU0FZUUFLWVRFUElMUElGSEFIUVxuUUhMU1dHR0RGUEVFQVFQRkZTUEFGTFdUUlBRRVRBVlZFVFFWRkFBRktEWUxLQVlMREZWRVFBRUFWVERTUU5MVkFJS1FBUVxuTFJZTFJZUkFFS0RQQVJHTUZLUkZZR0FFV1RFRVlJSEdGTEZETEVSS0xUVlZLXCIpIn0= 18.2 Multiple sequences in a single FASTA file Multiple sequences can be stored in a single FASTA file, each on separated by a line and have its own headline. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjYXQoXCI+TENCTyAtIFByb2xhY3RpbiBwcmVjdXJzb3IgLSBCb3ZpbmVcbk1EU0tHU1NRS0dTUkxMTExMVlZTTkxMTENRR1ZWU1RQVkNQTkdQR05DUVZTTFJETEZEUkFWTVZTSFlJSERMU1NcbkVNRk5FRkRLUllBUUdLR0ZJVE1BTE5TQ0hUU1NMUFRQRURLRVFBUVFUSEhFVkxNU0xJTEdMTFJTV05EUExZSExcblZURVZSR01LR0FQREFJTFNSQUlFSUVFRU5LUkxMRUdNRU1JRkdRVklQR0FLRVRFUFlQVldTR0xQU0xRVEtERURcbkFSWVNBRllOTExIQ0xSUkRTU0tJRFRZTEtMTE5DUklJWU5OTkMqXG5cbj5NQ0hVIC0gQ2FsbW9kdWxpbiAtIEh1bWFuLCByYWJiaXQsIGJvdmluZSwgcmF0LCBhbmQgY2hpY2tlblxuTUFEUUxURUVRSUFFRktFQUZTTEZES0RHREdUSVRUS0VMR1RWTVJTTEdRTlBURUFFTFFETUlORVZEQURHTkdUSURcbkZQRUZMVE1NQVJLTUtEVERTRUVFSVJFQUZSVkZES0RHTkdZSVNBQUVMUkhWTVROTEdFS0xUREVFVkRFTUlSRUFcbkRJREdER1FWTllFRUZWUU1NVEFLKlxuXG4+Z2l8NTUyNDIxMXxnYnxBQUQ0NDE2Ni4xfCBjeXRvY2hyb21lIGIgW0VsZXBoYXMgbWF4aW11cyBtYXhpbXVzXVxuTENMWVRISUdSTklZWUdTWUxZU0VUV05UR0lNTExMSVRNQVRBRk1HWVZMUFdHUU1TRldHQVRWSVROTEZTQUlQWUlHVE5MVlxuRVdJV0dHRlNWREtBVExOUkZGQUZIRklMUEZUTVZBTEFHVkhMVEZMSEVUR1NOTlBMR0xUU0RTREtJUEZIUFlZVElLREZMR1xuTExJTElMTExMTExBTExTUERNTEdEUEROSE1QQURQTE5UUExISUtQRVdZRkxGQVlBSUxSU1ZQTktMR0dWTEFMRkxTSVZJTFxuR0xNUEZMSFRTS0hSU01NTFJQTFNRQUxGV1RMVE1ETExUTFRXSUdTUVBWRVlQWVRJSUdRTUFTSUxZRlNJSUxBRkxQSUFHWFxuSUVOWVwiKSJ9 18.3 Multiple sequence alignments can be stored in FASTA format Aligned FASTA format can be used to store the output of Multiple Sequence Alignment (MSA). This format contains Multiple entries, each with their own header line Gaps inserted to align sequences are indicated by . Each spaces added to the beginning and end of sequences that vary in length are indicated by ~ In the sample FASTA file below, the example1 sequence has a gap of 8 near its beginning. The example2 sequence has numerous ~ indicating that this sequence is missing data from its beginning that are present in the other sequences. The example3 sequence has numerous ~ at its end, indicating that this sequence is shorter than the others. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjYXQoXCI+ZXhhbXBsZTEgXG5NS0FMV0FMTExWUExMVEdDTEEuLi4uLi4uLkVHRUxFVlREUUxQR1FTRFFQLldFUUFMTlJGV0RZTFJXVlFcbkdOUUFSRFJMRUVWUkVRTUVFVlJTS01FRVFUUVFJUkxRQUVJRlFBUklLR1dGRVBMVkVETVFSUVdBTkxNRVxuS0lRQVNWQVROU0lBU1RUVlBMRU5RXG4+ZXhhbXBsZTIgXG5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fktWUVFFTEVQRUFHV1FUR1FQLldFQUFMQVJGV0RZTFJXVlFcblNTUkFSR0hMRUVNUkVRSVFFVlJWS01FRVFBRFFJUlFLQUVBRlFBUkxLU1dGRVBMTEVETVFSUVdER0xWRVxuS1ZRQUFWQVQuSVBUU0tQVkVFUH5+XG4+ZXhhbXBsZTMgXG5NUlNMVlZGRkFMQVZMVEdDUUFSU0xGUUFELi4uLi4uLi4uLi4uLi5BUFFQUldFRU1WRFJGV1FZVlNFTE5cbkFHQUxLRUtMRUVUQUVOTC4uLlJUU0xFR1JWREVMVFNMTEFQWVNRS0lSRVFMUUVWTURLSUtFQVRBQUxQVFxuUUF+fn5+fn5+fn5+fn5+fn5+fn5+XCIpIn0= 18.4 FASTQ Format Adapted from Wikipedia: https://en.wikipedia.org/wiki/FASTQ_format \"FASTQ format is a text-based format for storing both a biological sequence (usually nucleotide sequence) and its corresponding quality scores. Both the sequence letter and quality score are each encoded with a single ASCII character for brevity. \"It was originally developed at the Wellcome Trust Sanger Institute to bundle a FASTA formatted sequence and its quality data, but has recently become the de facto standard for storing the output of high-throughput sequencing instruments such as the Illumina Genome Analyzer. \"A FASTQ file normally uses four lines per sequence. Line 1 begins with a @ character and is followed by a sequence identifier and an optional description (like a FASTA title line). Line 2 is the raw sequence letters. Line 3 begins with a + character and is optionally followed by the same sequence identifier (and any description) again. Line 4 encodes the quality values for the sequence in Line 2 of the file, and must contain the same number of symbols as letters in the sequence. “A FASTQ file containing a single sequence might look like this:” eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjYXQoXCJAU0VRX0lEXG5HQVRUVEdHR0dUVENBQUFHQ0FHVEFUQ0dBVENBQUFUQUdUQUFBVENDQVRUVEdUVENBQUNUQ0FDQUdUVFRcbitcbiEnJyooKCgoKioqKykpJSUlKyspKCUlJSUpLjEqKiotKyonJykpKio1NUNDRj4+Pj4+PkNDQ0NDQ0M2NVwiKSJ9 “Here are the quality value characters in left-to-right increasing order of quality (ASCII):” eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIgIVwiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXFxdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+In0= FASTQ files typically do not include line breaks and do not wrap around when they reach the width of a normal page or file. "],["downloading-dna-sequences-as-fasta-files-in-r.html", "Chapter 19 Downloading DNA sequences as FASTA files in R 19.1 DNA Sequence Statistics: Part 1 19.2 OPTIONAL: Saving FASTA files 19.3 Next steps", " Chapter 19 Downloading DNA sequences as FASTA files in R This is a modification of “DNA Sequence Statistics” from Avril Coghlan’s A little book of R for bioinformatics.. Most of the text and code was originally written by Dr. Coghlan and distributed under the Creative Commons 3.0 license. NOTE: There is some reduncnacy in this current draft that needs to be eliminated. 19.0.1 Functions library() help() length table seqinr::GC() seqinr::count() seqinr::write.fasta() 19.0.2 Software/websites www.ncbi.nlm.nih.gov Text editors (e.g. Notepad++, TextWrangler) 19.0.3 R vocabulary list library package CRAN wrapper 19.0.4 File types FASTA 19.0.5 Bioinformatics vocabulary accession, accession number NCBI NCBI Sequence Database EMBL Sequence Database FASTA file 19.0.6 Organisms and Sequence accessions Dengue virus: DEN-1, DEN-2, DEN-3, and DEN-4. The NCBI accessions for the DNA sequences of the DEN-1, DEN-2, DEN-3, and DEN-4 Dengue viruses are NC_001477, NC_001474, NC_001475 and NC_002640, respectively. According to Wikipedia “Dengue virus (DENV) is the cause of dengue fever. It is a mosquito-borne, single positive-stranded RNA virus … Five serotypes of the virus have been found, all of which can cause the full spectrum of disease. Nevertheless, scientists’ understanding of dengue virus may be simplistic, as rather than distinct … groups, a continuum appears to exist.” https://en.wikipedia.org/wiki/Dengue_virus 19.0.7 Preliminaries eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KHJlbnRyZXopXG5saWJyYXJ5KGNvbXBiaW80YWxsKSAifQ== 19.1 DNA Sequence Statistics: Part 1 19.1.1 Using R for Bioinformatics The chapter will guide you through the process of using R to carry out simple analyses that are common in bioinformatics and computational biology. In particular, the focus is on computational analysis of biological sequence data such as genome sequences and protein sequences. The programming approaches, however, are broadly generalizable to statistics and data science. The tutorials assume that the reader has some basic knowledge of biology, but not necessarily of bioinformatics. The focus is to explain simple bioinformatics analysis, and to explain how to carry out these analyses using R. 19.1.2 R packages for bioinformatics: Bioconductor and SeqinR Many authors have written R packages for performing a wide variety of analyses. These do not come with the standard R installation, but must be installed and loaded as “add-ons”. Bioinformaticians have written numerous specialized packages for R. In this tutorial, you will learn to use some of the function in the SeqinR package to to carry out simple analyses of DNA sequences. (SeqinR can retrieve sequences from a DNA sequence database, but this has largely been replaced by the functions in the package rentrez) Many well-known bioinformatics packages for R are in the Bioconductor set of R packages (www.bioconductor.org), which contains packages with many R functions for analyzing biological data sets such as microarray data. The SeqinR package is from CRAN, which contains R functions for obtaining sequences from DNA and protein sequence databases, and for analyzing DNA and protein sequences. We will also use functions from the rentrez and ape packages. Remember that you can ask for more information about a particular R command by using the help() function. For example, to ask for more information about the library(), you can type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoZWxwKFwibGlicmFyeVwiKSJ9 You can also do this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiI/bGlicmFyeSJ9 19.1.3 FASTA file format The FASTA format is a simple and widely used format for storing biological (e.g. DNA or protein) sequences. It was first used by the FASTA program for sequence alignment in the 1980s and has been adopted as standard by many other programs. FASTA files begin with a single-line description starting with a greater-than sign &gt; character, followed on the next line by the sequences. Here is an example of a FASTA file. (If you’re looking at the source script for this lesson you’ll see the cat() command, which is just a text display function used format the text when you run the code). ## &gt;A06852 183 residues MPRLFSYLLGVWLLLSQLPREIPGQSTNDFIKACGRELVRLWVEICGSVSWGRTALSLEEPQLETGPPAETMPSSITKDAEILKMMLEFVPNLPQELKATLSERQPSLRELQQSASKDSNLNFEEFKKIILNRQNEAEDKSLLELKNLGLDKHSRKKRLFRMTLSEKCCQVGCIRKDIARLC 19.1.4 The NCBI sequence database The US National Centre for Biotechnology Information (NCBI) maintains the NCBI Sequence Database, a huge database of all the DNA and protein sequence data that has been collected. There are also similar databases in Europe, the European Molecular Biology Laboratory (EMBL) Sequence Database, and Japan, the DNA Data Bank of Japan (DDBJ). These three databases exchange data every night, so at any one point in time, they contain almost identical data. Each sequence in the NCBI Sequence Database is stored in a separate record, and is assigned a unique identifier that can be used to refer to that record. The identifier is known as an accession, and consists of a mixture of numbers and letters. For example, Dengue virus causes Dengue fever, which is classified as a neglected tropical disease by the World Health Organization (WHO), is classified by any one of four types of Dengue virus: DEN-1, DEN-2, DEN-3, and DEN-4. The NCBI accessions for the DNA sequences of the DEN-1, DEN-2, DEN-3, and DEN-4 Dengue viruses are NC_001477 NC_001474 NC_001475 NC_002640 Note that because the NCBI Sequence Database, the EMBL Sequence Database, and DDBJ exchange data every night, the DEN-1 (and DEN-2, DEN-3, DEN-4) Dengue virus sequence are present in all three databases, but they have different accessions in each database, as they each use their own numbering systems for referring to their own sequence records. 19.1.5 Retrieving genome sequence data using rentrez You can retrieve sequence data from NCBI directly from R using the rentrez package. The DEN-1 Dengue virus genome sequence has NCBI accession NC_001477. To retrieve a sequence with a particular NCBI accession, you can use the function entrez_fetch() from the rentrez package. Note that to be specific where the function comes from I write it as package::function(). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkZW5ndWVzZXFfZmFzdGEgPC0gcmVudHJlejo6ZW50cmV6X2ZldGNoKGRiID0gXCJudWNsZW90aWRlXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IFwiTkNfMDAxNDc3XCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR0eXBlID0gXCJmYXN0YVwiKSJ9 Note that the “\" in the name is just an arbitrary way to separate two words. Another common format would be dengueseq.fasta. Some people like dengueseqFasta, called camel case because the capital letter makes a hump in the middle of the word. Underscores are becoming most common and are favored by developers associated with RStudio and the tidyverse of packages that many data scientists use. I switch between \".\" and \"” as separators, usually favoring \"_\" for function names and “.” for objects; I personally find camel case harder to read and to type. Ok, so what exactly have we done when we made dengueseq_fasta? We have an R object dengueseq_fasta which has the sequence linked to the accession number “NC_001477.” So where is the sequence, and what is it? First, what is it? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpcyhkZW5ndWVzZXFfZmFzdGEpXG5jbGFzcyhkZW5ndWVzZXFfZmFzdGEpIn0= How big is it? Try the dim() and length() commands and see which one works. Do you know why one works and the other doesn’t? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkaW0oZGVuZ3Vlc2VxX2Zhc3RhKVxubGVuZ3RoKGRlbmd1ZXNlcV9mYXN0YSkifQ== The size of the object is 1. Why is this? This is the genomics sequence of a virus, so you’d expect it to be fairly large. We’ll use another function below to explore that issue. Think about this first: how many pieces of unique information are in the dengueseq object? In what sense is there only one piece of information? If we want to actually see the sequence we can type just type dengueseq_fasta and press enter. This will print the WHOLE genomic sequence out but it will probably run of your screen. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkZW5ndWVzZXFfZmFzdGEifQ== This is a whole genome sequence, but its stored as single entry in a vector, so the length() command just tells us how many entries there are in the vector, which is just one! What this means is that the entire genomic sequence is stored in a single entry of the vector dengueseq_fasta. (If you’re not following along with this, no worries - its not essential to actually working with the data) If we want to actually know how long the sequence is, we need to use the function nchar(). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJuY2hhcihkZW5ndWVzZXFfZmFzdGEpIn0= The sequence is 10935 bases long. All of these bases are stored as a single character string with no spaces in a single entry of our dengueseq_fasta vector. This isn’t actually a useful format for us, so below were’ going to convert it to something more useful. If we want to see just part of the sequence we can use the strtrim() function. Before you run the code below, predict what the 100 means. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHJ0cmltKGRlbmd1ZXNlcV9mYXN0YSwgMTAwKSJ9 Note that at the end of the name is a slash followed by an n, which indicates to the computer that this is a newline; this is read by text editor, but is ignored by R in this context. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHJ0cmltKGRlbmd1ZXNlcV9mYXN0YSwgNDUpIn0= After the \\\\n begins the sequence, which will continue on for a LOOOOOONG way. Let’s just print a little bit. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHJ0cmltKGRlbmd1ZXNlcV9mYXN0YSwgNTIpIn0= Let’s print some more. Do you notice anything beside A, T, C and G in the sequence? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHJ0cmltKGRlbmd1ZXNlcV9mYXN0YSwgMjAwKSJ9 Again, there are the \\\\n newline characters, which tell text editors and wordprocessors how to display the file. Now that we a sense of what we’re looking at let’s explore the dengueseq_fasta a bit more. We can find out more information about what it is using the class()command. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjbGFzcyhkZW5ndWVzZXFfZmFzdGEpIn0= As noted before, this is character data. Many things in R are vectors so we can ask R is.vector() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpcy52ZWN0b3IoZGVuZ3Vlc2VxX2Zhc3RhKSJ9 Yup, that’s true. Ok, let’s see what else. A handy though often verbose command is is(), which tells us what an object, well, what it is: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpcyhkZW5ndWVzZXFfZmFzdGEpIn0= There is a lot here but if you scan for some key words you will see “character” and “vector” at the top. The other stuff you can ignore. The first two things, though, tell us the dengueseq_fasta is a vector of the class character: that is, a character vector. Another handy function is str(), which gives us a peak at the context and structure of an R object. This is most useful when you are working in the R console or with dataframes, but is a useful function to run on all R objects. How does this output differ from other ways we’ve displayed dengueseq_fasta? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHIoZGVuZ3Vlc2VxX2Zhc3RhKSJ9 We know it contains character data - how many characters? nchar() for “number of characters” answers that: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJuY2hhcihkZW5ndWVzZXFfZmFzdGEpIn0= 19.2 OPTIONAL: Saving FASTA files We can save our data as .fasta file for safe keeping. The write() function will save the data we downloaded as a plain text file. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ3cml0ZShkZW5ndWVzZXFfZmFzdGEsIFxuICAgICAgZmlsZT1cImRlbmd1ZXNlcS5mYXN0YVwiKSJ9 If you do this, you’ll need to figure out where R is saving things, which requires and understanding R’s file system, which can take some getting used to, especially if you’re new to programming. As a start, you can see where R saves things by using the getwd() command, which tells you where on your harddrive R currently is using as its home base for files. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJnZXR3ZCgpIn0= 19.3 Next steps On their own, FASTA files in R are not directly useful. In the next lesson we’ll process our dengueseq_fasta file so that we can use it in analyses. "],["downloading-dna-sequences-as-fasta-files-in-r-1.html", "Chapter 20 Downloading DNA sequences as FASTA files in R 20.1 Preliminaries 20.2 Convert FASTA sequence to an R variable", " Chapter 20 Downloading DNA sequences as FASTA files in R This is a modification of “DNA Sequence Statistics” from Avril Coghlan’s A little book of R for bioinformatics.. Most of the text and code was originally written by Dr. Coghlan and distributed under the Creative Commons 3.0 license. 20.1 Preliminaries We’ll need the dengueseq_fasta FASTA data object, which is in the compbio4all package. We’ll also use the stringr package for cleaning up the FASTA data, which can be downloaded with install.packages(\"stringr\") eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIGNvbXBiaW80YWxsLCB3aGljaCBoYXMgZGVuZ3Vlc2VxX2Zhc3RhXG5saWJyYXJ5KGNvbXBiaW80YWxsKVxuZGF0YShkZW5ndWVzZXFfZmFzdGEpXG5cbiMgc3RyaW5nciwgZm9yIGRhdGEgY2xlYW5pbmdcbmxpYnJhcnkoc3RyaW5ncikifQ== 20.2 Convert FASTA sequence to an R variable We can’t actually do much with the contents of the dengueseq_fasta we downloaded with the rentrez package except read them. If we want do address some biological questions with the data we need is to convert it into a data structure R can work with. There are several things we need to remove: The meta data line &gt;NC_001477.1 Dengue virus 1, complete genome (metadata is “data” about data, such as where it came from, what it is, who made it, etc.). All the \\n that show up in the file (these are the line breaks). Put each nucleotide of the sequence into its own spot in a vector. There are functions that can do this automatically, but I haven’t found one I like, and walking through this will help you understand the types of operations you can do on text data. The first two steps involve removing things from the existing character string that contains the sequence. The third step will split the single continuous character string like “AGTTGTTAGTCTACGT…” into a character vector like c(\"A\",\"G\",\"T\",\"T\",\"G\",\"T\",\"T\",\"A\",\"G\",\"T\",\"C\",\"T\",\"A\",\"C\",\"G\",\"T\"...), where each element of the vector is a single character a stored in a separate slot in the vector. 20.2.1 Removing unwanted characters The second item is the easiest to take care of. R and many programming languages have tools called regular expressions that allow you to manipulate text. R has a function called gsub() which allows you to substitute or delete character data from a string. First I’ll remove all those \\n values. The regular expression function gsub() takes three arguments: 1. pattern = .... This is what we need it to find so we can replace it. 1. replacement = .... The replacement. 1. x = .... A character string or vector where gsub() will do its work. We need to get rid of the \\n so that we are left with only A, T and G, which are the actually information of the sequence. We want \\n completely removed, so the replacement will be \"\", which is as set of quotation marks with nothing in the middle, which means “delete the target pattern and put nothing in its place.” One thing that is tricky about regular expressions is that many characters have special meaning to the functions, such as slashes, dollar signs, and brackets. So, if you want to find and replace one of these specially designated characters you need to put a slash in front of them. So when we set the pattern, instead of setting the pattern to a slash before an n \\n, we have to give it two slashes \\\\n. Here is the regular expression to delete the newline character \\n. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIgIyBub3RlOiB3ZSB3YW50IHRvIGZpbmQgYWxsIHRoZSBcXG4sIGJ1dCBuZWVkIHRvIHNldCB0aGUgcGF0dGVybiBhcyBcXFxcblxuZGVuZ3Vlc2VxX3ZlY3RvciA8LSBnc3ViKHBhdHRlcm4gPSBcIlxcXFxuXCIsICBcbiAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IFwiXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBkZW5ndWVzZXFfZmFzdGEpIn0= We can use strtrim() to see if it worked eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHJ0cmltKGRlbmd1ZXNlcV92ZWN0b3IsIDgwKSJ9 Now for the metadata header. This is a bit complex, but the following code is going to take all the that occurs before the beginning of the sequence (“AGTTGTTAGTC”) and delete it. First, I’ll define what I want to get rid of in an R object. This will make the call to gsub() a little cleaner to read eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXEuaGVhZGVyIDwtIFwiPk5DXzAwMTQ3Ny4xIERlbmd1ZSB2aXJ1cyAxLCBjb21wbGV0ZSBnZW5vbWVcIiJ9 Now I’ll get rid of the header with with gsub(). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkZW5ndWVzZXFfdmVjdG9yIDwtIGdzdWIocGF0dGVybiA9IHNlcS5oZWFkZXIsICMgb2JqZWN0IGRlZmluZWQgYWJvdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IFwiXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBkZW5ndWVzZXFfdmVjdG9yKSJ9 See if it worked: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHJ0cmltKGRlbmd1ZXNlcV92ZWN0b3IsIDgwKSJ9 20.2.2 Spliting unbroken strings in character vectors Now the more complex part. We need to split up a continuous, unbroken string of letters into a vector where each letter is on its own. This can be done with the str_split() function (“string split”) from the stringr package. The notation stringr::str_split() mean “use the str_split function from from the stringr package.” More specifically, it temporarily loads the stringr package and gives R access to just the str_split function. These allows you to call a single function without loading the whole library. There are several arguments to str_split, and I’ve tacked a [[1]] on to the end. First, run the command eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkZW5ndWVzZXFfdmVjdG9yX3NwbGl0IDwtIHN0cmluZ3I6OnN0cl9zcGxpdChkZW5ndWVzZXFfdmVjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGlmeSA9IEZBTFNFKVtbMV1dIn0= Look at the output with str() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHIoZGVuZ3Vlc2VxX3ZlY3Rvcl9zcGxpdCkifQ== We can explore what the different arguments do by modifying them. Change pattern = \"\" to pattern = \"A\". Can you figure out what happened? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHJlLXJ1biB0aGUgY29tbWFuZCB3aXRoIFwicGF0dGVybiAgPSBcIkFcIlxuZGVuZ3Vlc2VxX3ZlY3Rvcl9zcGxpdDIgPC0gc3RyaW5ncjo6c3RyX3NwbGl0KGRlbmd1ZXNlcV92ZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gXCJBXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGlmeSA9IEZBTFNFKVtbMV1dXG5zdHIoZGVuZ3Vlc2VxX3ZlY3Rvcl9zcGxpdDIpIn0= And try it with pattern = \"\" to pattern = \"G\". eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHJlLXJ1biB0aGUgY29tbWFuZCB3aXRoIFwicGF0dGVybiAgPSBcIkdcIlxuZGVuZ3Vlc2VxX3ZlY3Rvcl9zcGxpdDMgPC0gc3RyaW5ncjo6c3RyX3NwbGl0KGRlbmd1ZXNlcV92ZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gXCJHXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGlmeSA9IEZBTFNFKVtbMV1dXG5zdHIoZGVuZ3Vlc2VxX3ZlY3Rvcl9zcGxpdDMpIn0= Run this code to compare the two ways we just used str_split (don’t worry what it does). Does this help you see what’s up? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJvcHRpb25zKHN0ciA9IHN0ck9wdGlvbnModmVjLmxlbiA9IDEwKSlcbnN0cihsaXN0KGRlbmd1ZXNlcV92ZWN0b3Jfc3BsaXRbMToyMF0sXG4gICAgIGRlbmd1ZXNlcV92ZWN0b3Jfc3BsaXQyWzE6MTBdLCBcbiAgICAgZGVuZ3Vlc2VxX3ZlY3Rvcl9zcGxpdDNbMToxMF0pKSJ9 So, what does the pattern = ... argument do? For more info open up the help file for str_split by calling ?str_split. Something cool which we will explore in the next exercise is that we can do summaries on vectors of nucleotides, like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0YWJsZShkZW5ndWVzZXFfdmVjdG9yX3NwbGl0KSJ9 "],["downloading-protein-sequences-in-r.html", "Chapter 21 Downloading protein sequences in R 21.1 Preliminaries 21.2 Retrieving a UniProt protein sequence using rentrez", " Chapter 21 Downloading protein sequences in R By: Avril Coghlan. Adapted, edited and expanded: Nathan Brouwer under the Creative Commons 3.0 Attribution License (CC BY 3.0). 21.1 Preliminaries eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGNvbXBiaW80YWxsKSJ9 21.2 Retrieving a UniProt protein sequence using rentrez We can use entrez_fetch() to download protein sequences. For example to retrieve the protein sequences for UniProt accessions Q9CD83 and A0PQ23, we type in R: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHNlcXVlbmNlIDE6IFE5Q0Q4M1xubGVwcmFlX2Zhc3RhIDwtIHJlbnRyZXo6OmVudHJlel9mZXRjaChkYiA9IFwicHJvdGVpblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBcIlE5Q0Q4M1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHJldHR5cGUgPSBcImZhc3RhXCIpXG4jIHNlcXVlbmNlIDI6IE9JTjE3NjE5LjFcbnVsY2VyYW5zX2Zhc3RhIDwtIHJlbnRyZXo6OmVudHJlel9mZXRjaChkYiA9IFwicHJvdGVpblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gXCJPSU4xNzYxOS4xXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgcmV0dHlwZSA9IFwiZmFzdGFcIikifQ== Display the contents of the lepraeseq FASTA file. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsZXByYWVfZmFzdGEifQ== Let’s clean these up to remove the header and new line characters usin the function fasta_cleaner(). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsZXByYWVfdmVjdG9yICAgPC0gZmFzdGFfY2xlYW5lcihsZXByYWVfZmFzdGEpXG51bGNlcmFuc192ZWN0b3IgPC0gZmFzdGFfY2xlYW5lcih1bGNlcmFuc19mYXN0YSkifQ== Examine the output using length(), class(), and head(): eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsZW5ndGgobGVwcmFlX3ZlY3RvcilcbmNsYXNzKGxlcHJhZV92ZWN0b3IpXG5oZWFkKGxlcHJhZV92ZWN0b3IsIDIwKSJ9 "],["sequence-dotplots-in-r.html", "Chapter 22 Sequence dotplots in R 22.1 Preliminaries 22.2 Visualzing two identical sequences 22.3 Visualizing repeats 22.4 Inversions 22.5 Translocations 22.6 Random sequence 22.7 Comparing two real sequences using a dotplot", " Chapter 22 Sequence dotplots in R By: Avril Coghlan. Adapted, edited and expanded: Nathan Brouwer under the Creative Commons 3.0 Attribution License (CC BY 3.0). NOTE: I’ve added some new material that is rather terse and lacks explication. 22.1 Preliminaries eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGNvbXBiaW80YWxsKSJ9 22.1.1 Download sequences As we did in the previous lesson on dotplots, we’ll look at two sequences. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHNlcXVlbmNlIDE6IFE5Q0Q4M1xubGVwcmFlX2Zhc3RhIDwtIHJlbnRyZXo6OmVudHJlel9mZXRjaChkYiA9IFwicHJvdGVpblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBcIlE5Q0Q4M1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHJldHR5cGUgPSBcImZhc3RhXCIpXG4jIHNlcXVlbmNlIDI6IE9JTjE3NjE5LjFcbnVsY2VyYW5zX2Zhc3RhIDwtIHJlbnRyZXo6OmVudHJlel9mZXRjaChkYiA9IFwicHJvdGVpblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gXCJPSU4xNzYxOS4xXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgcmV0dHlwZSA9IFwiZmFzdGFcIilcblxubGVwcmFlX3ZlY3RvciAgIDwtIGZhc3RhX2NsZWFuZXIobGVwcmFlX2Zhc3RhKVxudWxjZXJhbnNfdmVjdG9yIDwtIGZhc3RhX2NsZWFuZXIodWxjZXJhbnNfZmFzdGEpIn0= 22.2 Visualzing two identical sequences To help build our intuition about dotplots we’ll first look at some artificial examples. First, we’ll see what happens when we make a dotplot comparing the alphabet versus itself. The build-in LETTERS object in R contains the alphabet from A to Z. This is a sequence with no repeats. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFpbnI6OmRvdFBsb3QoTEVUVEVSUywgXG4gICAgICAgICAgICAgICAgTEVUVEVSUykifQ== What we get is a perfect diagonal line. 22.3 Visualizing repeats Now lets’ make a sequence where the alphabet gets repeats twice eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJMRVRURVJTLjIudGltZXMgPC0gYyhMRVRURVJTLExFVFRFUlMpXG5cbnNlcWlucjo6ZG90UGxvdChMRVRURVJTLjIudGltZXMsIFxuICAgICAgICAgICAgICAgIExFVFRFUlMuMi50aW1lcykifQ== Note the diagonal lines. Now 3 repeats eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJMRVRURVJTLjMudGltZXMgPC0gYyhMRVRURVJTLExFVFRFUlMsTEVUVEVSUylcblxuc2VxaW5yOjpkb3RQbG90KExFVFRFUlMuMy50aW1lcywgXG4gICAgICAgICAgICAgICAgTEVUVEVSUy4zLnRpbWVzKSJ9 Here’s another example of repeats. Create sequence with repeats: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXEucmVwZWF0IDwtIGMoXCJBXCIsXCJDXCIsXCJEXCIsXCJFXCIsXCJGXCIsXCJHXCIsXCJIXCIsXCJJXCIpXG5zZXExIDwtIHJlcChzZXEucmVwZWF0LDMpIn0= Make the dotplot: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFpbnI6OmRvdFBsb3Qoc2VxMSwgXG4gICAgICAgICAgICAgICAgc2VxMSkifQ== 22.4 Inversions See if you can figure out what’s going on here. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJMRVRURVJTLjMudGltZXMud2l0aC5pbnZlcnQgPC0gYyhMRVRURVJTLHJldihMRVRURVJTKSxMRVRURVJTKVxuXG5zZXFpbnI6OmRvdFBsb3QoTEVUVEVSUy4zLnRpbWVzLCBcbiAgICAgICAgICAgICAgICBMRVRURVJTLjMudGltZXMud2l0aC5pbnZlcnQpIn0= 22.5 Translocations See if you can figure out what’s going on here. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZWcxIDwtIExFVFRFUlNbMTo4XVxuc2VnMiA8LSBMRVRURVJTWzk6MThdXG5zZWczIDwtIExFVFRFUlNbMTg6MjZdXG5cbkxFVFRFUlMud2l0aC50cmFuc2xvYyA8LSBjKHNlZzEsc2VnMyxzZWcyKVxuXG5zZXFpbnI6OmRvdFBsb3QoTEVUVEVSUywgXG4gICAgICAgICAgICAgICAgTEVUVEVSUy53aXRoLnRyYW5zbG9jKSJ9 22.6 Random sequence eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsZXR0ZXJzLnJhbmQxIDwtIHNhbXBsZSh4ID0gTEVUVEVSUywgc2l6ZSA9IDI2LCByZXBsYWNlID0gRilcbmxldHRlcnMucmFuZDIgPC0gc2FtcGxlKHggPSBMRVRURVJTLCBzaXplID0gMjYsIHJlcGxhY2UgPSBGKVxuXG5cbnNlcWlucjo6ZG90UGxvdChsZXR0ZXJzLnJhbmQxLCBcbiAgICAgICAgICAgICAgICBsZXR0ZXJzLnJhbmQyKSJ9 22.7 Comparing two real sequences using a dotplot As a first step in comparing two protein, RNA or DNA sequences, it is a good idea to make a dotplot. A dotplot is a graphical method that allows the comparison of two protein or DNA sequences and identify regions of close similarity between them. A dotplot is essentially a two-dimensional matrix (like a grid), which has the sequences of the proteins being compared along the vertical and horizontal axes. In order to make a simple dotplot to represent of the similarity between two sequences, individual cells in the matrix can be shaded black if residues are identical, so that matching sequence segments appear as runs of diagonal lines across the matrix. Identical proteins will have a line exactly on the main diagonal of the dotplot, that spans across the whole matrix. For proteins that are not identical, but share regions of similarity, the dotplot will have shorter lines that may be on the main diagonal, or off the main diagonal of the matrix. In essence, a dotplot will reveal if there are any regions that are clearly very similar in two protein (or DNA) sequences. We can create a dotplot for two sequences using the dotPlot() function in the seqinr package. First, let’s look at a dotplot created using only a single sequence. You’d never do this in practice, but it will give you a sense of what dotplots are doing. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFpbnI6OmRvdFBsb3QobGVwcmFlX3ZlY3RvciwgXG4gICAgICAgICAgICAgICAgbGVwcmFlX3ZlY3RvcikifQ== These two sequences are identical, so we have a very distinct diagonal line. But there’s also other Now we’ll make a real dotplot of the chorismate lyase proteins from two closely related species, Mycobacterium leprae and Mycobacterium ulcerans. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFpbnI6OmRvdFBsb3QobGVwcmFlX3ZlY3RvciwgXG4gICAgICAgICAgICAgICAgdWxjZXJhbnNfdmVjdG9yKSJ9 In the dotplot above, the M. leprae sequence is plotted along the x-axis (horizontal axis), and the M. ulcerans sequence is plotted along the y-axis (vertical axis). The dotplot displays a dot at points where there is an identical amino acid in the two sequences. For example, if amino acid 53 in the M. leprae sequence is the same amino acid (eg. “W”) as amino acid 70 in the M. ulcerans sequence, then the dotplot will show a dot the position in the plot where x =50 and y =53. In this case you can see a lot of dots along a diagonal line, which indicates that the two protein sequences contain many identical amino acids at the same (or very similar) positions along their lengths. This is what you would expect, because we know that these two proteins are homologs (related proteins) because they share a close evolutionary history. "],["global-proteins-aligments-in-r.html", "Chapter 23 Global proteins aligments in R 23.1 Preliminaries 23.2 Pairwise global alignment of DNA sequences using the Needleman-Wunsch algorithm 23.3 Pairwise global alignment of protein sequences using the Needleman-Wunsch algorithm 23.4 Aligning UniProt sequences 23.5 Viewing a long pairwise alignment", " Chapter 23 Global proteins aligments in R By: Avril Coghlan. Adapted, edited and expanded: Nathan Brouwer under the Creative Commons 3.0 Attribution License (CC BY 3.0). 23.1 Preliminaries eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGNvbXBiaW80YWxsKVxuXG5saWJyYXJ5KEJpb3N0cmluZ3MpIn0= 23.1.1 Download sequences As we did in the previous lesson on dotplots, we’ll look at two sequences. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIERvd25sb2FkXG4jIyBzZXF1ZW5jZSAxOiBROUNEODNcbmxlcHJhZV9mYXN0YSA8LSByZW50cmV6OjplbnRyZXpfZmV0Y2goZGIgPSBcInByb3RlaW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gXCJROUNEODNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICByZXR0eXBlID0gXCJmYXN0YVwiKVxuIyMgc2VxdWVuY2UgMjogT0lOMTc2MTkuMVxudWxjZXJhbnNfZmFzdGEgPC0gcmVudHJlejo6ZW50cmV6X2ZldGNoKGRiID0gXCJwcm90ZWluXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBcIk9JTjE3NjE5LjFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICByZXR0eXBlID0gXCJmYXN0YVwiKVxuXG4jIGNsZWFuXG5sZXByYWVfdmVjdG9yICAgPC0gZmFzdGFfY2xlYW5lcihsZXByYWVfZmFzdGEpXG51bGNlcmFuc192ZWN0b3IgPC0gZmFzdGFfY2xlYW5lcih1bGNlcmFuc19mYXN0YSkifQ== 23.2 Pairwise global alignment of DNA sequences using the Needleman-Wunsch algorithm If you are studying a particular pair of genes or proteins, an important question is to what extent the two sequences are similar. To quantify similarity, it is necessary to align the two sequences, and then you can calculate a similarity score based on the alignment. There are two types of alignment in general. A global alignment is an alignment of the full length of two sequences from beginning to end, for example, of two protein sequences or of two DNA sequences. A local alignment is an alignment of part of one sequence to part of another sequence; the parts the end up getting aligned are the most similar, and determined by the alignment algorithm. The first step in computing a alignment (global or local) is to decide on a scoring system. For example, we may decide to give a score of +2 to a match and a penalty of -1 to a mismatch, and a penalty of -2 to a gap due to an indexl. Thus, for the alignment: ## [1] &quot;G A A T T C&quot; ## [1] &quot;G A T T - A&quot; we would compute a score of G vs G = matchb = 2 A vs A = match = 2 A vs T = mismatch = -1 T vs T = match = 2 T vs - = gap = -2 C vs A = mismatch = 2 So, the scores is 2 + 2 -1 + 2 -2 - 1 = 2. Similarly, the score for the following alignment is 2 + 2 -2 + 2 + 2 -1 = 5: ## [1] &quot;G A A T T C&quot; ## [1] &quot;G A - T T A&quot; The scoring system above can be represented by a scoring matrix (also known as a substitution matrix). The scoring matrix has one row and one column for each possible letter in our alphabet of letters (e.g. 4 rows and 4 columns for DNA and RNA sequences, 20 x 20 for amino acids). The (i,j) element of the matrix has a value of +2 in case of a match and -1 in case of a mismatch. We can make a scoring matrix in R by using the nucleotideSubstitutionMatrix() function in the Biostrings package. Biostrings is part of a set of R packages for bioinformatics analysis known as Bioconductor (www.bioconductor.org/). The arguments (inputs) for the nucleotideSubstitutionMatrix() function are the score that we want to assign to a match and the score that we want to assign to a mismatch. We can also specify that we want to use only the four letters representing the four nucleotides (ie. A, C, G, T) by setting baseOnly=TRUE, or whether we also want to use the letters that represent ambiguous cases where we are not sure what the nucleotide is (e.g. ‘N’ = A/C/G/T; ambiguous cases occur in some sequences due to sequencing errors or ambiguities). To make a scoring matrix which assigns a score of +2 to a match and -1 to a mismatch, and store it in the variable sigma, we type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIG1ha2UgdGhlIG1hdHJpeFxuc2lnbWEgPC0gbnVjbGVvdGlkZVN1YnN0aXR1dGlvbk1hdHJpeChtYXRjaCA9IDIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXNtYXRjaCA9IC0xLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZU9ubHkgPSBUUlVFKVxuIyBQcmludCBvdXQgdGhlIG1hdHJpeFxuc2lnbWEgIn0= Instead of assigning the same penalty (e.g. -8) to every gap position, it is common instead to assign a gap opening penalty to the first position in a gap (e.g. -8), and a smaller gap extension penalty to every subsequent position in the same gap. The reason for doing this is that it is likely that adjacent gap positions were created by the same insertion or deletion event, rather than by several independent insertion or deletion events. Therefore, we don’t want to penalize a 3-letter gap (AAA—AAA) as much as we would penalize three separate 1-letter gaps (AA-A-A-AA), as the 3-letter gap may have arisen due to just one insertion or deletion event, while the 3 separate 1-letter gaps probably arose due to three independent insertion or deletion events. For example, if we want to compute the score for a global alignment of two short DNA sequences ‘GAATTC’ and ‘GATTA’, we can use the Needleman-Wunsch algorithm to calculate the highest-scoring alignment using a particular scoring function. The pairwiseAlignment() function in the Biostrings package finds the score for the optimal global alignment between two sequences using the Needleman-Wunsch algorithm, given a particular scoring system. As arguments (inputs), pairwiseAlignment() takes the two sequences that you want to align, the scoring matrix, the gap opening penalty, and the gap extension penalty. You can also tell the function that you want to just have the optimal global alignment’s score by setting scoreOnly = TRUE, or that you want to have both the optimal global alignment and its score by setting scoreOnly = FALSE. For example, let’s find the score for the optimal global alignment between the sequences ‘GAATTC’ and ‘GATTA’. First, we’ll store the sequences as character vectors: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzMSA8LSBcIkdBQVRUQ1wiXG5zMiA8LSBcIkdBVFRBXCIifQ== Now we’ll align them: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJnbG9iYWxBbGlnbnMxczIgPC0gQmlvc3RyaW5nczo6cGFpcndpc2VBbGlnbm1lbnQoczEsIHMyLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25NYXRyaXggPSBzaWdtYSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwT3BlbmluZyA9IC0yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhcEV4dGVuc2lvbiA9IC04LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZU9ubHkgPSBGQUxTRSkifQ== The output: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJnbG9iYWxBbGlnbnMxczIgIn0= The above commands print out the optimal global alignment for the two sequences and its score. Note we set gapOpening to be -2 and gapExtension to be -8, which means that the first position of a gap is assigned a score of -8 - 2= -10, and every subsequent position in a gap is given a score of -8. Here the alignment contains four matches, one mismatch, and one gap of length 1, so its score is (42)+(1-1)+(1*-10) = -3. 23.3 Pairwise global alignment of protein sequences using the Needleman-Wunsch algorithm As well as DNA alignments, it is also possible to make alignments of protein sequences. In this case it is necessary to use a scoring matrix for amino acids rather than for nucleotides. 23.3.1 Protein score matrices There are several well known scoring matrices that come with R, such as the BLOSUM series of matrices. Different BLOSUM matrices exist, named with different numbers. BLOSUM with high numbers are designed for comparing closely related sequences, while BLOSUM with low numbers are designed for comparing evolutionarily distantly related sequences. For example, BLOSUM62 is used for less divergent alignments (alignments of sequences that differ little), and BLOSUM30 is used for more divergent alignments (alignments of sequences that differ a lot). Many R packages come with example data sets or data files and you use the data() function is used to load these data files. You can use the data() function to load a data set of BLOSUM matrices that comes with Biostrings To load the BLOSUM50 matrix, we type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYXRhKEJMT1NVTTUwKVxuQkxPU1VNNTAgIyBQcmludCBvdXQgdGhlIGRhdGEifQ== You can get a list of the available scoring matrices that come with the Biostrings package by using the data() function, which takes as an argument the name of the package for which you want to know the data sets that come with it: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYXRhKHBhY2thZ2U9XCJCaW9zdHJpbmdzXCIpIn0= Another well-known series of scoring matrices are the PAM matrices developed by Margaret Dayhoff and her team. These have largely been replaced by BLOSUM but are important for historical reasons because they represent one of the first major bioinformatics, computational biology, and phyolgenetics projects ever. 23.3.2 Example protein alignment Let’s find the optimal global alignment between the protein sequences “PAWHEAE” and “HEAGAWGHEE” using the Needleman-Wunsch algorithm using the BLOSUM50 matrix. First, load the scoring matrix BLOSUM50 and make vectors for the sequence eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIG1hdHJpeFxuZGF0YShCTE9TVU01MClcblxuIyBzZXF1ZW5jZXNcbnMzIDwtIFwiUEFXSEVBRVwiXG5zNCA8LSBcIkhFQUdBV0dIRUVcIiJ9 Now do the alignments. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJnbG9iYWxBbGlnbnMzczQgPC0gcGFpcndpc2VBbGlnbm1lbnQoczMsIHM0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbk1hdHJpeCA9IFwiQkxPU1VNNTBcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwT3BlbmluZyA9IC0yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhcEV4dGVuc2lvbiA9IC04LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZU9ubHkgPSBGQUxTRSkifQ== Look at the results: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJnbG9iYWxBbGlnbnMzczQgIyBQcmludCBvdXQgdGhlIG9wdGltYWwgZ2xvYmFsIGFsaWdubWVudCBhbmQgaXRzIHNjb3JlIn0= We set gapOpening to be -2 and gapExtension to be -8, which means that the first position of a gap is assigned a score of -8-2=-10, and every subsequent position in a gap is given a score of -8. This means that the gap will be given a score of -10-8-8 = -26. 23.4 Aligning UniProt sequences We discussed previously how you can search for UniProt accessions and retrieve the corresponding protein sequences, either via the UniProt website or using the rentrez package. In the examples given above, we learned how to retrieve the sequences for the chorismate lyase proteins from Mycobacterium leprae (UniProt Q9CD83) and Mycobacterium ulcerans (UniProt A0PQ23), and read them into R, and store them as vectors lepraeseq and ulceransseq. You can align these sequences using pairwiseAlignment() from the Biostrings package. As its input, the pairwiseAlignment()function requires that the sequences be in the form of a single string (e.g. “ACGTA”), rather than as a vector of characters (e.g. a vector with the first element as “A”, the second element as “C”, etc.). Therefore, to align the M. leprae and M. ulcerans chorismate lyase proteins, we first need to convert the vectors lepraeeq and ulceransseq into strings. We can do this using the paste() function: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIGNvbnZlcnQgbGVwcmFlX3ZlY3RvciB0byBhbiBvYmplY3QgbGVwcmFlc2VxX3N0cmluZ1xubGVwcmFlc2VxX3N0cmluZyA8LXBhc3RlKGxlcHJhZV92ZWN0b3IsY29sbGFwc2UgPSBcIlwiKSAgICBcblxuIyBjb252ZXJ0IHVsY2VyYW5zX3ZlY3RvciB0byBhbiBvYmplY3QgdWxjZXJhbnNzZXFfc3RyaW5nXG51bGNlcmFuc3NlcV9zdHJpbmcgPC1wYXN0ZSh1bGNlcmFuc192ZWN0b3IsY29sbGFwc2UgPSBcIlwiKSAifQ== Furthermore, pairwiseAlignment() requires that the sequences be stored as uppercase characters. Therefore, if they are not already in uppercase, we need to use the toupper() function to convert lepraeseq_string and ulceransseq_string to uppercase: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsZXByYWVzZXFfc3RyaW5nICAgPC0gdG91cHBlcihsZXByYWVzZXFfc3RyaW5nKVxudWxjZXJhbnNzZXFfc3RyaW5nIDwtIHRvdXBwZXIodWxjZXJhbnNzZXFfc3RyaW5nKSJ9 Check the output eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsZXByYWVzZXFfc3RyaW5nICMgUHJpbnQgb3V0IHRoZSBjb250ZW50IG9mIFwibGVwcmFlc2VxX3N0cmluZ1wiIn0= We can now align the the M. leprae and M. ulcerans chorismate lyase protein sequences using the pairwiseAlignment() function: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJnbG9iYWxBbGlnbkxlcHJhZVVsY2VyYW5zIDwtIEJpb3N0cmluZ3M6OnBhaXJ3aXNlQWxpZ25tZW50KGxlcHJhZXNlcV9zdHJpbmcsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bGNlcmFuc3NlcV9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbk1hdHJpeCA9IEJMT1NVTTUwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwT3BlbmluZyA9IC0yLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwRXh0ZW5zaW9uID0gLTgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZU9ubHkgPSBGQUxTRSkifQ== The output: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJnbG9iYWxBbGlnbkxlcHJhZVVsY2VyYW5zICMgUHJpbnQgb3V0IHRoZSBvcHRpbWFsIGdsb2JhbCBhbGlnbm1lbnQgYW5kIGl0cyBzY29yZSJ9 As the alignment is very long, when you type globalAlignLepraeUlcerans, you only see the start and the end of the alignment. Therefore, we need to have a function to print out the whole alignment (see below). 23.5 Viewing a long pairwise alignment If you want to view a long pairwise alignment such as that between the M. leprae and M. ulerans chorismate lyase proteins, it is convenient to print out the alignment in blocks. The R function printPairwiseAlignment() below will do this for you: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwcmludFBhaXJ3aXNlQWxpZ25tZW50KGdsb2JhbEFsaWduTGVwcmFlVWxjZXJhbnMsIDYwKSJ9 The position in the protein of the amino acid that is at the end of each line of the printed alignment is shown after the end of the line. For example, the first line of the alignment above finishes at amino acid position 50 in the M. leprae protein and also at amino acid position 60 in the M. ulcerans protein. Becaues there as a difference of 60-50 = 10 bases, there must be 10 insertions in the M. leprae to get it to line up. Count the number of dashes in the sequence to see how many there are. "],["local-protein-aligments-in-r.html", "Chapter 24 Local protein aligments in R 24.1 Preliminaries 24.2 Pairwise local alignment of protein sequences using the Smith-Waterman algorithm", " Chapter 24 Local protein aligments in R By: Avril Coghlan. Adapted, edited and expanded: Nathan Brouwer under the Creative Commons 3.0 Attribution License (CC BY 3.0). 24.1 Preliminaries eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGNvbXBiaW80YWxsKVxubGlicmFyeShCaW9zdHJpbmdzKSJ9 24.1.1 Download sequences As we did in the previous lesson on dotplots, we’ll look at two sequences. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIERvd25sb2FkXG4jIyBzZXF1ZW5jZSAxOiBROUNEODNcbmxlcHJhZV9mYXN0YSA8LSByZW50cmV6OjplbnRyZXpfZmV0Y2goZGIgPSBcInByb3RlaW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gXCJROUNEODNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICByZXR0eXBlID0gXCJmYXN0YVwiKVxuIyMgc2VxdWVuY2UgMjogT0lOMTc2MTkuMVxudWxjZXJhbnNfZmFzdGEgPC0gcmVudHJlejo6ZW50cmV6X2ZldGNoKGRiID0gXCJwcm90ZWluXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBcIk9JTjE3NjE5LjFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICByZXR0eXBlID0gXCJmYXN0YVwiKVxuXG4jIGNsZWFuXG5sZXByYWVfdmVjdG9yICAgPC0gZmFzdGFfY2xlYW5lcihsZXByYWVfZmFzdGEpXG51bGNlcmFuc192ZWN0b3IgPC0gZmFzdGFfY2xlYW5lcih1bGNlcmFuc19mYXN0YSlcblxuIyBjb252ZXJ0IGxlcHJhZV92ZWN0b3IgdG8gYW4gb2JqZWN0IGxlcHJhZXNlcV9zdHJpbmdcbmxlcHJhZXNlcV9zdHJpbmcgPC1wYXN0ZShsZXByYWVfdmVjdG9yLGNvbGxhcHNlID0gXCJcIikgICAgXG5cbiMgY29udmVydCB1bGNlcmFuc192ZWN0b3IgdG8gYW4gb2JqZWN0IHVsY2VyYW5zc2VxX3N0cmluZ1xudWxjZXJhbnNzZXFfc3RyaW5nIDwtcGFzdGUodWxjZXJhbnNfdmVjdG9yLGNvbGxhcHNlID0gXCJcIikgIn0= 24.2 Pairwise local alignment of protein sequences using the Smith-Waterman algorithm You can use the pairwiseAlignment() function to find the optimal local alignment of two sequences, that is the best alignment of parts (subsequences) of those sequences, by using the type=local argument in pairwiseAlignment(). This uses the Smith-Waterman algorithm for local alignment. This is the classic bioinformatics algorithm for finding optimal local alignments. (We’ll discuss updated approaches when we get into database searches with BLAST, the **Basic, Local Alignment Search Tool* that is the workhorse of many day-to-day bioinformatics tasks). For example, to find the best local alignment between the M. leprae and M. ulcerans chorismate lyase proteins, we can run: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIGxvYWQgc2NvcmluZyBtYXRyaXhcbmRhdGEoQkxPU1VNNTApXG5cbiMgcnVuIGFsaWdubWVudFxubG9jYWxBbGlnbkxlcHJhZVVsY2VyYW5zIDwtIHBhaXJ3aXNlQWxpZ25tZW50KGxlcHJhZXNlcV9zdHJpbmcsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVsY2VyYW5zc2VxX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25NYXRyaXggPSBCTE9TVU01MCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwT3BlbmluZyA9IC0yLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXBFeHRlbnNpb24gPSAtOCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVPbmx5ID0gRkFMU0UsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJsb2NhbFwiKSAgIyA8PSB0eXBlID0gXCJsb2NhbCAhIn0= Print out the optimal local alignment and its score eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsb2NhbEFsaWduTGVwcmFlVWxjZXJhbnMgIn0= As before, we can print out the full alignment with printPairwiseAlignment(): eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwcmludFBhaXJ3aXNlQWxpZ25tZW50KGxvY2FsQWxpZ25MZXByYWVVbGNlcmFucywgNjApIn0= We see that the optimal local alignment is quite similar to the optimal global alignment in this case, except that it excludes a short region of poorly aligned sequence at the start and at the ends of the two proteins. "],["matrix-vocabulary.html", "Chapter 25 Matrix vocabulary 25.1 Introduction 25.2 Preliminaries 25.3 Load packages 25.4 Matrix structure 25.5 Diagonal of a matrix", " Chapter 25 Matrix vocabulary By Nathan Brouwer eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGNvbXBiaW80YWxsKSJ9 25.1 Introduction In this exercise we will practice manipulating matrices and vector by exploring the structure of scoring matrices and alignments. 25.2 Preliminaries 25.2.1 Packages BiocManager Biostrings combio4all 25.2.2 Vocab 25.2.2.1 Math / R vocab triangular matrix square matrix lower triangle upper triangle symmetric matrix matrix diagonal 25.2.2.2 Bioinformatics vocab scoring matrix BLOSUM scoring matrix 25.2.3 Functions used 25.2.3.1 Base R functions data() is() nrow(), ncol(), dim(), names(), colnames(), rownames(), head(), tail() 25.2.3.2 Specific function combio4all::tri_print() combio4all::diag_show() 25.3 Load packages Load basic packages eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGZsZXh0YWJsZSlcbmxpYnJhcnkod2Vic2hvdCkifQ== Install the Biostrings package from Bioconductor; you don’t have to run this if you already happen to have downloaded Biostrings before In the R console the matrix looks like this. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02MiJ9 The function tri_print() will print just the lower triangle, with all the other values left empty. (This might be a bit slow) eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmlfcHJpbnQoQkxPU1VNNjIsIGFzLmltYWdlID0gVCkifQ== We can also look at the upper triangle. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmlfcHJpbnQoQkxPU1VNNjIsdHJpYW5nbGUgPSBcInVwcGVyXCIsIGFzLmltYWdlID0gVCkifQ== 25.4 Matrix structure The BLOSUM62 matrix is a square matrix since the number of rows equals the number of columns. It is also a symmetrical matrix since the lower triangle of the matrix is the same as the upper triangle. The compbio4all package has functions for displaying these. R shows us the full symmetric matrix, though in books usually they just show the lower triangle. A symmetric matrix is one where the upper and lower triangles are identical. 25.5 Diagonal of a matrix The diagonal of a matrix is the set of numbers that falls directly in a diagonal line from the upper left corner to the lower right. The diagonal of a scoring matrix represents an amino acid that hasn’t changed or diverged between two sequences (in theory it could change and then change back). We can access the diagonal in R diag(). What does diag(BLOSUM62) tell you? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkaWFnKEJMT1NVTTYyKSJ9 This is showing you the entries that fall along the diagonal of the matrix. But the output is just a string of numbers. We can look at the diagonal in context using the diag_show() function from the compbio4all package. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkaWFnX3Nob3coQkxPU1VNNjIpIn0= "],["alignment-in-r.html", "Chapter 26 Alignment in R 26.1 Preliminaries", " Chapter 26 Alignment in R By: Nathan Brouwer 26.1 Preliminaries 26.1.1 Packages eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KEJpb3N0cmluZ3MpIn0= 26.1.2 Data eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoU2hybTMgIDwtIFwiRVBFUkVQRVdSRFJQR1NQXCJcblxubVNocm0zICAgPC0gXCJFQUVSRUFTV1NFRFJQR1RcIiJ9 We can do a pairwise alignment directly in R using pairwiseAlignment() from Biostrings, a package from Bioconductor. We’ll use this function to check the math on our alignment calculations from the previous lesson. Normally this pairwiseAlignment() will insert gaps. Alignment algorithms allow you to set a penalty for first creating a gap, and for how large it is. As noted above, usually the penalty is largest for first allowing a gap initially, but less for each additional space. So a gap of 1 might have a penalty of -14 (-10 + -4), but a gap of 2 might have total penalty of -18 (-10 + -4 + -4). In pairwiseAlignment() the arguments related to gaps are gapOpening = and gapExtension =, where gapOpening is the for starting the gap and gapExtension is the penalty for the size of the gap (including the first insertion). In R you can get information about a function using the ? function. If we want to know about the pairwiseAlignment() function we run ?pairwiseAlignment. Call up the help file for pairwiseAlignment and see if you can see what the defaults are for gap opening (aka gap creation) and gap extension. Hint: Its int the first 50 lines of the help file - don’t scroll too far down). R help files are pretty dense so this might be hard. Note that the penalties are set as positive numbers in the help file but get converted to negative values. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIENhbGwgdXAgdGhlIGhlbHAgZmlsZSBmb3IgcGFpcndpc2VBbGlnbm1lbnQoKVxuXG4jIFdoYXQgaXMgdGhlIGdhcCBvcGVuaW5nIHBlbmFsdHk/IFJlcGxhY2UgdGhlIFwiTkFcIiB3aXRoIHRoZSBwZW5hbHR5XG5cbmdhcE9wZW4gPC0gTkFcblxuXG4jIFdoYXQgaXMgdGhlIGdhcCBleHRlbnNpb24gPyBSZXBsYWNlIHRoZSBcIk5BXCIgd2l0aCB0aGUgcGVuYWx0eVxuXG5nYXBFeHRlbmQgPC0gTkEifQ== We can force the alignment to NOT allow gaps by setting the penalties for gaps to be REALLY large. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJub2dhcCA8LSBwYWlyd2lzZUFsaWdubWVudChoU2hybTMsXG4gICAgICAgICAgICAgICAgICBtU2hybTMsXG4gICAgICAgICAgICAgICAgICBnYXBPcGVuaW5nID0gLTEwMCxcbiAgICAgICAgICAgICAgICAgIGdhcEV4dGVuc2lvbiA9IC0xMDAsXG4gICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25NYXRyaXggPSBcIkJMT1NVTTYyXCIpIn0= We can check the alignment by calling up the object We can get the score directly using the score() function We can get the percent identity using the pid() function Note that In the code above I’ve set the penalties to be negative, which is more intuitive. Confirm that positive numbers for these penalties result in the same score by changing the 100 values to -100. Copy the code from above and make the appropriate changes. Why does setting the gap penalties high make the algorithm not insert gaps? We haven’t covered this directly yet, but the goal of an alignment algorithm is to maximize the score by lining up the two sequences and adding gaps and deletions as necessary. Recalling what’s along the diagonal of the BLOSUM matrix, direct matches (identity) between the residues on two sequences result in the highest scores, and differences have lower scores based on how different the residues are. Look at the BLOSUM matrix and see if there are any entries that are as low as -10, the gap penalty. We can allow gaps by removing the gapOpening and gapExtension arguments (deleting them). Copy the code from above, remove those arguments, and assign the output to an object called gap. When we don’t assign anything to gapOpening and gapExtension arguments in the code above, the function uses the defaults. We can also specify the gap penalties directly. COpy the code again, leave the arguments in but change the penalties to -10 for gap creation and -4 for gap extension. Look at the alignment; How many indels were added on the “pattern” strand? What is the score of this alignment? Use the appropriate function to access it directly and save into an object called score.gap eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHJlbW92ZSB0aGUgTkEgYW5kIGFkZCB0aGUgYXBwcm9wcmlhdGUgY29kZSBcbnNjb3JlLmdhcCA8LSBOQSJ9 What is the percent identity? Use the appropriate function to access it directly and save it to and object called pid.gap eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHJlbW92ZSB0aGUgTkEgYW5kIGFkZCB0aGUgYXBwcm9wcmlhdGUgY29kZSBcbnBpZC5nYXAgPC0gTkEifQ== "],["manipulating-matrices-and-vectors-worked-example.html", "Chapter 27 Manipulating matrices and vectors: worked example 27.1 Introduction 27.2 Preliminaries 27.3 Matrix elements can be accessed with square bracket notation 27.4 R object names", " Chapter 27 Manipulating matrices and vectors: worked example By Nathan Brouwer 27.1 Introduction In this exercise we will practice manipulating matrices and vectors by exploring the structure of scoring matrices. 27.2 Preliminaries 27.2.1 Packages BiocManager Biostrings combio4all 27.2.2 Vocab 27.2.2.1 Math / R vocab triangular matrix square matrix lower triangle upper triangle symmetric matrix matrix diagonal named vectors named matrices accessing items in named vectors or matrices square bracket notation 27.2.2.2 Bioinformatics vocab scoring matrix BLOSUM scoring matrix 27.2.3 Functions used 27.2.3.1 Base R functions data() is() nrow(), ncol(), dim(), names(), colnames(), rownames(), head(), tail() 27.2.4 Packages eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KEJpb3N0cmluZ3MpIn0= 27.2.5 Data eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYXRhKEJMT1NVTTYyKSJ9 27.3 Matrix elements can be accessed with square bracket notation We often want to access just subsets of data from a matrix or a dataframe. This can take some getting used to. We can use square brackets to get certain subsets or ranges of cells. If we want just the upper left-hand cell we can do this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02MlsxLDFdIn0= If we want the first four cells in the upper left hand corner we can do this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02MltjKDE6NCksIGMoMTo0KV0ifQ== If we want to get rid of the ambiguity code cells on the bottom which are B, J, Z, X and * we can specify that we want elements 1 through 20. Let me step through this. First, run the code below; what happens? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIxOjQifQ== Now do the same thing for 1 to 20: Note that this next line should provide the same result as what you just did. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjKDE6MjApIn0= If we really wanted to type all of this out, we would have to do this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjKDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwKSJ9 We can get just the first row of the BLOSUM matrix by telling R we want row 1 and columns 1 to 20. We get just row 1 like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02MlsxLCBdIn0= We get columns 1:20 like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02MlsgLCBjKDE6MjApXSJ9 Note that leaving the first part blank gives us ALL the rows. If we want just the first row AND the first 20 columns, we do this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02MlsxICwgYygxOjIwKV0ifQ== Assign the output of the code c(1:20) to an object called i using the assignment operator &lt;-. The code should like like this i &lt;- c(1:20). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpIDwtIGMoMToyMCkifQ== This thing i we just made is a vector of numbers. Vectors are a 1-dimensional sequence of numbers. You can think of a matrix as a bunch of vectors stacked on top of each other. Unfortunately, if you call is() in the i object you don’t get a totally clear picture of what it is. Where does the word vector show up? I’m not sure why vector isn’t the first thing to be printed. We can check whether i is a vector more directly by asking it “hey i, are you a vector” using the is.vector() command eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpcy52ZWN0b3IoaSkifQ== Its a vector, so it shouldn’t be a matrix, but we can check with is.matrix() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpcy5tYXRyaXgoaSkifQ== Math books may tell you that a vector is a 1-dimensional matrix, but in R land vectors are distinct from matrices. Vectors show up everywhere in R. In this case I’ve defined a vector, i, which is holding the row and column numbers I want to isolated from the BLOSUM62 matrix. I can call up just these rows and columns like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02MltpICwgaV0ifQ== If I hadn’t defined the vector i, I could write eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02MltjKDE6MjApICxjKDE6MjApICBdIn0= Let’s isolate just the first 20 rows and columns and put them into a new object called BLOSUM62.subset. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02Mi5zdWJzZXQgPC0gIEJMT1NVTTYyW2kgLGkgXSJ9 We can get the scores for when there is no change in an amino acid from the diagonal with diag() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkaWFnKEJMT1NVTTYyLnN1YnNldCkifQ== If you’re scoring an alignment by hand you can pull up the diagonal of the matrix this way so you don’t have to squint at the whole matrix. We can make it even easier if we alphabetize thing, though this requires some extra code which you don’t need to worry about. (I’m making a new vector, i2, which will do the alphabetizing). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIGdldCBjb2x1bW4gbmFtZXNcbm4gPC0gY29sbmFtZXMoQkxPU1VNNjIuc3Vic2V0KVxuXG4jIHNvcnRcbmkyIDwtIHNvcnQobikifQ== Now things are in alphabetical order eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkaWFnKEJMT1NVTTYyLnN1YnNldClbaTJdIn0= Save this alphabetized diagonal to an R object called BLOSUM62.diag using the assignment operator &lt;- eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02Mi5kaWFnIDwtIGRpYWcoQkxPU1VNNjIuc3Vic2V0KVtpMl0ifQ== What are the names attached to this BLOSUM62.diag object? Unfortunately R is picky about how you do this so you need to figure out whether the functions names(), rownames(), or colnames() gets you want you want eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyb3duYW1lcyhCTE9TVU02Mi5kaWFnKVxuY29sbmFtZXMoQkxPU1VNNjIuZGlhZylcbm5hbWVzKEJMT1NVTTYyLmRpYWcpIn0= 27.4 R object names When an R object has “names” assigned to it we can use the name to call up elements of the object. 27.4.1 Accessing items in names vectors We can call up just the score for an E to E transition stored in our matrix diagonal like this, which is a way of saying “Hey R, give me the value in this BLOSUM62.diag object that is in the slot labeled”E\". eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02Mi5kaWFnW1wiRVwiXSJ9 E is the 4th slot so we can also get this value like this with the slot number. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02Mi5kaWFnWzRdIn0= We could get the first four values using c(1:4). Try it What type of object is this diagonal thingy anyway? The command starts with “i”. 27.4.2 Accessing items in names matrices If we want to get something from the main matrix (the full BLOSUM matrix, not the diagonal) we can also specify things using the row and column names. This will give us the value for an E to E transition: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02Mi5zdWJzZXRbXCJFXCIsXCJFXCJdIn0= How could you get the whole “E” column? How could you get the whole “E” row? We can use numbers too if we want. “E” is in the 7th column, so we can get the E to E value like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02Mi5zdWJzZXRbNyw3XSJ9 How would you get the whole “E” column? How would you get the whole “E” row? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02Mi5zdWJzZXRbNywgXSJ9 We can of course specify any score we want. For a P to A transition we could do this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02Mi5zdWJzZXRbXCJQXCIsXCJBXCJdIn0= Or specify the row and column numbers eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02Mi5zdWJzZXRbMTUsMV0ifQ== What happens when you do [“A”,“P”] instead (reverse of what was above? So, if you are doing an alignment by hand, you can quickly query the matrix and pull up the scores. If you have a sequence “EPEERPEWRDRPGSP” and “EAEREASWSEDRPGT” you can get the score for the E to E matching again like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02Mi5zdWJzZXRbXCJFXCIsXCJFXCJdIn0= and P to A like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02Mi5zdWJzZXRbXCJQXCIsXCJBXCJdIn0= and so on. "],["alignment-by-eye-in-r.html", "Chapter 28 Alignment by eye in R 28.1 Preliminaries", " Chapter 28 Alignment by eye in R By Nathan Brouwer 28.1 Preliminaries 28.1.1 Packages eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGNvbXBiaW80YWxsKVxubGlicmFyeShCaW9zdHJpbmdzKSJ9 28.1.2 Data eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYXRhKFwiQkxPU1VNNjJcIikifQ== Let’s do an alignment between two parts of a shroom protein. We’ll look at part of the ASD2 domain of Shroom 3. We’ll look at human shroom (hShrm3) and call this the “Query” sequence. We’ll use mouse shroom (mShrm3) as the “subject” or “target”. (The accession number for human shroom 3 is NP_065910.3) eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoU2hybTMgIDwtIFwiRVBFUkVQRVdSRFJQR1NQXCJcblxubVNocm0zICAgPC0gXCJFQUVSRUFTV1NFRFJQR1RcIiJ9 Use nchar() to see how many characters are in them We can make a little matrix and look at how they align using the rbind() function, which stands for “row bind” eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyYmluZChoU2hybTMsXG4gICAgICBtU2hybTMpIn0= Assign this to an object called shrms eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJtcyA8LSByYmluZChoU2hybTMsIG1TaHJtMykifQ== What type of object is shrms? How big is it? See if you can guess first before using R to check If we want to do an alignment by eye it would help if instead of having all the letters stuck together they were separated. We would do this by hand but it would require a lot of typing: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoU2hybTNfYWx0IDwtIGMoXCJFXCIsXCJQXCIsXCJFXCIsXCJSXCIsXCJFXCIsXCJQXCIsXCJFXCIsXCJXXCIsXCJSXCIsXCJEXCIsXCJSXCIsXCJQXCIsXCJHXCIsXCJTXCIsXCJQXCIpXG5cbm1TaHJtM19hbHQgPC0gYyhcIkVcIixcIkFcIixcIkVcIixcIlJcIixcIkVcIixcIkFcIixcIlNcIixcIldcIixcIlNcIixcIkVcIixcIkRcIixcIlJcIixcIlBcIixcIkdcIixcIlRcIikifQ== One thing that is annoying about R is that vectors have “length” but no dimension. Compare the output of the length() command and dim() command when called on hShrm3_alt eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHJ1biBsZW5ndGgoKVxuXG5cbiMgcnVuIGRpbSgpIn0= Use is, is.vector, length, is.character, and n.char on hShrm3 and hShrm3_alt. How is hShrm3 (“EPEREPEWRDRPGSP”) different from hShrm3_alt? Can you figure out why nchar() is doing what its doing? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHJ1biBpcygpIG9uIGhTaHJtMyBBTkQgaFNocm0zX2FsdFxuXG5cbiMgcnVuIGlzLnZlY3RvciBvbiBoU2hybTMgQU5EIGhTaHJtM19hbHRcblxuXG4jIGRvIHRoaXMgZm9yIHRoZSByZXN0IG9mIHRoZSBjb21tYW5kcyJ9 Typing all this stuff out is a pain. Instead of typing all those commas to make hShrm3_alt we could take hShrm3 and have R do the work for us. Lots of people work with character data (data make up of alphabetic and other characters that can NOT be interpreted as numbers) so there are lots of functions for manipulating characters. We’ll use the strsplit() function. If we just all strsplit() on the hShrm3 object we get something a little annoying. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHJzcGxpdChoU2hybTMsIHNwbGl0ID0gXCJcIikifQ== Note that the output above is on too lines, and the first line is [[1]]. Ok, what’s up? Assign the thing we just made to an object called hShrm3_vec for “hShrm3 vector”. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoU2hybTNfdmVjIDwtIHN0cnNwbGl0KGhTaHJtMywgc3BsaXQgPSBcIlwiKSJ9 Now figure out what the heck it “is”: If you used the right command to figure out what it is (hint) the first thing you see is “list.” Lists are rather complex data structures in R because they aren’t the kind of thing you run in to if you just have experience working in a spreadsheet. Lists allow you to make collections of different R objects. For now you just need to know that they exist; we’ll run into them again later. For now, we want to get rid of this listy-ness of our R object. We can do this with the function unlist(). Call unlist() on your hShrm3_vec object and re-assign it to the same object hShrm3_vec, eg, run hShrm3_vec &lt;- unlist(hShrm3_vec) eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoU2hybTNfdmVjIDwtIHVubGlzdChoU2hybTNfdmVjKSJ9 Now we need to repeat these steps for the mouse shroom sequence. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHNwbGl0IHVwIG1TaHJtMyB3aXRoIHN0cnNwbGl0KClcbm1TaHJtM192ZWMgPC0gc3Ryc3BsaXQobVNocm0zLCBzcGxpdCA9IFwiXCIpXG5cbiMgdW5saXN0IGl0IHdpdGggdW5saXN0KClcbm1TaHJtM192ZWMgPC0gdW5saXN0KG1TaHJtM192ZWMpIn0= Something that is useful once you get good at reading R code is that you can wrap functions within functions. So instead of doing this in separate steps I could just do this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoU2hybTNfdmVjIDwtIHVubGlzdChzdHJzcGxpdChoU2hybTMsIHNwbGl0ID0gXCJcIikpXG5tU2hybTNfdmVjIDwtIHVubGlzdChzdHJzcGxpdChtU2hybTMsIHNwbGl0ID0gXCJcIikpIn0= Before moving on confirm that these two factors are the same length. If they aren’t R will get angry eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIGxlbmd0aCBvZiBoU2hybTNfdmVjXG5cbiMgbGVuZ3RoIG9mIG1TaHJtM192ZWMifQ== Now let’s make a little matrix so we can think about aligning these sequences. The rbind() function binds two rows together into a matrix. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyYmluZChoU2hybTNfdmVjLCBtU2hybTNfdmVjKSJ9 For what we want to do next aligning them vertically will actually work better. We can align them as columns using cbind(), which stands for “column bind” eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjYmluZChoU2hybTNfdmVjLCBtU2hybTNfdmVjKSJ9 Save that to an object called shrm eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjYmluZChoU2hybTNfdmVjLCBtU2hybTNfdmVjKSJ9 eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJtIDwtIGNiaW5kKGhTaHJtM192ZWMsIG1TaHJtM192ZWMpIn0= The most basic way to do an alignment is to determine the which bases are identical and to score those as 1, and anything that is mismatched score as 0. From this you can determine percent identity. A handy way to do this quickly in R is to use the ifelse() command. What you can do is tell it to do this: “IF a base in the first sequence the same as the aligned base in the second sequence, return a value of 1, ELSE return a value of 0.” I’ll do a really transparent example. First, let me make some very simple objects with just a single letter in them. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJhYTEgPC0gXCJBXCJcbmFhMiA8LSBcIkFcIlxuYWEzIDwtIFwiV1wiIn0= What kind of object have I just made? Use is, is.vector, length, dim, and is.matrix. Can you understand why you get the results that you do? Now let me use ifelse(). First, let me check if aa1 is the same as aa2, an if they R, return a value of 1, else return a value of 0 eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpZmVsc2UoYWExID09IGFhMiwgeWVzID0gIDEsIG5vID0gMCkifQ== The first part of the function asks a true/false question: is aa1 the same as aa2? Note that it is TWO equals signs This is a logical comparison or logical test in R. It would work on its own outside of ifelse, like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJhYTEgPT0gYWEyIn0= Now compare aa1 and aa2. First try the logical test Now try the ifelse() command Something that is very hand in R is that it can process things in a series. First, let’s turn our single amino acids into some sequences. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXExIDwtIGMoYWExLCBhYTIsIGFhMylcbnNlcTIgPC0gYyhhYTMsIGFhMiwgYWExKSJ9 Do you know what kind of R object we just made? Run an appropriate check Now let’s compare these two sequences. First a logical comparison. Can you tell what this code is doing? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXExID09IHNlcTIifQ== What is going on here? It might help to line everything up using rbind() to make a little matrix. First, save the output of the logical comparison to an R object eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpZGVudGljYWwgPC0gc2VxMT09c2VxMiJ9 Now stack the two sequences and the logical comparison into a matrix eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyYmluZChzZXExLCBzZXEyLCBpZGVudGljYWwpIn0= We can also run ifelse() on the two sequences eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpZmVsc2Uoc2VxMSA9PSBzZXEyLCB5ZXMgPSAxLCBubyA9IDApIn0= Save this output to an object called align.score for “alignment score” eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJhbGlnbi5zY29yZSA8LSBpZmVsc2Uoc2VxMSA9PSBzZXEyLCB5ZXMgPSAxLCBubyA9IDApIn0= Now stack everything up into a matrix using rbind eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyYmluZChzZXExLCBzZXEyLCBpZGVudGljYWwsIGFsaWduLnNjb3JlICkifQ== Now let’s try this on our shroom vectors. First, do a logical comparison of the hShrm3_vec vector and the mShrm3_vec vector. Remember there are two equals signs (==) Now use ifelse() to assign a 1 to a match and a 0 to a mismatch. Again, can you describe what’s going on here? Again we can make a little matrix with rbind(). I’m going to embed the ifelse() function within rbind(); this might be a little dense but see if you can figure out what each separate command is. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyYmluZChoU2hybTNfdmVjLCBcbiAgICAgIG1TaHJtM192ZWMsXG4gICAgICBpZGVudGljYWwgPSBoU2hybTNfdmVjID09IG1TaHJtM192ZWMsXG4gICAgICBzY29yZT0gaWZlbHNlKGhTaHJtM192ZWMgPT0gbVNocm0zX3ZlYyx5ZXMgPSAxLCBubyA9IDAgKSkifQ== If we want the total score we can assign the results of ifelse() to an object eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzY29yZXMgPC1pZmVsc2UoaFNocm0zX3ZlYyA9PSBtU2hybTNfdmVjLHllcyA9IDEsIG5vID0gMCApIn0= I can then total up the score with sum() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdW0oc2NvcmVzKSJ9 I can easily call up the number of amino acids with length(). Do that below Percent identity is a common statistic when comparing sequences. If my score is 5 and my total number of residues is 15 my percent identity is: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiI1LzE1In0= I can do this directly on the objects like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdW0oc2NvcmVzKS9sZW5ndGgoc2NvcmVzKSJ9 We can do this sort of scoring on sequences in a matrix or data frame. Remember that we made a matrix called shrm with our two sequences in it. Matrices and dataframes are very similar, but its usually easier to work with dataframes. We can convert the matrix to a dataframe like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJtIDwtIGRhdGEuZnJhbWUoc2hybSwgc3RyaW5nc0FzRmFjdG9ycyA9IEYpIn0= There’s a lot relate to the “stringsAsFactors = F”; basically it makes sure we are working with raw character data. Calling summary() on the shrm dataframe can confirm that its character data: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdW1tYXJ5KHNocm0pIn0= You can call up the human shroom 3 columns with this code: shrm[, “hShrm3_vec”]. try it below How would you call up the other column with mouse shroom? One tricky thin about R is that you can access the column of dataframes in more than one way. You can get the first column also using the dollar sign eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJtJGhTaHJtM192ZWMifQ== Note that even though we’re calling a column, R prints it out left to right like a row. We can do a logical comparisons of the two columns like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJtWywgXCJoU2hybTNfdmVjXCJdID09IHNocm1bLFwibVNocm0zX3ZlY1wiXSJ9 Can you re-write this using the dollar sign notation? Try it below Now let’s use ifelse() on these two columns eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpZmVsc2Uoc2hybVssIFwiaFNocm0zX3ZlY1wiXSA9PSBzaHJtWyxcIm1TaHJtM192ZWNcIl0sIHllcyA9IDEsIG5vID0gMCkifQ== Rewrite the code above using dollar sign notation We can add this information to the dataframe like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJtJGlkZW50aWNhbCA8LSBpZmVsc2Uoc2hybVssIFwiaFNocm0zX3ZlY1wiXSA9PSBzaHJtWyxcIm1TaHJtM192ZWNcIl0sIHllcyA9IDEsIG5vID0gMCkifQ== Now what do we have? Call up the dataframe shrm we just made: Now call summary on it. What types of data are each variable? Comparing an alignment to a scoring matrix by hand is a lot of work, so there’s a function called score_alignment() in the compbio4all package which can do basic comparisons. The function has the following arguments seq.df = A dataframe with aligned sequences in columns seq1 = the name of the column with a sequence in it; name must be in quotes seq2 = the other, aligned sequence gap.penalty = -10 Running the function returns a dataframe with a new column called “score”. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJtIDwtc2NvcmVfYWxpZ25tZW50KHNlcS5kZiA9IHNocm0sIFxuICAgICAgICAgICAgICAgIHNlcTE9ICBcImhTaHJtM192ZWNcIiwgICNub3RlIHRoZSBxdW90YXRpb24gbWFya3NcbiAgICAgICAgICAgICAgICBzZXEyID0gXCJtU2hybTNfdmVjXCIsXG4gICAgICAgICAgICAgICAgc3ViLm1hdCA9IEJMT1NVTTYyLFxuICAgICAgICAgICAgICAgIGdhcC5wZW5hbHR5ID0gIC0xMCkifQ== We can call the sum() function on the score column of the shrm dataframe to calculate the overall score for the alignment. This is a metric that tells use how good the alignment is based on the number of identical residues in the sequence, how different any mutations are from the original residue, and how many gaps there are. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdW0oc2hybSRzY29yZSkifQ== I happen to know that we can make this alignment better if we add a gap. I’ll do it by hand because I don’t have a function yet to do it automatically. I’ll put a gap into the human shroom 3 sequence (hShrm3_alt) after the “W” that’s about in the middle of the sequence. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoU2hybTNfYWx0ICA8LSBjKFwiRVwiLFwiUFwiLFwiRVwiLFwiUlwiLFwiRVwiLFwiUFwiLFwiRVwiLFwiV1wiLFwiLVwiLFwiUlwiLFwiRFwiLFwiUlwiLFwiUFwiLFwiR1wiLFwiU1wiLFwiUFwiKSJ9 Using an appropriate function, confirm that the insertion has made the sequence longer (hint: its not nchar) Now we’ll do the other sequence. To make this work we need to add an insertion to the end of the mouse sequence (mShrm3_alt) so that the two sequences are the same length. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJtU2hybTNfYWx0ICA8LSBjKFwiRVwiLFwiQVwiLFwiRVwiLFwiUlwiLFwiRVwiLFwiQVwiLFwiU1wiLFwiV1wiLFwiU1wiLFwiRVwiLFwiRFwiLFwiUlwiLFwiUFwiLFwiR1wiLFwiVFwiLFwiLVwiKSJ9 Again, check that this sequence is longer than it was before A handy trick is to do a logical comparison to check that the two vectors are the same. Run the following code and see if you can interpret what is going on. Remember that the double equals sign == carries out a logical comparison that returns TRUE if two values are the same. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsZW5ndGgoaFNocm0zX2FsdCkgPT0gbGVuZ3RoKG1TaHJtM19hbHQpIn0= Now, for a challenge, see if you can figure out what’s going on here eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoU2hybTNfYWx0ID09IG1TaHJtM19hbHQifQ== It might be easier if we stack thing in to a little matrix with rbind(). I’ve put a lot of stuff in the rbind() function but see if you can figure it out. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyYmluZChoU2hybTNfYWx0ID0gaFNocm0zX2FsdCxcbiAgICAgIG1TaHJtM19hbHQgPSBtU2hybTNfYWx0LFxuICAgICAgaWRlbnRpY2FsID0gaFNocm0zX2FsdCA9PSBtU2hybTNfYWx0KSJ9 Now let’s compare these two sequences by scoring them. First, we’ll put them into a dataframe using data.frame(). We’ll call the object shrm.gap. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJtLmdhcCA8LWRhdGEuZnJhbWUoaFNocm0zX2FsdCxcbiAgICAgICAgICAgICAgICAgICAgICBtU2hybTNfYWx0LCBcbiAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdzQXNGYWN0b3JzID0gRikifQ== Run an appropriate function to confirm that this is a dataframe Check what the size of the dataframe is: Now look at the full dataframe Now run a function to just look at the top of the dataframe: Run a function to just look at the bottom of the dataframe Ok, we have a sense of what we’re working with. Let’s calculate the score eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJtLmdhcCA8LSBzY29yZV9hbGlnbm1lbnQoc2hybS5nYXAsIFxuICAgICAgICAgICAgICAgICAgICAgc2VxMT0gIFwiaFNocm0zX2FsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgc2VxMiA9IFwibVNocm0zX2FsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgc3ViLm1hdD0gQkxPU1VNNjIsXG4gICAgICAgICAgICAgICAgICAgICBnYXAucGVuYWx0eSA9LTEwKSJ9 Look at the dataframe and make sure it looks right. Note that each gap (“-”) has a score of 10 as defined by the gap.penalty. Now calculate the total score eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdW0oc2hybS5nYXAkc2NvcmUpIn0= There is one issue here which I haven’t yet resolved. When alignment are scored we take into account two things: the creation of a gap (yes there is a gap there) and its length (how long it it). Each gap that get’s created gets scores -10 for occurring and -4 for each insertion in the gap. So a gap of 1 insertion (“-”) gets score -10 + -4 eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiItMTAgKyAtNCJ9 A gap of 2 insertions (“–”) gets a score of eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIoLTEwICsgLTQpICsgLTQifQ== A gap of 3 insertions (“—”) gets a score of eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIoLTEwICsgLTQpICsgLTQgKyAtNCJ9 Our alignment has two separate insertions, one in the middle and one on the end. In the logic of alignment this is two separate insertions each of length one, so each one gets scored -10 + -4 = -14 I haven’t written a function yet to implement counting up the length of the insertions, so the score returned by score_alignment() is not correct. Based on the description above, what is the correct score? Write out R code using sum() to calculate the correct score. "],["retrieving-multiple-sequences-in-r.html", "Chapter 29 Retrieving multiple sequences in R 29.1 Prelminaries 29.2 Retrieving a set of sequences from UniProt 29.3 Downloading sequences in bulk", " Chapter 29 Retrieving multiple sequences in R eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGNvbXBiaW80YWxsKSJ9 By: Avril Coghlan. Multiple Alignment and Phylogenetic trees https://a-little-book-of-r-for-bioinformatics.readthedocs.io/en/latest/src/chapter5.html Adapted, edited and expanded: Nathan Brouwer under the Creative Commons 3.0 Attribution License (CC BY 3.0). 29.1 Prelminaries eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIyBwYWNrYWdlXG5saWJyYXJ5KGNvbXBiaW80YWxsKVxubGlicmFyeShyZW50cmV6KSAgICAjIHN0aWxsIG5lZWRlZD8ifQ== 29.2 Retrieving a set of sequences from UniProt Using websites or R you can search fort DNA or protein sequences in sequence databases such as the NCBI database and UniProt. Oftentimes, it is useful to retrieve several sequences at once. The R function entrez_fetch() from the rentrez package is useful for this purpose. Other packages can also, such as sequinr this but rentrez has the cleanest interface. We’ll retrieve the protein sequences for these UniProt accessions P06747: rabies virus phosphoprotein P0C569: Mokola virus phosphoprotein O56773: Lagos bat virus phosphoprotein Q5VKP1: Western Caucasian bat virus phosphoprotein Rabies virus is the virus responsible for rabies, which is classified by the WHO as a neglected tropical disease. Rabies is not a major human pathogen in the USA and Europe, but is problem in Africa. [Mokola virus](https://en.wikipedia.org/wiki/Mokola_lyssavirus() and rabies virus are closely related viruses that both belong to a group of viruses called the Lyssaviruses. Mokola virus causes a rabies-like infection in mammals including humans. You can type make a vector containing the names of the sequences. Note that the accessions aren’t numbers but are quoted character strings: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFuYW1lcyA8LSBjKFwiUDA2NzQ3XCIsIFxuICAgICAgICAgICAgICBcIlAwQzU2OVwiLCBcbiAgICAgICAgICAgICAgXCJPNTY3NzNcIiwgXG4gICAgICAgICAgICAgIFwiUTVWS1AxXCIpICAifQ== Confirm that we are working with character data using is.character() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpcy5jaGFyYWN0ZXIoc2VxbmFtZXMpIn0= We can access the first element of the vector, P06747, using bracket notation like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFuYW1lc1sxXSJ9 The code to access the second and third elements of the vector of accessions is: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIDJuZCBhY2Nlc3Npb25cbnNlcW5hbWVzWzJdXG5cbiMgM3JkIGFjY2Vzc2lvblxuc2VxbmFtZXNbM10ifQ== Now let’s use this vector of accessions to download sequence data. To make sure we understand what we’re doing, first we’ll download just the sequences one by one. This code retrieves the first sequence and store them in vector variable seqs. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXExIDwtIHJlbnRyZXo6OmVudHJlel9mZXRjaChkYiA9IFwicHJvdGVpblwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBzZXFuYW1lc1sxXSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHR5cGUgPSBcImZhc3RhXCIpICAgICAgIn0= We can do the next two sequences by change id = ... to seqnames[2] and seqnames[3]. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHNlcXVlbmNlIHR3byB1c2luZyBzZXFuYW1lc1syXVxuc2VxMiA8LSByZW50cmV6OjplbnRyZXpfZmV0Y2goZGIgPSBcInByb3RlaW5cIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gc2VxbmFtZXNbMl0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR0eXBlID0gXCJmYXN0YVwiKSBcblxuIyBzZXF1ZW5jZSB0d28gdXNpbmcgc2VxbmFtZXNbM11cbnNlcTMgPC0gcmVudHJlejo6ZW50cmV6X2ZldGNoKGRiID0gXCJwcm90ZWluXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IHNlcW5hbWVzWzNdLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dHlwZSA9IFwiZmFzdGFcIilcblxuIyBzZXF1ZW5jZSB0d28gdXNpbmcgc2VxbmFtZXNbNF1cbnNlcTQgPC0gcmVudHJlejo6ZW50cmV6X2ZldGNoKGRiID0gXCJwcm90ZWluXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IHNlcW5hbWVzWzRdLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dHlwZSA9IFwiZmFzdGFcIikifQ== Each of these is in raw FASTA format eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXExIn0= To do an analysis of these we need to clean each of these vectors using fasta_cleaner(). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXExIDwtIGZhc3RhX2NsZWFuZXIoc2VxMSwgcGFyc2UgPSBUKSAgXG5zZXEyIDwtIGZhc3RhX2NsZWFuZXIoc2VxMiwgcGFyc2UgPSBUKSAgXG5zZXEzIDwtIGZhc3RhX2NsZWFuZXIoc2VxMywgcGFyc2UgPSBUKSAgXG5zZXE0IDwtIGZhc3RhX2NsZWFuZXIoc2VxNCwgcGFyc2UgPSBUKSAgIn0= Print out the first 20 letters of the first sequence eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXExWzE6MjBdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAifQ== Print out the first 20 letters of the second sequence eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXEyWzE6MjBdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAifQ== We have these four sequences, each cleaned and in its own vector. We can therefore do dotplots, alignments, and other analyses. Creating all these separate vectors is a bit laborious. Luckily entrez_fetch() can download multiple sequences for us. 29.3 Downloading sequences in bulk Previously we were giving entrez_fetch the name of just one sequence at a time by using square brackets on our seqnames vector, e.g. seqnames[1], seqnames[2] etc. If don’t include square brackets, entrez_fetch() will download all of the sequences in succession and package them up into a single long, formatted string. This may take a second or two, depending on your internet connection and how busy the NCBI servers are. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfMV8yXzNfNCA8LSByZW50cmV6OjplbnRyZXpfZmV0Y2goZGIgPSBcInByb3RlaW5cIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gc2VxbmFtZXMsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR0eXBlID0gXCJmYXN0YVwiKSJ9 We can view what we have in a nice format using the cat() function. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjYXQoc2VxXzFfMl8zXzQpIn0= This is a good way to store FASTA files, but we can’t work with them in this format - they need to be in vectors. To give us FASTA data in a usable form the compbio4all package has a function called entrez_fetch_list(), which is a wrapper for entrez_fetch() which returns each sequence in its own separate slot in a list. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfMV8yXzNfNCA8LSBlbnRyZXpfZmV0Y2hfbGlzdChkYiA9IFwicHJvdGVpblwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBzZXFuYW1lcywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHR5cGUgPSBcImZhc3RhXCIpIn0= Let’s look at the output eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfMV8yXzNfNCJ9 Note that before each sequence is its name, preceded by a dollar sign, e.g. $P06747. This is the name of each element of our list. We can confirm that we have a list using is.list(). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpcy5saXN0KHNlcV8xXzJfM180KSJ9 The size of the list is the number of elements it contains, not the amount of data in each element. There are 4 sequences, so 4 elements, so length = 4. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsZW5ndGgoc2VxXzFfMl8zXzQpIn0= We can access each element of the list by name, like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfMV8yXzNfNCRQMDY3NDcifQ== We can also access it by its index number, like this, using double-bracket notation. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfMV8yXzNfNFtbMV1dICNOT1RFOiBkb3VibGUgYnJhY2tldHMifQ== Each element of the list is a vector. We can check this using is.vector() like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpcy52ZWN0b3Ioc2VxXzFfMl8zXzQkUDA2NzQ3KSJ9 or using double brackets like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpcy52ZWN0b3Ioc2VxXzFfMl8zXzRbWzFdXSkifQ== Its character data, which we can confirm with class() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjbGFzcyhzZXFfMV8yXzNfNCRQMDY3NDcpICMgZG9sbGFyIHNpZ24gbm90YXRpb25cbmNsYXNzKHNlcV8xXzJfM180W1sxXV0pICAgIyBkb3VibGUtYnJhY2tldCBub3RhdGlvbiJ9 "],["multiple-sequence-alignment-in-r.html", "Chapter 30 Multiple sequence alignment in R 30.1 Preliminaries 30.2 Multiple sequence alignment (MSA) 30.3 Make MSA with msa() 30.4 Viewing your MSA 30.5 Discarding very poorly conserved regions from an alignment", " Chapter 30 Multiple sequence alignment in R By: Nathan Brouwer, with some content adapted Coghlan (2011) Multiple Alignment and Phylogenetic trees and under the Creative Commons 3.0 Attribution License (CC BY 3.0). Functions print_msa() and clean_alignment() adapted from (Coglan 2011). 30.1 Preliminaries 30.1.1 Packages We’ll be using the package ggmsa for the first time and you will have to install it using install.packages(\"ggmsa\"). You may be asked to re-restart R more then once during the installation process. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIG5ldyBwYWNrYWdlc1xuIyMgT25seSBpbnN0YWxsIG9uY2VcbiMgaW5zdGFsbC5wYWNrYWdlcyhcImdnbXNhXCIpXG5saWJyYXJ5KGdnbXNhKSAgICAgICAjIHZpc3VhbGl6ZSBNU0FcblxuIyBvdGhlciBwYWNrYWdlc1xubGlicmFyeShjb21wYmlvNGFsbClcbmxpYnJhcnkoQmlvc3RyaW5ncykgICMgY29udmVydCBGQVNUQSB0byBBQVN0cmluZ1NldFxubGlicmFyeShtc2EpICAgICAgICAgIyBtdWx0aXBsZSBzZXF1ZW5jZSBhbGlnbm1lbnQifQ== 30.1.2 Functions The following key functions from compbio4all are used in this lesson fasta_cleaner() entrez_fetch_list() print_msa() clean_alignment() 30.2 Multiple sequence alignment (MSA) A common task in bioinformatics is to download a set of related sequences from a database, and then to align those sequences using multiple alignment software. This is the first step in almost all phylogenetic analyses using sequence data. 30.3 Make MSA with msa() WE’ll use a package called msa (Bodenhofer et al. 2015). There are several packages that can do multiple sequence alignment in R, but they all require loading an external piece of alignment software that is just accessed via R. The msa package actually runs the alignment algorithms entirely in R, making workflows simpler. 30.3.1 Data preparation The data is stored in object in combio4all eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYXRhKHNlcV8xXzJfM180KSAifQ== This data is in the form of a list eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpcy5saXN0KHNlcV8xXzJfM180KSJ9 First we need to clean each one using fasta_cleaner(). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfMV8yXzNfNFtbMV1dIDwtIGZhc3RhX2NsZWFuZXIoc2VxXzFfMl8zXzRbWzFdXSlcbnNlcV8xXzJfM180W1syXV0gPC0gZmFzdGFfY2xlYW5lcihzZXFfMV8yXzNfNFtbMl1dKVxuc2VxXzFfMl8zXzRbWzNdXSA8LSBmYXN0YV9jbGVhbmVyKHNlcV8xXzJfM180W1szXV0pXG5zZXFfMV8yXzNfNFtbNF1dIDwtIGZhc3RhX2NsZWFuZXIoc2VxXzFfMl8zXzRbWzRdXSkifQ== We need to put it into the form of a vector; in particular a named vector. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfMV8yXzNfNF92ZWN0b3IgPC0gYyhQMDY3NDcgPSBwYXN0ZShzZXFfMV8yXzNfNFtbMV1dLCBjb2xsYXBzZSA9IFwiXCIpLFxuICAgICAgICAgICAgICAgICBQMEM1NjkgPSBwYXN0ZShzZXFfMV8yXzNfNFtbMl1dLCBjb2xsYXBzZSA9IFwiXCIpLFxuICAgICAgICAgICAgICAgICBPNTY3NzMgPSBwYXN0ZShzZXFfMV8yXzNfNFtbM11dLCBjb2xsYXBzZSA9IFwiXCIpLFxuICAgICAgICAgICAgICAgICBRNVZLUDEgPSBwYXN0ZShzZXFfMV8yXzNfNFtbNF1dLCBjb2xsYXBzZSA9IFwiXCIpKSJ9 We’ll need need to convert our set of sequences to a particular format in preparation for alignment. This is done with the AAStringSet() function from Biostrings. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfMV8yXzNfNF9zdHJpbmdzZXQgPC0gQmlvc3RyaW5nczo6QUFTdHJpbmdTZXQoc2VxXzFfMl8zXzRfdmVjdG9yKSJ9 This just puts things in a format that makes the software happy. Doing this is a theme of bioinformatics work! eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfMV8yXzNfNF9zdHJpbmdzZXQifQ== Next, we can run the alignment algorithm with the msa() function. There are many algorithms and pieces software for building alignments. The msa packages implements three major ones: ClustalW ClustalOmega Muscle We’ll use ClustalW. Depending on the size and number of sequences this may take a little bit of time. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ2aXJ1c2FsbiA8LSBtc2EoaW5wdXRTZXFzID0gc2VxXzFfMl8zXzRfc3RyaW5nc2V0LFxuICAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gXCJDbHVzdGFsV1wiKSJ9 We can view a snapshot of the alignment. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ2aXJ1c2FsbiJ9 Each sequence is on a line. The consensus sequence indicates something similar to the average of all the sequences and is on the bottom and labeled Con. Question marks indicate that the software could not determine a consensus. Dashes indicate either indels (insertions or deletions), or are added at the begining and end of sequences of unequal length so that they line up. The output from msa() is a particular class of R object, a MsaAAMultipleAlignment. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpcyh2aXJ1c2FsbilcbmNsYXNzKHZpcnVzYWxuKSJ9 Next we’ll want to visualize our alignment. In order to do further work with the MSA we’re going to - I bet you can guess what happens next - make a conversion to the object. In this case we’re going to make a subtle change by calling up the class() of the alignment and changing it from MsaAAMultipleAlignment (with “Msa” at the beginning) to AAMultipleAlignment (no “Msa”). (This is an annoying step and is needed because the folks who wrote the msa package have yet to collaobrate with the folks who wrote another package we’ll use in a little bit). Don’t worry if you don’t understand what’s going on here - just run the code. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjbGFzcyh2aXJ1c2FsbikgPC0gXCJBQU11bHRpcGxlQWxpZ25tZW50XCIifQ== 30.4 Viewing your MSA There are several ways to view and explore your MSA Within the R console using compbio4all::print_msa() As an R plot using ggmsa::ggmas() OPTIONAL: As a PDF using msa::msaPrettyPrint() 30.4.1 Viewing a long multiple alignment in the R console. If you want to view a long multiple alignment within the R console, it is convenient to view the multiple alignment in blocks. The function print_msa() (Coglan 2011)below will do this for you. As its inputs, the function print_msa() takes the two things alignment: input alignment chunksize: the number of columns to print out in each block. To use print_msa() we first need to do a little format conversion: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ2aXJ1c2Fsbl9zZXFpbnIgPC0gbXNhQ29udmVydCh2aXJ1c2FsbiwgdHlwZSA9IFwic2VxaW5yOjphbGlnbm1lbnRcIikifQ== Then we can print it out like this, making the alignment 60 bases wide: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwcmludF9tc2EoYWxpZ25tZW50ID0gdmlydXNhbG5fc2VxaW5yLCBcbiAgICAgICAgICBjaHVua3NpemUgPSA2MCkifQ== 30.4.2 Visualizing alignments as an R plot A powerful tool for visualizing focal parts of an alignment is ggmsa. If you haven’t already, download it with install.packages(\"ggmsa\") and load it with library(ggmsa). ggmsa prints a sequence alignment out within RStudio. Alignments can be large, so its important to select a subset of the alignment for visualzation. First, let’s look at the first 20 bases of our alignment. Note that we are using virusaln, NOT virusaln_seqinr (sorry for the back and forth between objects.) eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJnZ21zYSh2aXJ1c2FsbiwgICAjIHZpcnVzYWxuLCBOT1QgdmlydXNhbG5fc2VxaW5yXG4gICAgICBzdGFydCA9IDEsIFxuICAgICAgZW5kID0gMjApICJ9 30.4.2.1 OPTIONAL: File types used by ggmsa The ggmsa packages currently only works with certain types of alignment output. We can see what these are with available_msa(). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJhdmFpbGFibGVfbXNhKCkifQ== As you can see there are a number of ways multiple sequence alignments can be represented in R. This has to do with the facts that i) There are many pieces of software / algorithms for making MSAs, and many bioinformatics packages that work with them., You can see that AAMultipleAlignment is listed, which the the format we set previously using the class() command. The msa packages has a function msaConvert() which can change formats between different ways of representing MSAs which may be useful. 30.4.3 OPTIONAL: Print MSA to PDF The msa package has a fabulous function, msaPrettyPrint() for rendering an MSA to PDF. It can take a little bit to run, and in order to vioew the PDF you need to locate the output. (Again, we’ll use virusaln, not virusaln_seqinr). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJtc2FQcmV0dHlQcmludCh2aXJ1c2FsbiwgICAgICMgdmlydXNhbG4sIE5PVCB2aXJ1c2Fsbl9zZXFpbnJcbiAgICAgICAgICAgICAgIGZpbGUgPSBcIm15X21zYS5wZGZcIixcbiAgICAgICAgICAgICAgIGFza0Zvck92ZXJ3cml0ZSA9IEYpIn0= On a Mac usually searching in Finder will locate the file even after is just created. You can ask R where it is saving thing using getwd(). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJnZXR3ZCgpIn0= You can change where R is saving things using the RStudio menu by clicking on Session -&gt; Set Working Directory -&gt; Choose directory… 30.5 Discarding very poorly conserved regions from an alignment It is often a good idea to discard very poorly conserved regions from a multiple sequence alignment before visualizing it or building a phylogenetic tree, as the very poorly conserved regions are likely to be regions that are either non-homologous between the sequences being considered (and so do not have any phylogenetic signal), or are homologous but are so diverged that they are very difficult to align accurately (and so may add noise to the phylogenetic analysis, and decrease the accuracy of the inferred tree). To discard very poorly conserved regions from a multiple alignment, you can use the following R function, clean_alignment() ((Coglan 2011)) The function clean_alignment() takes three arguments (inputs): the input alignment; minpcnongap: the minimum percent of letters in an alignment column that must be non-gap characters for the column to be kept; and minpcid: the minimum percent of pairs of letters in an alignment column that must be identical for the column to be kept. For example, if we have a single column (locus) with letters “T”, “A”, “T”, “-” (in four sequences), then 75% of the letters are non-gap characters; and the pairs of letters between the three non-gap sequences are 1 versus 2: “T,A”, 1 versus 3: “T,T”, 2 versus 3: “A,T”, Therefore 33% of the pairs of letters are identical (PID) for that position in the alignment. If you look at the multiple alignment for the virus phosphoprotein sequences (which we printed out using function print_msa(), see above), we can see that the last few columns are poorly aligned (contain many gaps and mismatches), and probably add noise to the phylogenetic analysis. Let’s cleave off anything with less than 30% non-gap and less than 30% PID. NOTE: we’re bac to using virusaln_seqinr, not virusaln. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ2aXJ1c2Fsbl9zZXFpbnJfY2xlYW4gPC0gY2xlYW5fYWxpZ25tZW50KGFsaWdubWVudCA9IHZpcnVzYWxuX3NlcWluciwgICMgdmlydXNhbG5fc2VxaW5yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbnBjbm9uZ2FwID0gMzAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5wY2lkID0gMzApIn0= In this case, we required that at least 30% of letters in a column are not gap characters for that column to be kept, and that at least 30% of pairs of letters in an alignment column must be identical for the column to be kept. We can print out the filtered alignment by typing: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwcmludF9tc2EodmlydXNhbG5fc2VxaW5yX2NsZWFuKSJ9 The filtered alignment is shorter, and is missing some of the poorly conserved regions of the original alignment. Note that it is not a good idea to filter out too much of your alignment, as if you are left with few columns in your filtered alignment, you will be basing your phylogenetic tree upon a very short alignment (little data), and so the tree may be unreliable. Therefore, you need to achieve a balance between discarding the dodgy (poorly aligned) parts of your alignment, and retaining enough columns of the alignment that you will have enough data to based your tree upon. "],["the-blosum-scoring-matrix-in-r.html", "Chapter 31 The BLOSUM scoring matrix in R 31.1 Introduction 31.2 Preliminaries 31.3 Load packages 31.4 The BLOSUM matrix 31.5 Visualizing the BLOSUM matrix", " Chapter 31 The BLOSUM scoring matrix in R By Nathan Brouwer eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGNvbXBiaW80YWxsKSJ9 31.1 Introduction In this lesson we will introduce the basic structure of the BLOSUM scoring matrix. 31.2 Preliminaries 31.2.1 Packages BiocManager Biostrings combio4all 31.2.2 Vocab 31.2.2.1 Math / R vocab triangular matrix square matrix lower triangle upper triangle symmetric matrix matrix diagonal named vectors named matrices accessing items in named vectors or matrices square bracket notation 31.2.2.2 Bioinformatics vocab scoring matrix BLOSUM scoring matrix ambiguity codes 31.2.3 Functions used 31.2.3.1 Base R functions data() is() nrow(), ncol(), dim(), names(), colnames(), rownames(), head(), tail() 31.2.3.2 Specific function combio4all::tri_print() combio4all::diag_show() 31.3 Load packages Load basic packages eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGZsZXh0YWJsZSlcbmxpYnJhcnkod2Vic2hvdCkifQ== Install the Biostrings package from Bioconductor; you don’t have to run this if you already happen to have downloaded Biostrings before eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KEJpb3N0cmluZ3MpIn0= 31.4 The BLOSUM matrix When data is contained within an R package we can load it using the data() function. We’ll work with a version of the BLOSUM62 matrix in the Biostrings package Load BLOSUM62 amino acid substitution matrix using data() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYXRhKEJMT1NVTTYyKSJ9 Bioinformatics uses a lot of difference data structures, including dataframes, matrices, vectors, etc. What is the data structure of BLOSUM62? Use is() Take a look at the whole matrix by just calling up the object on its own: Whenever you start working with data its important to get a sense of what’s there, how much of its there, and if there is anything goofy. Since it can be hard to see a dataframe or matrix on a screen its important to explore it with various commands, including nrow(), ncol(), dim(), colnames(), rownames(), head(), and tail() Use nrow() and ncol() to determine the number of rows and columns. This is a square matrix since the number of rows equals the number of columns. It is also a symmetrical matrix since the lower triangle of the matrix is the same as the upper triangle. The compbio4all package has functions for displaying these. R shows us the full symmetric matrix, though in books usually they just show the lower triangle. A symmetric matrix is one where the upper and lower triangles are identical. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCTE9TVU02MiJ9 The function tri_print() will print just the lower triangle, with all the other values left empty. (This might be a bit slow) eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmlfcHJpbnQoQkxPU1VNNjIsIGFzLmltYWdlID0gVCkifQ== BLOSUM62 is a matrix for scoring differences between sequences of amino acids. Is the size of this R object therefore a bit odd? We should check out what these rows and columns actually are. What are the row names of the matrix? Use rownames() to determine this. What are the column names? Run the appropriate command below to determine this. Look at the top of the matrix using head(). Look at the bottom of the matrix using tail(). What have we learned? There’s more than 20 rows and columns (why is 20 the reference point?). The B, J, Z, X and * represent more ambiguity codes. These usually show up due to sequencing errors or lack of full resolution of an amino acid in the sequence because they are so close chemically (e.g. Asparagine versus aspartic acid) . B means its ambiguous whether the amino acid is asparagine or aspartici acid (D or N) J is used when its ambiguous whether its I or L. Z means its ambiguous whether the amino acid is glutamine or glutamic acid (E or Q). X is a stand in for any or an unknown code. This might occur if there is a sequencing error. The asterisk “*” is used to represent stop codons. We’ll be working with sequences without any ambiguities. In the following sections of code we’ll remove these ambiguity codes. 31.5 Visualizing the BLOSUM matrix We can visualize the BLOSUM matrix by first drawing all 20 amino acids in a circle. ## Loading required package: BiocGenerics ## Loading required package: parallel ## ## Attaching package: &#39;BiocGenerics&#39; ## The following objects are masked from &#39;package:parallel&#39;: ## ## clusterApply, clusterApplyLB, clusterCall, clusterEvalQ, ## clusterExport, clusterMap, parApply, parCapply, parLapply, ## parLapplyLB, parRapply, parSapply, parSapplyLB ## The following objects are masked from &#39;package:stats&#39;: ## ## IQR, mad, sd, var, xtabs ## The following objects are masked from &#39;package:base&#39;: ## ## anyDuplicated, append, as.data.frame, basename, cbind, colnames, ## dirname, do.call, duplicated, eval, evalq, Filter, Find, get, grep, ## grepl, intersect, is.unsorted, lapply, Map, mapply, match, mget, ## order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank, ## rbind, Reduce, rownames, sapply, setdiff, sort, table, tapply, ## union, unique, unsplit, which, which.max, which.min ## Loading required package: S4Vectors ## Loading required package: stats4 ## ## Attaching package: &#39;S4Vectors&#39; ## The following object is masked from &#39;package:base&#39;: ## ## expand.grid ## Loading required package: IRanges ## Loading required package: XVector ## ## Attaching package: &#39;Biostrings&#39; ## The following object is masked from &#39;package:base&#39;: ## ## strsplit ## ## Attaching package: &#39;igraph&#39; ## The following object is masked from &#39;package:Biostrings&#39;: ## ## union ## The following object is masked from &#39;package:IRanges&#39;: ## ## union ## The following object is masked from &#39;package:S4Vectors&#39;: ## ## union ## The following objects are masked from &#39;package:BiocGenerics&#39;: ## ## normalize, path, union ## The following objects are masked from &#39;package:stats&#39;: ## ## decompose, spectrum ## The following object is masked from &#39;package:base&#39;: ## ## union In theory, all mutations can change any codon into any other codon. We can represent mutations that result in a changed in the amino acid by connecting each amino acid with an arrow. We’ll do this for adenine. Thicker arrows represent more common transitions. Often, there will be no change in a codon, the changes don’t impact which amino acid, or a mutation to a different codon is reversed due to a back mutation. We can represent the fact that an adenine can stay as adenine with a self loop. You can see that the most common “transition” is for adenine to remain as adenine. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJibG9zdW0uZ3JhcGguQSA8LSBncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoQkxPU1VNNjJfYWxsX3Bvc19BLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWcgPSBULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodGVkID0gVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gXCJkaXJlY3RlZFwiKVxuXG5cbnBsb3QuaWdyYXBoKGJsb3N1bS5ncmFwaC5BICxcbiAgICAgICAgICAgIGxheW91dCA9IGJsb3N1bS5ncmFwaC5jaXJjbGUsIFxuICAgICAgICAgICAgZWRnZS5hcnJvdy5zaXplID0wLjUsXG4gICAgICAgICAgICB2ZXJ0ZXguY29sb3I9IDE6MjAsIFxuICAgICAgICAgICAgZWRnZS5jb2xvciA9IDE6MjAsXG4gICAgICAgICAgICBlZGdlLndpZHRoID0gRShibG9zdW0uZ3JhcGguQSkkd2VpZ2h0LzEwXG4gICAgICAgICAgICApIn0= Instead of laying things out in circle, we can have them oriented so that the amino acids adenine is most likely to transition to are closest to it. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJibG9zdW0uZ3JhcGguQSA8LSBncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgoQkxPU1VNNjJfYWxsX3Bvc19BLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWcgPSBGLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodGVkID0gVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gXCJkaXJlY3RlZFwiKVxucGxvdC5pZ3JhcGgoYmxvc3VtLmdyYXBoLkEgLFxuICAgICAgICAgICAgI2xheW91dCA9IGJsb3N1bS5ncmFwaC5jaXJjbGUsIFxuICAgICAgICAgICAgZWRnZS5hcnJvdy5zaXplID0wLjUsXG4gICAgICAgICAgICB2ZXJ0ZXguY29sb3I9IDE6MjAsIFxuICAgICAgICAgICAgZWRnZS5jb2xvciA9IDE6MjAsXG4gICAgICAgICAgICBlZGdlLndpZHRoID0gRShibG9zdW0uZ3JhcGguQSkkd2VpZ2h0LzEwXG4gICAgICAgICAgICApIn0= We can extend this by considering all possible transition and making a plot that tries to orient each amino acid close to the other amino acids its likely to transition to, and far from those its unlikely to. This is a bit tricky, since all transitions are now being consider. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJibG9zdW0uZ3JhcGguYWxsIDwtIGdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChCTE9TVU02Ml9hbGxfcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWcgPSBGLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodGVkID0gVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gXCJkaXJlY3RlZFwiKVxucGxvdC5pZ3JhcGgoYmxvc3VtLmdyYXBoLmFsbCxcbiAgICAgICAgICAgIGVkZ2UuYXJyb3cuc2l6ZSA9IDAsXG4gICAgICAgICAgICB2ZXJ0ZXguY29sb3I9IDE6MjAsXG4gICAgICAgICAgICBlZGdlLmNvbG9yID0gMSkifQ== "],["calculating-genetic-distances-between-sequences.html", "Chapter 32 Calculating genetic distances between sequences 32.1 Preliminaries 32.2 Introduction 32.3 Calculating genetic distances between DNA/mRNA sequences 32.4 Calculationg genetic distance", " Chapter 32 Calculating genetic distances between sequences By: Nathan Brouwer, with some content adapted Coghlan (2011) Multiple Alignment and Phylogenetic trees and under the Creative Commons 3.0 Attribution License (CC BY 3.0). Functions print_msa() and clean_alignment() adapted from (Coglan 2011). 32.1 Preliminaries eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGNvbXBiaW80YWxsKVxubGlicmFyeShtc2EpXG5saWJyYXJ5KHNlcWlucilcbmxpYnJhcnkoYXBlKSJ9 32.2 Introduction A common first step in performing a phylogenetic analysis is to calculate the pairwise genetic distances between sequences. The genetic distance is an estimate of the evolutionary divergence between two sequences, and is usually measured in quantity of evolutionary change, e.g., an estimate of the number of mutations that have occurred since the two sequences shared a common ancestor. We can calculate the genetic distances between protein sequences using the dist.alignment() function in the seqinr package. The dist.alignment() function takes a multiple sequence alignment (MSA) as input. Based on the MSA that you give it, dist.alignment() calculates the genetic distance between each pair of proteins in the multiple alignment, yielding pairwise distances. For example, to calculate genetic distances between the virus phosphoproteins based on the multiple sequence alignment stored in virusaln, we type: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYXRhKHZpcnVzYWxuKVxudmlydXNkaXN0IDwtIHNlcWlucjo6ZGlzdC5hbGlnbm1lbnQodmlydXNhbG5fc2VxaW5yKSAgIyBDYWxjdWxhdGUgdGhlIGdlbmV0aWMgZGlzdGFuY2VzXG5cbnZpcnVzZGlzdCAjIFByaW50IG91dCB0aGUgZ2VuZXRpYyBkaXN0YW5jZSBtYXRyaXgifQ== NOTE My result are different from the original results, shown here: I need to check the settings used for the MSA P0C569 O56773 P06747 O56773 0.4142670 P06747 0.4678196 0.4714045 Q5VKP1 0.4828127 0.5067117 0.5034130 The genetic distance matrix above shows the genetic distance between each pair of proteins. The sequences are referred to by their UniProt accessions. Recall that P06747 = rabies virus phosphoprotein P0C569 is Mokola virus phosphoprotein O56773 is Lagos bat virus phosphoprotein Q5VKP1 is Western Caucasian bat virus phosphoprotein. Based on the genetic distance matrix above, we can see that the genetic distance between Lagos bat virus phosphoprotein (O56773) and Mokola virus phosphoprotein (P0C569) is smallest (about 0.414). Similarly, the genetic distance between Western Caucasian bat virus phosphoprotein (Q5VKP1) and Lagos bat virus phosphoprotein (O56773) is the biggest (about 0.507). The larger the genetic distance between two sequences, the more amino acid changes (such as change from Asp to Met) or indels that have occurred since they shared a common ancestor, and the longer ago their common ancestor probably lived. (The relationship between number of mutations and time, however, depends on the mutation rate and generation time of the organism). 32.3 Calculating genetic distances between DNA/mRNA sequences Just like for protein sequences, you can calculate genetic distances between DNA (or mRNA) sequences based on an alignment of the sequences. The RefSeq DNA accession numbers for the proteins we’ve been using are: AF049118 = mRNA sequence for Mokola virus phosphoprotein, AF049114 = mRNA sequence for Mokola virus phosphoprotein, AF049119 = mRNA sequence for Lagos bat virus phosphoprotein, AF049115 = mRNA sequence for Duvenhage virus phosphoprotein. We can retrieve these DNA sequences using entrez_fetch_list(). Some notes about how we’ll use this function works: db is short for “database” the database is called nuccore (not genebank or gene) the argument rettype is “tt”; I think it stands for “REtURN type” (I also forget the second “t”) eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHB1dCBhY2Nlc3Npb25zIGluIHZlY3RvclxuYWNjZXNzaW9uc19tcm5hIDwtIGMoXCJBRjA0OTExOFwiLFwiQUYwNDkxMTRcIixcIkFGMDQ5MTE5XCIsXCJBRjA0OTExNVwiKVxuXG4jIGdldCBzZXF1ZW5jZXNcbnZpcnVzX21ybmFfbGlzdCA8LSBlbnRyZXpfZmV0Y2hfbGlzdChkYiA9IFwibnVjY29yZVwiLCAgIyBcIm51Y2NvcmVcIiBkYiBmb3IgRE5BIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IGFjY2Vzc2lvbnNfbXJuYSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHR5cGUgPSBcIkZBU1RBXCIpICMgcmV0dHlwZSBoYXMgdHdvIHQifQ== We can clean these three sequences using a simple for() loop. We set parse = F so we get things back as single character string. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJmb3IoaSBpbiAxOmxlbmd0aCh2aXJ1c19tcm5hX2xpc3QpKXtcbiAgdmlydXNfbXJuYV9saXN0W1tpXV0gPC0gZmFzdGFfY2xlYW5lcih2aXJ1c19tcm5hX2xpc3RbaV0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2UgPSBGKVxufSJ9 Now we need to convert each of these into a named vector of sequences. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJtcmFfc2VxX3ZlY3RvciA8LSBjKEFGMDQ5MTE4ID0gIHZpcnVzX21ybmFfbGlzdFtbMV1dICxcbiAgICAgICAgICAgICAgICAgQUYwNDkxMTQgPSB2aXJ1c19tcm5hX2xpc3RbWzJdXSAsXG4gICAgICAgICAgICAgICAgIEFGMDQ5MTE5ID0gdmlydXNfbXJuYV9saXN0W1szXV0gLFxuICAgICAgICAgICAgICAgICBBRjA0OTExNSA9IHZpcnVzX21ybmFfbGlzdFtbNF1dKSJ9 Finally convert this to a “stringset” using Biostrings::DNAStringSet(). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkbmFfc2VxX3N0cmluZ3NldCA8LSBCaW9zdHJpbmdzOjpETkFTdHJpbmdTZXQobXJhX3NlcV92ZWN0b3IpIn0= Let’s see what we got eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkbmFfc2VxX3N0cmluZ3NldCJ9 Now we can make an alignment use msa(). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ2aXJ1c19tcm5hX2FsbiA8LSBtc2EoaW5wdXRTZXFzID0gZG5hX3NlcV9zdHJpbmdzZXQsXG4gICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSBcIkNsdXN0YWxXXCIpIn0= The output looks like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ2aXJ1c19tcm5hX2FsbiJ9 This looks a LOT different than an amino acid alignment, which looked like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYXRhKHZpcnVzYWxuKVxudmlydXNhbG4ifQ== Why might the be different? First, examine the output above and determine how long the DNA alignment is versus the amino acid alignment? Why are they different, and why is one longer than the other? The DNA alignment is 1097 columns, while the amino acid alignment is only 306 rows. Note that 306*3 = 918. 1097 is pretty close to 1097. What’s the relevance of multiplying by 3? 32.4 Calculationg genetic distance You can calculate a genetic distance for DNA or mRNA sequences using the dist.dna() function in the ape package. dist.dna() takes a MSA of DNA or mRNA sequences as its input, and calculates the genetic distance between each pair of DNA sequences in the multiple alignment. The dist.dna() function requires the input alignment to be in a special format known as DNAbin format, so we must use the as.DNAbin() function to convert our DNA alignment into this format before using the dist.dna() function. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIgIyBDb252ZXJ0IHRoZSBhbGlnbm1lbnQgdG8gXCJETkFiaW5cIiBmb3JtYXRcbnZpcnVzX21ybmFfYWxuX2JpbiA8LSBhcGU6OmFzLkROQWJpbih2aXJ1c19tcm5hX2FsbikifQ== The output of as.DNAbin() gives us a short summery of the alignment eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ2aXJ1c19tcm5hX2Fsbl9iaW4ifQ== Now to make and view the alignment: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIgIyBDYWxjdWxhdGUgdGhlIGdlbmV0aWMgZGlzdGFuY2UgbWF0cml4XG52aXJ1c19tcm5hX2Rpc3QgPC0gYXBlOjpkaXN0LmRuYSh2aXJ1c19tcm5hX2Fsbl9iaW4pXG5cbiAjIFByaW50IG91dCB0aGUgZ2VuZXRpYyBkaXN0YW5jZSBtYXRyaXhcbnZpcnVzX21ybmFfZGlzdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIn0= NOTE: my results for this alignment are the same as the original by Coghlan. I’m not sure why my amino acid alignment produces divergent results but the DNA is the same. "],["unrooted-neighbor-joining-phylogenetic-trees.html", "Chapter 33 Unrooted neighbor-joining phylogenetic trees 33.1 Preliminaries 33.2 Building an unrooted phylogenetic tree for protein sequences 33.3 Boostrap values indicate support for clades 33.4 Branch lengths indicate divergence between sequences 33.5 Unrooted trees lack an outgroup", " Chapter 33 Unrooted neighbor-joining phylogenetic trees NOTE: the code for this chapter works as intended but there are some differences between my results and what is reported by the original author of the chapter. This is likely to do with different alignment software, though it could just be a typo. By: Avril Coghlan. Multiple Alignment and Phylogenetic trees https://a-little-book-of-r-for-bioinformatics.readthedocs.io/en/latest/src/chapter5.html Adapted, edited and expanded: Nathan Brouwer under the Creative Commons 3.0 Attribution License (CC BY 3.0). 33.1 Preliminaries eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGNvbXBiaW80YWxsKVxubGlicmFyeShzZXFpbnIpIn0= You will need to install the ape package if you do not have it already using install.packages(\"ape\"). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGFwZSkifQ== 33.1.1 Key functions compbio4all::unrooted_NJ_tree (Coghlan 200x) 33.1.2 Key vocab clade bootstrap resample rooted vs. unrooted tree outgroup 33.2 Building an unrooted phylogenetic tree for protein sequences Once we have a distance matrix that gives the pairwise distances between all our protein sequences, we can build a phylogenetic tree based on that distance matrix. One method for using this is the neighbor-joining algorithm. If we have the distance matrix already made we can make the tree like this using ape::nj(). The distance matrix is saved in compbio4all as virus_mrna_dist. Load this with data(). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIGxvYWQgdGhlIGRpc3RhbmNlIG1hdHJpeFxuZGF0YSh2aXJ1c19tcm5hX2Rpc3QpXG5cbiMgYnVpbGQgdGhlIHRyZWVcbnRyZWVfZnJvbV9kaXN0bWF0IDwtIG5qKHZpcnVzX21ybmFfZGlzdClcblxuXG5wbG90LnBoeWxvKHRyZWVfZnJvbV9kaXN0bWF0LCB0eXBlID0gXCJ1bnJvb3RlZFwiKSJ9 33.2.1 Build tree with unrooted_NJ_tree() Coghlan (2011) wrote a function to simply the steps of making an NJ tree. The R function unrooted_NJ_tree() is a wrapper for functions from the ape package which builds a phylogenetic tree based on an alignment of sequences, using the NJ algorithm. The unrooted_NJ_tree() function takes an alignment of sequences its input, calculates pairwise distances between the sequences based on the alignment behind the scenes, and then builds a phylogenetic tree based on the pairwise distances. It returns the phylogenetic tree, and also makes a plot of that tree. It also gives us information about to what extent the data in the original MSA support the evolutionary relationships shown in the tree. The alignment is saved in compbio4all as virusaln and can be loaded with the data() command. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYXRhKHZpcnVzYWxuX3NlcWlucikifQ== Take a look at the structure of the data eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHIodmlydXNhbG5fc2VxaW5yKSJ9 eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ2aXJ1c2FsbnRyZWUgPC0gdW5yb290ZWRfTkpfdHJlZSh2aXJ1c2Fsbl9zZXFpbnJfY2xlYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInByb3RlaW5cIikifQ== Note that you need to specify that the type of sequences that you are using are protein sequences when you use unrooted_NJ_tree(), by setting type=protein. We can see that Q5VKP1 (Western Caucasian bat virus phosphoprotein) and P06747 (rabies virus phosphoprotein) have been grouped together into a clade on the tree, and that O56773 (Lagos bat virus phosphoprotein) and P0C569 (Mokola virus phosphoprotein) are grouped together. This is consistent with what we saw above in the genetic distance matrix, which showed that the genetic distance between Lagos bat virus phosphoprotein (O56773) and Mokola virus phosphoprotein (P0C569) is relatively small. 33.3 Boostrap values indicate support for clades In the plot, the numbers in blue boxes are bootstrap values for the nodes in the tree. A bootstrap value for a particular node in the tree gives an idea of the confidence that we have in the clade (group) defined by that node in the tree. If a node has a high bootstrap value (near 100%) then we are very confident that the clade defined by the node is correct, while if it has a low bootstrap value (near 0%) then we are not so confident. Note that the fact that a bootstrap value for a node is high does not necessarily guarantee that the clade defined by the node is correct, but just tells us that it is quite likely that it is correct given the data and analysis we’re using. The bootstrap values are calculated by making many (for example, 100) random resamples of the alignment that the phylogenetic tree was based upon. Each resample of the alignment consists of a certain number x (e.g.. 200) of randomly sampled columns from the alignment. Each resample of the alignment (e.g.. 200 randomly sampled columns) forms a sort of fake alignment of its own, and a phylogenetic tree can be based upon the resample. We can make 100 random resamples of the alignment, and build 100 phylogenetic trees based on the 100 resamples. These 100 trees are known as the bootstrap trees. For each clade (grouping) that we see in our original phylogenetic tree, we can count in how many of the 100 bootstrap trees it appears. This is known as the bootstrap value for the clade in our original phylogenetic tree. For example, if we calculate 100 random resamples of the virus phosphoprotein alignment, and build 100 phylogenetic trees based on these resamples, we can calculate the bootstrap values for each clade in the virus phosphoprotein phylogenetic tree. NOTE: I am currently not able to reproduce these results: In this case, the bootstrap value for the node defining the clade containing Q5VKP1 (Western Caucasian bat virus phosphoprotein) and P06747 (rabies virus phosphoprotein) is 25%, while the bootstrap value for node defining the clade containing of Lagos bat virus phosphoprotein (O56773) and Mokola virus phosphoprotein (P0C569) is 100%. The bootstrap values for each of these clades is the percent of 100 bootstrap trees that the clade appears in. Therefore, we are very confident that Lagos bat virus and Mokola virus phosphoproteins should be grouped together in the tree. However, we are not so confident that the Western Caucasian bat virus and rabies virus phosphoproteins should be grouped together. 33.4 Branch lengths indicate divergence between sequences The lengths of the branches in the plot of the tree are proportional to the amount of evolutionary change (estimated number of mutations) along the branches. In this case, the branches leading to Lagos bat virus phosphoprotein (O56773) and Mokola virus phosphoprotein (P0C569) from the node representing their common ancestor are slightly shorter than the branches leading to the Western Caucasian bat virus (Q5VKP1) and rabies virus (P06747) phosphoproteins from the node representing their common ancestor. This suggests that there might have been more mutations in the Western Caucasian bat virus (Q5VKP1) and rabies virus (P06747) phosphoproteins since they shared a common ancestor, than in the Lagos bat virus phosphoprotein (O56773) and Mokola virus phosphoprotein (P0C569) since they shared a common ancestor. 33.5 Unrooted trees lack an outgroup The tree above of the virus phosphoproteins is an unrooted phylogenetic tree as it does not contain an outgroup sequence; that is, a sequence of a protein that is known to be more distantly related to the other proteins in the tree than they are to each other. As a result, we cannot tell which direction evolutionary time ran in along the internal branches of the tree. For example, we cannot tell whether the node representing the common ancestor of (O56773, P0C569) was an ancestor of the node representing the common ancestor of (Q5VKP1, P06747), or the other way around. In order to build a rooted phylogenetic tree, we need to have an outgroup sequence in our tree. In the case of the virus phosphoproteins, this is unfortunately not possible, as there is not any protein known that is more distantly related to the four proteins already in our tree than they are to each other. However, in many other cases, an outgroup - a sequence known to be more distantly related to the other sequences in the tree than they are to each other - is known, and so it is possible to build a rooted phylogenetic tree. We discussed above that it is a good idea to investigate whether discarding the poorly conserved regions of a multiple alignment has an effect on the phylogenetic analysis. In this case, we made a filtered copy of the multiple alignment and stored it in the variable virusln_seqinr_clean (see above). We can make a phylogenetic tree based this filtered alignment, and see if it agrees with the phylogenetic tree based on the original alignment: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYXRhKHZpcnVzYWxuX3NlcWlucl9jbGVhbilcbmNsZWFuZWR2aXJ1c2FsbnRyZWUgPC0gdW5yb290ZWRfTkpfdHJlZSh2aXJ1c2Fsbl9zZXFpbnJfY2xlYW4sdHlwZT1cInByb3RlaW5cIikifQ== As in the phylogenetic tree based on the raw (unfiltered) multiple alignment, O56773 and P0C569 are still grouped together, and Q5VKP1 and P06747 are still grouped together. Thus, filtering the multiple alignment does not have an effect on the tree. The bootstrap value, however, have changed. If we had found a difference in the trees made using the unfiltered and filtered multiple alignments, we would have to examine the multiple alignments closely, to see if the unfiltered multiple alignment contains a lot of very poorly aligned regions that might be adding noise to the phylogenetic analysis (if this is true, the tree based on the filtered alignment is likely to be more reliable). "],["a-complete-bioinformatics-workflow-in-r.html", "Chapter 34 A complete bioinformatics workflow in R", " Chapter 34 A complete bioinformatics workflow in R By: Nathan L. Brouwer "],["worked-example-building-a-phylogeny-in-r.html", "Chapter 35 “Worked example: Building a phylogeny in R” 35.1 Introduction 35.2 Software Preliminaires 35.3 Downloading macro-molecular sequences 35.4 Prepping macromolecular sequences 35.5 Aligning sequences 35.6 The shroom family of genes 35.7 Downloading multiple sequences 35.8 Multiple sequence alignment 35.9 Genetic distance. 35.10 Phylognetic trees (finally!)", " Chapter 35 “Worked example: Building a phylogeny in R” 35.1 Introduction Phylogenies play an important role in computational biology and bioinformatics. Phylogenetics itself is an obligatly computational field that only began rapid growth when computational power allowed the many algorithms it relies on to be done rapidly. Phylogeneies of species, genes and proteins are used to address many biological issues, including Patterns of protein evolution Origin and evolution of phenotypic traits Origin and progression of epidemics Origin of evolution of diseases (eg, zooenoses) Prediction of protein function from its sequence … and many more The actual building of a phylogeny is a computationally intensive task; moreover, there are many bioinformatics and computational tasks the precede the construction of a phylogeny: genome sequencing and assembly computational gene prediction and annotation database searching and results screening pairwise sequence alignment data organization and cleaning multiple sequence alignment evaluation and validation of alignment accuracy Once all of these steps have been carried out, the building of a phylogeny involves picking a model of sequence evolution or other description of evolution picking a statistical approach to tree construction evaluationg uncertainty in the final tree In this chapter we will work through many of these steps. In most cases we will pick the easiest or fastest option; in later chapters we will unpack the various options. This chapter is written as an interactive R sessions. You can follow along by opening the .Rmd file of the chapter or typing the appropriate commands into your own script. I assume that all the necessary packages have been installed and they only need to be loaded into R using the library() command. This lesson walks you through and entire workflow for a bioinformatics, including obtaining FASTA sequences cleaning sequences creating alignments creating distance a distance matrix building a phylogenetic tree We’ll examine the Shroom family of genes, which produces Shroom proteins essential for tissue formation in many multicellular eukaryotes, including neural tube formation in vertebrates. We’ll examine shroom in severall very different organism, including humans, mice and sea urchins. There is more than one type of shroom in vertebrates, and we’ll also look at two different Shroom genes: shroom 1 and shroom 2. This lesson draws on skills from previous sections of the book, but is written to act as a independent summary of these activities. There is therefore review of key aspects of R and bioinformatics throughout it. 35.2 Software Preliminaires 35.2.1 Vocab arguement function list named list vector named vector for() loop R console 35.2.2 R functions library() round() plot() mtext() nchar() rentrez::entrez_fetch() combio4all::entrez_fetch_list() combio4aal::print_msa() (Coghlan 2011) Biostrings::AAStringSet() msa::msa() msa::msaConvert() msa::msaPrettyPrint() seqinr::dist.alignment() ape::nj() A few things need to be done to get started with our R session. 35.2.3 Download necessary packages Many R sessions begin by downloading necessary software packages to augment R’s functionality. If you don’t have them already, you’ll need the following packages from CRAN: ape seqinr rentrez devtools The CRAN packages can be loaded with install.packages(). You’ll also need these packages from Bioconductor: msa Biostrings For install packages from Bioconductor, see the chapter at the beginning of this book on this process. Finally, you’ll need this package from GitHub compbio4all To install packages from GitHub you can use the code devtools::install_github(\"brouwern/combio4all\") 35.2.4 Load packages into memory We noew need to load up all our bioinformatics and phylogenetics software into R. This is done with the library() command. To run this code just clock on the sideways green triangel all the way to the right of the code. NOTE: You’ll likely see some red code appear on your screen. No worries, totally normal! eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIGdpdGh1YiBwYWNrYWdlc1xubGlicmFyeShjb21wYmlvNGFsbClcblxuIyBDUkFOIHBhY2thZ2VzXG5saWJyYXJ5KHJlbnRyZXopXG5saWJyYXJ5KHNlcWlucilcbmxpYnJhcnkoYXBlKVxuXG4jIEJpb2NvbmR1Y3RvciBwYWNrYWdlc1xubGlicmFyeShtc2EpXG5saWJyYXJ5KEJpb3N0cmluZ3MpIn0= 35.3 Downloading macro-molecular sequences We’re going to explore some sequences. First we need to download them. To do this we’ll use a function, entrez_fretch(), which accesses the Entrez system of database (ncbi.nlm.nih.gov/search/). This function is from the rentrez package, which stands for “R-Entrez.” We need to tell entrez_fetch() several things db = ... the type of entrez database. id = ... the accession (ID) number of the sequence rettype = ... file type what we want the function to return. Formally, these things are called arguements by R. We’ll use these settings: db = \"protein\" to access the Entrez database of protein sequences rettype = \"fasta\", which is a standard file format for nucleic acid and protein sequences We’ll set id = ... to sequences whose accession numbers are: NP_065910: Human shroom 3 AAF13269: Mouse shroom 3a CAA58534: Human shroom 2 XP_783573: Sea urchin shroom There are two highly conserved regions of shroom 3 1. ASD 1: aa 884 to aa 1062 in hShroom3 1. ASD 2: aa 1671 to aa 1955 in hShroom3 Normally we’d have to download these sequences by hand through pointing and clicking on GeneBank records on the NCBI website. In R we can do it automatically; this might take a second. All the code needed is this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIEh1bWFuIHNocm9vbSAzIChILiBzYXBpZW5zKVxuaFNocm9vbTMgPC0gZW50cmV6X2ZldGNoKGRiID0gXCJwcm90ZWluXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IFwiTlBfMDY1OTEwXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR0eXBlID0gXCJmYXN0YVwiKSJ9 The output is in FASTA format; we’ll use the cat() to do a little formating for us: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjYXQoaFNocm9vbTMpIn0= Note the initial &gt;, then the header line of NP_065910.3 protein Shroom3 [Homo sapiens]. After that is the amino acid sequence. The underlying data also includes the newline character \\n to designate where each line of amino acids stops. We can get the rest of the data by just chaing the id = ... argument: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIE1vdXNlIHNocm9vbSAzYSAoTS4gbXVzY3VsdXMpXG5tU2hyb29tM2EgPC0gZW50cmV6X2ZldGNoKGRiID0gXCJwcm90ZWluXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IFwiQUFGMTMyNjlcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHR5cGUgPSBcImZhc3RhXCIpXG5cbiMgSHVtYW4gc2hyb29tIDIgKEguIHNhcGllbnMpXG5oU2hyb29tMiA8LSBlbnRyZXpfZmV0Y2goZGIgPSBcInByb3RlaW5cIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gXCJDQUE1ODUzNFwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dHlwZSA9IFwiZmFzdGFcIilcblxuXG4jIFNlYS11cmNoaW4gc2hyb29tXG5zU2hyb29tIDwtIGVudHJlel9mZXRjaChkYiA9IFwicHJvdGVpblwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBcIlhQXzc4MzU3M1wiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dHlwZSA9IFwiZmFzdGFcIikifQ== I’m going to check about how long each of these sequences is - each should have an at least slightly different length. If any are identical, I might have repeated an accession name or re-used an object name. The function nchar() counts of the number of characters in an R object. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJuY2hhcihoU2hyb29tMylcbm5jaGFyKG1TaHJvb20zYSlcbm5jaGFyKHNTaHJvb20pXG5uY2hhcihoU2hyb29tMikifQ== 35.4 Prepping macromolecular sequences “90% of data analysis is data cleaning” (-Just about every data analyst and data scientist on twitter) We have our sequences, but the current format isn’t directly usable for us yet because there are several thigns that aren’t sequence information metadata (the header) page formatting information (the newline character) We can remove this non-sequence information using a function I wrote called fasta_cleaner(), which is in the compbio4all package. The function uses regular expressions to remove the info we don’t need. ASIDE: If we run the name of the command with out any quotation marks we can see the code: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJmYXN0YV9jbGVhbmVyIn0= End ASIDE Now use the function to clean our sequences; we won’t worry about what pare = ... is for. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoU2hyb29tMyAgPC0gZmFzdGFfY2xlYW5lcihoU2hyb29tMywgIHBhcnNlID0gRilcbm1TaHJvb20zYSA8LSBmYXN0YV9jbGVhbmVyKG1TaHJvb20zYSwgcGFyc2UgPSBGKVxuaFNocm9vbTIgIDwtIGZhc3RhX2NsZWFuZXIoaFNocm9vbTIsICBwYXJzZSA9IEYpXG5zU2hyb29tICAgPC0gZmFzdGFfY2xlYW5lcihzU2hyb29tLCAgIHBhcnNlID0gRikifQ== Now let’s take a peek at what our sequences look like: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJoU2hyb29tMyJ9 35.5 Aligning sequences We can do a global alignment of one sequence against another using the pairwiseAlignment() function from the Bioconductor package Biostrings (note that capital “B” in Biostrings; most R package names are all lower case, but not this one). Let’s align human versus mouse shroom: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJhbGlnbi5oMy52cy5tM2EgPC0gQmlvc3RyaW5nczo6cGFpcndpc2VBbGlnbm1lbnQoXG4gICAgICAgICAgICAgICAgICBoU2hyb29tMyxcbiAgICAgICAgICAgICAgICAgIG1TaHJvb20zYSkifQ== We can peek at the alignment eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJhbGlnbi5oMy52cy5tM2EifQ== The score tells us how closely they are aligned; higher scores mean the sequences are more similar. Its hard to interpret the number on its own so we can get the percent sequence identity (PID) using the pid() function. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCaW9zdHJpbmdzOjpwaWQoYWxpZ24uaDMudnMubTNhKSJ9 So, shroom3 from humans and shroom3 from mice are ~71% similar (at least using this particular method of alignment, and there are many ways to do this!) What about human shroom 3 and sea-urchin shroom? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJhbGlnbi5oMy52cy5oMiA8LSBCaW9zdHJpbmdzOjpwYWlyd2lzZUFsaWdubWVudChcbiAgICAgICAgICAgICAgICAgIGhTaHJvb20zLFxuICAgICAgICAgICAgICAgICAgaFNocm9vbTIpIn0= First check out the score using score(), which accesses it directly without all the other information. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzY29yZShhbGlnbi5oMy52cy5oMikifQ== Now the percent sequence alignment with pid(): eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJCaW9zdHJpbmdzOjpwaWQoYWxpZ24uaDMudnMuaDIpIn0= So Human shroom 3 and Mouse shroom 3 are 71% identical, but Human shroom 3 and human shroom 2 are only 34% similar? How does it work out evolutionary that a human and mouse gene are more similar than a human and a human gene? What are the evolutionary relationships among these genes within the shroom gene family? 35.6 The shroom family of genes I’ve copied a table from a published paper which has accession numbers for 15 different Shroom genes. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJvb21fdGFibGUgPC0gYyhcIkNBQTc4NzE4XCIgLCBcIlguIGxhZXZpcyBBcHhcIiAsICAgICAgICAgXCJ4U2hyb29tMVwiLFxuICAgICAgICAgICAgXCJOUF81OTc3MTNcIiAsIFwiSC4gc2FwaWVucyBBUFhMMlwiICwgICAgIFwiaFNocm9vbTFcIixcbiAgICAgICAgICAgIFwiQ0FBNTg1MzRcIiAsIFwiSC4gc2FwaWVucyBBUFhMXCIsICAgICAgICBcImhTaHJvb20yXCIsXG4gICAgICAgICAgICBcIkFCRDE5NTE4XCIgLCBcIk0uIG11c2N1bHVzIEFweGxcIiAsICAgICAgXCJtU2hyb29tMlwiLFxuICAgICAgICAgICAgXCJBQUYxMzI2OVwiICwgXCJNLiBtdXNjdWx1cyBTaHJvb21MXCIgLCAgIFwibVNocm9vbTNhXCIsXG4gICAgICAgICAgICBcIkFBRjEzMjcwXCIgLCBcIk0uIG11c2N1bHVzIFNocm9vbVNcIiAsICAgXCJtU2hyb29tM2JcIixcbiAgICAgICAgICAgIFwiTlBfMDY1OTEwXCIsIFwiSC4gc2FwaWVucyBTaHJvb21cIiAsICAgICBcImhTaHJvb20zXCIsXG4gICAgICAgICAgICBcIkFCRDU5MzE5XCIgLCBcIlguIGxhZXZpcyBTaHJvb20tbGlrZVwiLCAgXCJ4U2hyb29tM1wiLFxuICAgICAgICAgICAgXCJOUF8wNjU3NjhcIiwgXCJILiBzYXBpZW5zIEtJQUExMjAyXCIgLCAgIFwiaFNocm9vbTRhXCIsXG4gICAgICAgICAgICBcIkFBSzk1NTc5XCIgLCBcIkguIHNhcGllbnMgU0hBUC1BXCIgLCAgICAgXCJoU2hyb29tNGJcIixcbiAgICAgICAgICAgICNcIkRRNDM1Njg2XCIgLCBcIk0uIG11c2N1bHVzIEtJQUExMjAyXCIgLCAgXCJtU2hyb29tNFwiLFxuICAgICAgICAgICAgXCJBQkE4MTgzNFwiICwgXCJELiBtZWxhbm9nYXN0ZXIgU2hyb29tXCIsIFwiZG1TaHJvb21cIixcbiAgICAgICAgICAgIFwiRUFBMTI1OThcIiAsIFwiQS4gZ2FtYmlhZSBTaHJvb21cIiwgICAgICBcImFnU2hyb29tXCIsXG4gICAgICAgICAgICBcIlhQXzM5MjQyN1wiICwgXCJBLiBtZWxsaWZlcmEgU2hyb29tXCIgLCAgXCJhbVNocm9vbVwiLFxuICAgICAgICAgICAgXCJYUF83ODM1NzNcIiAsIFwiUy4gcHVycHVyYXR1cyBTaHJvb21cIiAsIFwic3BTaHJvb21cIikgI3NlYSB1cmNoaW4ifQ== I’ll do a bit of formatting; you can ignore these details if you want eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIGNvbnZlcnQgdG8gbWF0cml4XG5zaHJvb21fdGFibGVfbWF0cml4IDwtIG1hdHJpeChzaHJvb21fdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnlyb3cgPSBULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5yb3cgPSAxNClcbiMgY29udmVydCB0byBkYXRhZnJhbWVcbnNocm9vbV90YWJsZSA8LSBkYXRhLmZyYW1lKHNocm9vbV90YWJsZV9tYXRyaXgsIFxuICAgICAgICAgICAgICAgICAgICAgc3RyaW5nc0FzRmFjdG9ycyA9IEYpXG5cbiMgbmFtZSBjb2x1bW5zXG5uYW1lcyhzaHJvb21fdGFibGUpIDwtIGMoXCJhY2Nlc3Npb25cIiwgXCJuYW1lLm9yaWdcIixcIm5hbWUubmV3XCIpXG5cbiMgQ3JlYXRlIHNpbXBsaWZpZWQgc3BlY2llcyBuYW1lc1xuc2hyb29tX3RhYmxlJHNwcCA8LSBcIkhvbW9cIlxuc2hyb29tX3RhYmxlJHNwcFtncmVwKFwibGFldmlzXCIsc2hyb29tX3RhYmxlJG5hbWUub3JpZyldIDwtIFwiWGVub3B1c1wiXG5zaHJvb21fdGFibGUkc3BwW2dyZXAoXCJtdXNjdWx1c1wiLHNocm9vbV90YWJsZSRuYW1lLm9yaWcpXSA8LSBcIk11c1wiXG5zaHJvb21fdGFibGUkc3BwW2dyZXAoXCJtZWxhbm9nYXN0ZXJcIixzaHJvb21fdGFibGUkbmFtZS5vcmlnKV0gPC0gXCJEcm9zb3BoaWxhXCJcbnNocm9vbV90YWJsZSRzcHBbZ3JlcChcImdhbWJpYWVcIixzaHJvb21fdGFibGUkbmFtZS5vcmlnKV0gPC0gXCJtb3NxdWl0b1wiXG5zaHJvb21fdGFibGUkc3BwW2dyZXAoXCJtZWxsaWZlcmFcIixzaHJvb21fdGFibGUkbmFtZS5vcmlnKV0gPC0gXCJiZWVcIlxuc2hyb29tX3RhYmxlJHNwcFtncmVwKFwicHVycHVyYXR1c1wiLHNocm9vbV90YWJsZSRuYW1lLm9yaWcpXSA8LSBcInNlYSB1cmNoaW5cIiJ9 Take a look: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJvb21fdGFibGUifQ== 35.7 Downloading multiple sequences Instead of getting one sequence at a time we can download several by accessing the “accession” column from the table eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJvb21fdGFibGUkYWNjZXNzaW9uIn0= We can give this whole set of accessions to entrez_fetch(): eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJvb21zIDwtIGVudHJlel9mZXRjaChkYiA9IFwicHJvdGVpblwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBzaHJvb21fdGFibGUkYWNjZXNzaW9uLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dHlwZSA9IFwiZmFzdGFcIikifQ== We can look at what we got here with cat() (I won’t display this because it is very long!) eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjYXQoc2hyb29tcykifQ== The current format of these data is a single, long set of data. This is a standard way to store, share and transmit FASTA files, but in R we’ll need a slightly different format. We’ll download all of the sequences again, this time using a function from compbio4all called entrez_fetch_list() which is a wrapper function I wrote to put the output of entrez_fetch() into an R data format called a list. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJvb21zX2xpc3QgPC0gZW50cmV6X2ZldGNoX2xpc3QoZGIgPSBcInByb3RlaW5cIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gc2hyb29tX3RhYmxlJGFjY2Vzc2lvbiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHR5cGUgPSBcImZhc3RhXCIpIn0= Now we have a list which as 14 elements, one for each sequence in our table. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsZW5ndGgoc2hyb29tc19saXN0KSJ9 We now need to clean up each one fo these sequences. We can do that using a simple for() loop: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJmb3IoaSBpbiAxOmxlbmd0aChzaHJvb21zX2xpc3QpKXtcbiAgc2hyb29tc19saXN0W1tpXV0gPC0gZmFzdGFfY2xlYW5lcihzaHJvb21zX2xpc3RbW2ldXSwgcGFyc2UgPSBGKVxufSJ9 Second to last step: we need to take each one of our sequences from our list and put it into a vector, in particular a named vector eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIG1ha2UgYSB2ZWN0b3IgdG8gc3RvcmUgb3V0cHV0XG5zaHJvb21zX3ZlY3RvciA8LSByZXAoTkEsIGxlbmd0aChzaHJvb21zX2xpc3QpKVxuXG4jIHJ1biB0aGUgbG9vcFxuZm9yKGkgaW4gMTpsZW5ndGgoc2hyb29tc192ZWN0b3IpKXtcbiAgc2hyb29tc192ZWN0b3JbaV0gPC0gc2hyb29tc19saXN0W1tpXV1cbn1cblxuIyBuYW1lIHRoZSB2ZWN0b3Jcbm5hbWVzKHNocm9vbXNfdmVjdG9yKSA8LSBuYW1lcyhzaHJvb21zX2xpc3QpIn0= Now the final step: we need to convert our named vector to a string set using Biostrings::AAStringSet(). Note the _ss tag at the end of the object we’re assigning the output to, which designates this as a string set. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJvb21zX3ZlY3Rvcl9zcyA8LSBCaW9zdHJpbmdzOjpBQVN0cmluZ1NldChzaHJvb21zX3ZlY3RvcikifQ== 35.8 Multiple sequence alignment We must align all of the sequences we downloaded and use that alignment to build a phylogenetic tree. This will tell us how the different genes, both within and between species, are likely to be related. 35.8.1 Building an Multiple Sequence Alignment (MSA) We’ll use the software msa, which implements the ClustalW multiple sequence alignment algorithm. Normally we’d have to download the ClustalW program and either point-and-click our way through it or use the command line*, but these folks wrote up the algorithm in R so we can do this with a line of R code. This will take a second or two. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJvb21zX2FsaWduIDwtIG1zYShzaHJvb21zX3ZlY3Rvcl9zcyxcbiAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwiQ2x1c3RhbFdcIikifQ== 35.8.2 Viewing an MSA Once we build an MSA we need to visualize it. 35.8.2.1 Viewing an MSA in R We can look at the output from msa(), but its not very helpful eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJvb21zX2FsaWduIn0= A function called print_msa() (Coghlan 2011) which I’ve put intocombio4all can give us more informative output by printing out the actual alignment into the R console. To use print_msa() We need to make a few minor tweaks though first. These are behind the scenes changes so don’t worry about the details right now. We’ll change the name to shrooms_align_seqinr to indcate that one of our changes is putting this into a format defined by the bioinformatics package seqinr. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjbGFzcyhzaHJvb21zX2FsaWduKSA8LSBcIkFBTXVsdGlwbGVBbGlnbm1lbnRcIlxuc2hyb29tc19hbGlnbl9zZXFpbnIgPC0gbXNhQ29udmVydChzaHJvb21zX2FsaWduLCB0eXBlID0gXCJzZXFpbnI6OmFsaWdubWVudFwiKSJ9 I won’t display the output from shrooms_align_seqinr because its very long; we have 14 shroom genes, and shroom happens to be a rather long gene. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwcmludF9tc2EoYWxpZ25tZW50ID0gc2hyb29tc19hbGlnbl9zZXFpbnIsIFxuICAgICAgICAgIGNodW5rc2l6ZSA9IDYwKSJ9 35.8.2.2 Displaying an MSA as an R plot I’m going to just show about 100 amino acids near the end of the alignment, where there is the most overlap across all of the sequences. This is set with the start = ... and end = ... arguments. Note that we’re using the shrooms_align object. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJnZ21zYTo6Z2dtc2Eoc2hyb29tc19hbGlnbiwgICAjIHNocm9vbXNfYWxpZ24sIE5PVCBzaHJvb21zX2FsaWduX3NlcWluclxuICAgICAgc3RhcnQgPSAyMDAwLCBcbiAgICAgIGVuZCA9IDIxMDApICJ9 35.8.2.3 Saving an MSA as PDF We can take a look at the alignment in PDF format if we want. I this case I’m going to just show about 100 amino acids near the end of the alignment, where there is the most overlap across all of the sequences. This is set with the y = c(...) argument. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJtc2FQcmV0dHlQcmludChzaHJvb21zX2FsaWduLCAgICAgICAgICAgICAjIGFsaWdubWVudFxuICAgICAgICAgICAgICAgZmlsZSA9IFwic2hyb29tX21zYS5wZGZcIiwgICAjIGZpbGUgbmFtZVxuICAgICAgICAgICAgICAgeT1jKDIwMDAsIDIxMDApLCAgICAgICAgICAgIyByYW5nZVxuICAgICAgICAgICAgICAgYXNrRm9yT3ZlcndyaXRlPUZBTFNFKSJ9 You can see where R is saving thigns by running getwd() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJnZXR3ZCgpIn0= On a Mac you can usually find the file by searching in Finder for the file name, which I set to be “shroom_msa.pdf” using the file = ... arguement above. 35.9 Genetic distance. Next need to first get an estimate of how similar each sequences is. The more amino acids that are identical to each other, the more similar. Instead of similarity, we usually work in terms of difference or genetic distance (a.k.a. evolutionary distance). This is done with the dist.alignment() function. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJvb21zX2Rpc3QgPC0gc2VxaW5yOjpkaXN0LmFsaWdubWVudChzaHJvb21zX2FsaWduX3NlcWluciwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXggPSBcImlkZW50aXR5XCIpIn0= We’ve made a matrix using dist.alignment(); let’s round it off so its easier to look at using the round() function. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJvb21zX2Rpc3Rfcm91bmRlZCA8LSByb3VuZChzaHJvb21zX2Rpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHMgPSAzKSJ9 Now let’s look at it eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzaHJvb21zX2Rpc3Rfcm91bmRlZCJ9 35.10 Phylognetic trees (finally!) We got our sequence, built multiple sequence alignment, and calcualted the genetic distance between sequences. Now we are - finally - ready to build a phylogenetic tree. First, we let R figure out the structure of the tree. There are MANY ways to build phylogenetic trees. We’ll use a common one used for exploring sequences called neighbor joining algorithm via the function nj(). Neighbor joining uses genetic distances to cluster sequences into clades. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlIDwtIG5qKHNocm9vbXNfZGlzdCkifQ== 35.10.1 Plotting phylogenetic trees Now we’ll make a quick plot of our tree using plot() (and add a little label using a function called mtext()). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHBsb3QgdHJlZVxucGxvdC5waHlsbyAodHJlZSwgbWFpbj1cIlBoeWxvZ2VuZXRpYyBUcmVlXCIsIFxuICAgICAgICAgICAgdHlwZSA9IFwidW5yb290ZWRcIiwgXG4gICAgICAgICAgICB1c2UuZWRnZS5sZW5ndGggPSBGKVxuXG4jIGFkZCBsYWJlbFxubXRleHQodGV4dCA9IFwiU2hyb29tIGZhbWlseSBnZW5lIHRyZWUgLSB1bnJvb3RlZCwgbm8gYnJhbmNoIGxlbmd0aHNcIikifQ== This is an **unrooted tree*. For the sake of plotting we’ve also ignored the evolutionary distance between the sequences. To make a rooted tree we remove type = \"unrooted. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHBsb3QgdHJlZVxucGxvdC5waHlsbyAodHJlZSwgbWFpbj1cIlBoeWxvZ2VuZXRpYyBUcmVlXCIsIFxuICAgICAgICAgICAgdXNlLmVkZ2UubGVuZ3RoID0gRilcblxuIyBhZGQgbGFiZWxcbm10ZXh0KHRleHQgPSBcIlNocm9vbSBmYW1pbHkgZ2VuZSB0cmVlIC0gcm9vdGVkLCBubyBicmFuY2ggbGVudGhzXCIpIn0= We can include information about branch length by setting use.edge.length = ... to T. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHBsb3QgdHJlZVxucGxvdC5waHlsbyAodHJlZSwgbWFpbj1cIlBoeWxvZ2VuZXRpYyBUcmVlXCIsIFxuICAgICAgICAgICAgdXNlLmVkZ2UubGVuZ3RoID0gVClcblxuIyBhZGQgbGFiZWxcbm10ZXh0KHRleHQgPSBcIlNocm9vbSBmYW1pbHkgZ2VuZSB0cmVlIC0gcm9vdGVkLCB3aXRoIGJyYW5jaCBsZW50aHNcIikifQ== Some of the branches are now very short, but most are very long, indicating that these genes have been evolvin independently for many millions of years. Let’s make a fancier plot. Don’t worry about all the steps; I’ve added some more code to add some annotations on the right-hand side to help us see what’s going on. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KHRyZWUsIG1haW49XCJQaHlsb2dlbmV0aWMgVHJlZVwiKVxubXRleHQodGV4dCA9IFwiU2hyb29tIGZhbWlseSBnZW5lIHRyZWVcIilcblxueCA8LSAwLjU1MVxueDIgPC0gMC42XG5cbiMgbGFiZWwgU2hybSAzXG5zZWdtZW50cyh4MCA9IHgsIHkwID0gMSwgXG4gICAgICAgICB4MSA9IHgsIHkxID0gNCxcbiAgICAgICAgIGx3ZD0yKVxudGV4dCh4ID0geCoxLjAxLCB5ID0gMi41LCBcIlNocm0gM1wiLGFkaiA9IDApXG5cbnNlZ21lbnRzKHgwID0geCwgeTAgPSA1LCBcbiAgICAgICAgIHgxID0geCwgeTEgPSA2LFxuICAgICAgICAgbHdkPTIpXG50ZXh0KHggPSB4KjEuMDEsIHkgPSA1LjUsIFwiU2hybSAyXCIsYWRqID0gMClcblxuc2VnbWVudHMoeDAgPSB4LCB5MCA9IDcsIFxuICAgICAgICAgeDEgPSB4LCB5MSA9IDksXG4gICAgICAgICBsd2Q9MilcbnRleHQoeCA9IHgqMS4wMSwgeSA9IDgsIFwiU2hybSAxXCIsYWRqID0gMClcblxuc2VnbWVudHMoeDAgPSB4LCB5MCA9IDEwLCBcbiAgICAgICAgIHgxID0geCwgeTEgPSAxMyxcbiAgICAgICAgIGx3ZD0yKVxudGV4dCh4ID0geCoxLjAxLCB5ID0gMTIsIFwiU2hybSA/XCIsYWRqID0gMClcblxuXG5zZWdtZW50cyh4MCA9IHgsIHkwID0gMTQsIFxuICAgICAgICAgeDEgPSB4LCB5MSA9IDE1LFxuICAgICAgICAgbHdkPTIpXG50ZXh0KHggPSB4KjEuMDEsIHkgPSAxNC41LCBcIlNocm0gNFwiLGFkaiA9IDApXG5cblxuc2VnbWVudHMoeDAgPSB4MiwgeTAgPSAxLCBcbiAgICAgICAgIHgxID0geDIsIHkxID0gNixcbiAgICAgICAgIGx3ZD0yKVxuXG5zZWdtZW50cyh4MCA9IHgyLCB5MCA9IDcsIFxuICAgICAgICAgeDEgPSB4MiwgeTEgPSA5LFxuICAgICAgICAgbHdkPTIpXG5cbnNlZ21lbnRzKHgwID0geDIsIHkwID0gMTAsIFxuICAgICAgICAgeDEgPSB4MiwgeTEgPSAxNSxcbiAgICAgICAgIGx3ZD0yKSJ9 "],["appendix-01-getting-access-to-r.html", "Appendix 01: Getting access to R 35.11 Getting Started With R and RStudio", " Appendix 01: Getting access to R 35.11 Getting Started With R and RStudio R is a piece of software that does calculations and makes graphs. RStudio is a GUI (graphical user interface) that acts as a front-end to R Your can use R directly, but most people use a GUI of some kind RStudio has become the most popular GUI The following instructions will lead you click by click through downloading R and RStudio and starting an initial session. If you have trouble with downloading either program go to YouTube and search for something like “Downloading R” or “Installing RStudio” and you should be able to find something helpful, such as “How to Download R for Windows”. 35.11.1 RStudio Cloud TODO: Add RStudio cloud 35.11.2 Getting R onto your own computer To get R on to your computer first go to the CRAN website at https://cran.r-project.org/ (CRAN stands for “comprehensive R Archive Network”). At the top of the screen are three bullet points; select the appropriate one (or click the link below) Download R for Linux Download R for (Mac) OS X Download R for Windows Each page is formatted slightly differently. For a current Mac, click on the top link, which as of 8/16/2018 was “R-3.5.1.pkg” or click this link. If you have an older Mac you might have to scroll down to find your operating system under “Binaries for legacy OS X systems.” For PC select “base” or click this link. When its downloaded, run the installer and accept the defaults. 35.11.3 Getting RStudio onto your computer RStudio is an R interface developed by a company of the same name. RStudio has a number of commercial products, but much of their portfolio is freeware. You can download RStudio from their website www.rstudio.com/ . The download page (www.rstudio.com/products/rstudio/download/) is a bit busy because it shows all of their commercial products; the free version is on the far left side of the table of products. Click on the big green DOWNLOAD button under the column on the left that says “RStudio Desktop Open Source License” (or click on this link ). This will scroll you down to a list of downloads titled “Installers for Supported Platforms.” Windows users can select the top option RStudio 1.1.456 - Windows Vista/7/8/10 and Mac the second option RStudio 1.1.456 - Mac OS X 10.6+ (64-bit). (Versions names are current of 8/16/2018). Run the installer after it downloads and accept the default. RStudio will automatically link up with the most current version of R you have on your computer. Find the RStudio icon on your desktop or search for “RStudio” from your task bar and you’ll be read to go. 35.11.4 Keep R and RStudio current Both R and RStudio undergo regular updates and you will occasionally have to re-download and install one or both of them. In practice I probably do this about every 6 months. "],["getting-started-with-r-itself-or-not.html", "Getting started with R itself (or not) Vocabulary R commands 35.12 Help! 35.13 Other features of RStudio 35.14 Practice (OPTIONAL) 35.15 Repliminaries 35.16 Concepts 35.17 Functions 35.18 Introduction 35.19 Number of rooted trees 35.20 Number of rooted trees in R 35.21 Bilography 35.22 UPGMA the hard way 35.23 Introudction to UPGMA 35.24 Preliminaries 35.25 Data matrix 35.26 What does this distance matrix represent? 35.27 From linear distances to “tree distances” 35.28 The UPGMA algorithm 35.29 Calculate 2D representation 35.30 Algorithm - round 1 35.31 Algorithm - next round 35.32 Next iteration 35.33 Finish up 35.34 Finalizing branch lengths", " Getting started with R itself (or not) Vocabulary console script editor / source viewer interactive programming scripts / script files .R files text files / plain text files command execution / execute a command from script editor comments / code comments commenting out / commenting out code stackoverflow.com the rstats hashtag R commands c(…) mean(…) sd(…) ? read.csv(…) This is a walk-through of a very basic R session. It assumes you have successfully installed R and RStudio onto your computer, and nothing else. Most people who use R do not actually use the program itself - they use a GUI (graphical user interface) “front end” that make R a bit easier to use. However, you will probably run into the icon for the underlying R program on your desktop or elsewhere on your computer. It usually looks like this: ADD IMAGE HERE The long string of numbers have to do with the version and whether is 32 or 64 bit (not important for what we do). If you are curious you can open it up and take a look - it actually looks a lot like RStudio, where we will do all our work (or rather, RStudio looks like R). Sometimes when people are getting started with R they will accidentally open R instead of RStudio; if things don’t seem to look or be working the way you think they should, you might be in R, not RStudio 35.11.4.1 R’s console as a scientific calculator You can interact with R’s console similar to a scientific calculator. For example, you can use parentheses to set up mathematical statements like eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiI1KigxKzEpIn0= Note however that you have to be explicit about multiplication. If you try the following it won’t work. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiI1KDErMSkifQ== R also has built-in functions that work similar to what you might have used in Excel. For example, in Excel you can calculate the average of a set of numbers by typing “=average(1,2,3)” into a cell. R can do the same thing except The command is “mean” You don’t start with “=” You have to package up the numbers like what is shown below using “c(…)” eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJtZWFuKGMoMSwyLDMpKSJ9 Where “c(…)” packages up the numbers the way the mean() function wants to see them. If you just do the following R will give you an answer, but its the wrong one eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJtZWFuKDEsMiwzKSJ9 This is a common issue with R – and many programs, really – it won’t always tell you when somethind didn’t go as planned. This is because it doesn’t know something didn’t go as planned; you have to learn the rules R plays by. 35.11.4.2 Practice: math in the console See if you can reproduce the following results Division eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIxMC8zIn0= The standard deviation eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZChjKDUsMTAsMTUpKSAjIG5vdGUgdGhlIHVzZSBvZiBcImMoLi4uKVwiIn0= 35.11.4.3 The script editor While you can interact with R directly within the console, the standard way to work in R is to write what are known as scripts. These are computer code instructions written to R in a script file. These are save with the extension .R but area really just a form of plain text file. To work with scripts, what you do is type commands in the script editor, then tell R to excute the command. This can be done several ways. First, you tell RStudio the line of code you want to run by either * Placing the cursor at the end a line of code, OR * Clicking and dragging over the code you want to run in order highlight it. Second, you tell RStudio to run the code by * Clicking the “Run” icon in the upper right hand side of the script editor (a grey box with a green error emerging from it) * pressing the control key (“ctrl)” and then then enter key on the keyboard The code you’ve chosen to run will be sent by RStudio from the script editor over to the console. The console will show you both the code and then the output. You can run several lines of code if you want; the console will run a line, print the output, and then run the next line. First I’ll use the command mean(), and then the command sd() for the standard deviation: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJtZWFuKGMoMSwyLDMpKVxuc2QoYygxLDIsMykpIn0= 35.11.4.4 Comments One of the reasons we use script files is that we can combine R code with comments that tell us what the R code is doing. Comments are preceded by the hashtag symbol #. Frequently we’ll write code like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjVGhlIG1lYW4gb2YgMyBudW1iZXJzXG5tZWFuKGMoMSwyLDMpKSJ9 If you highlight all of this code (including the comment) and then click on “run”, you’ll see that RStudio sends all of the code over console. ## [1] 2 Comments can also be placed at the end of a line of code eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJtZWFuKGMoMSwyLDMpKSAjTm90ZSAgdGhlIHVzZSBvZiBjKC4uLikifQ== Sometimes we write code and then don’t want R to run it. We can prevent R from executing the code even if its sent to the console by putting a “#” infront of the code. If I run this code, I will get just the mean but not the sd. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJtZWFuKGMoMSwyLDMpKVxuI3NkKGMoMSwyLDMpKSJ9 Doing this is called commenting out a line of code. 35.12 Help! There are many resource for figuring out R and RStudio, including R’s built in “help” function Q&amp;A websites like stackoverflow.com twitter, using the hashtag #rstats blogs online books and course materials 35.12.1 Getting “help” from R If you are using a function in R you can get info about how it works like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiI/bWVhbiJ9 In RStudio the help screen should appear, probably above your console. If you start reading this help file, though, you don’t have to go far until you start seeing lots of R lingo, like “S3 method”,“na.rm”, “vectors”. Unfortunately, the R help files are usually not written for beginners, and reading help files is a skill you have to acquire. For example, when we load data into R in subsequent lessons we will use a function called “read.csv” Access the help file by typing “?read.csv” into the console and pressing enter. Surprisingly, the function that R give you the help file isn’t what you asked for, but is read.table(). This is a related function to read.csv, but when you’re a beginner thing like this can really throw you off. Kieran Healy as produced a great cheatsheet for reading R’s help pages as part of his forthcoming book. It should be available online at http://socviz.co/appendix.html#a-little-more-about-r 35.12.2 Getting help from the internet The best way to get help for any topic is to just do an internet search like this: “R read.csv”. Usually the first thing on the results list will be the R help file, but the second or third will be a blog post or something else where a usually helpful person has discussed how that function works. Sometimes for very basic R commands like this might not always be productive but its always work a try. For but things related to stats, plotting, and programming there is frequently lots of information. Also try searching YouTube. 35.12.3 Getting help from online forums Often when you do an internet search for an R topic you’ll see results from the website www.stackoverflow.com, or maybe www.crossvalidated.com if its a statistics topic. These are excellent resources and many questions that you may have already have answers on them. Stackoverflow has an internal search function and also suggests potentially relevant posts. Before posting to one of these sites yourself, however, do some research; there is a particular type and format of question that is most likely to get a useful response. Sadly, people new to the site often get “flamed” by impatient pros. 35.12.4 Getting help from twitter Twitter is a surprisingly good place to get information or to find other people knew to R. Its often most useful to ask people for learning resources or general reference, but you can also post direct questions and see if anyone responds, though usually its more advanced users who engage in twitter-based code discussion. A standard tweet might be “Hey #rstats twitter, am knew to #rstats and really stuck on some of the basics. Any suggestions for good resources for someone starting from scratch?” 35.13 Other features of RStudio 35.13.1 Ajusting pane the layout You can adjust the location of each of RStudio 4 window panes, as well as their size. To set the pane layout go to 1. ”Tools” on the top menu 1. ”Global options” 1. “Pane Layout” Use the drop-down menus to set things up. I recommend 1. Lower left: “Console”\" 1. Top right: “Source” 1. Top left: “Plot, Packages, Help Viewer” 1. This will leave the “Environment…” panel in the lower right. 35.13.2 Adjusting size of windows You can clicked on the edge of a pane and adjust its size. For most R work we want the console to be big. For beginners, the “Environment, history, files” panel can be made really small. 35.14 Practice (OPTIONAL) Practice the following operations. Type the directly into the console and execute them. Also write them in a script in the script editor and run them. Square roots eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzcXJ0KDQyKSJ9 The date Some functions in R can be executed within nothing in the parentheses. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYXRlKCkifQ== Exponents The ^ is used for exponents eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiI0Ml4yIn0= A series of numbers A colon between two numbers creates a series of numbers. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIxOjQyIn0= logs The default for the log() function is the natural log. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsb2coNDIpIn0= log10() gives the base-10 log. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsb2cxMCg0MikifQ== exp() raises e to a power eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJleHAoMy43Mzc2NykifQ== Multiple commands can be nested eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzcXJ0KDQyKV4yXG5sb2coc3FydCg0MileMilcbmV4cChsb2coc3FydCg0MileMikpIn0= output: html_document editor_options: chunk_output_type: console — # Calculating the number of possible phylogenetic trees eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGNvbXBiaW80YWxsKSJ9 35.15 Repliminaries 35.16 Concepts 35.16.0.1 Biology Concepts / Vocab toplogy rotation Number of possible phylogenetics trees 35.17 Functions factorial 35.18 Introduction Phylogenetics is one of the original fields of computational biology. This is because as the number of taxa that need to be organized on a tree increases, the number of unique phylogenetic trees describing possible relationships among those taxa increases rapidly. The following refers to bifurcating tree which always branch into two branches at each node. There are the type of branches built for phylogenies. 35.19 Number of rooted trees The number of possible rooted phylogenetic trees is calculated using the equation below, where n is the number of taxa: In text, the equation looks like this: (2n-3)!/(2^(n-2))(n-2)! Written in a math book it would look like this: \\(\\frac{(2*n-3)!}{2^{n-2} * (n-2)!}\\) This equation is occasionally mis-printed (as I did in the part of this original assignment) so its worth being explicit: The numerator is: (2n-3)!, where “!” is factorial The denominator is: (2^n-2)*(n-2)!; the factorial is evaluated first. So, for n = 3 taxa (2n-3)!/(2^(n-2))(n-2)! = (2x3-3)!/(2^(3-2))x(3-2)! = (6 -3)!/(2^(1))x(1)! = (3)!/(2)x(1)! = (1 x 2 x 3)/(2 x 1) = 6 / 2 = 3 One of our first tasks will be to translate this equation into R code. 35.20 Number of rooted trees in R In R we take factorials using the factorial() function eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJmYWN0b3JpYWwoMylcbjMqMioxXG5cbmZhY3RvcmlhbCg0KVxuNCozKjIqMSJ9 We can re-write our text equation above as: factorial(2n-3)/(2^(n-2))*(factorial(n-2)) In this would be eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJuPC0zXG5cbmZhY3RvcmlhbCgyKm4tMykvKCgyXihuLTIpKSpmYWN0b3JpYWwobi0yKSkifQ== All of the parentheses make this a bit nutty. Let me write this out as a separate numerator and denominator eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjbnVtZXJhdG9yXG5udW1lcmF0b3IgICA8LSBmYWN0b3JpYWwoMipuLTMpXG5cbiNkZW5vbWluYXRvclxuZGVub21pbmF0b3IgPC0gMl4obi0yKSpmYWN0b3JpYWwobi0yKVxuXG4jZGl2aXNpb25cbm51bWVyYXRvci9kZW5vbWluYXRvciJ9 35.20.1 Unique topologies versus rotations Note that this applies to all tree typologies. For n = 3 species the three typologies are ((Human, Chimp), Gorilla) ((Human, Gorilla), Chimp) ((Chimp, Gorilla), Human) In this discussion Since we are referring to evolutionary unique typologies. Therefore order within a clade does not matter. Therefore, these two are identical typologies and don’t get counted among the three unique typologies the equation is telling use exist:. ((Human, Chimp), Gorilla) ((Chimp, Human), Gorilla) 35.21 Bilography This topic is discussed on page 187-189 of Baum &amp; Smith Tree Thinking. They discuss it in the concept of maximum parsimony estimation of phylogenetic trees. 35.22 UPGMA the hard way eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGNvbXBiaW80YWxsKSJ9 35.23 Introudction to UPGMA UPGMA is a basic clustering algorithm which can be used for building phylognetic tree from distance matrices. It still has some applications because it is fast, but it has mostly beenn replaced by Neighbor Joining and Minimum Evolution methods. UPGMA is still useful for teaching the basic steps involved in data clustering and building trees. UPGMA is a particular variant of a general class of algorithms. Another varient is WPGMA. 35.24 Preliminaries 35.24.1 R Libraries The phangorn package contains the functions upgma() wpgma() The ape package has the function nj() for neighbor joinging, which is useful for comparison to UPGMA. 35.24.1.1 Phylogenetic libraries eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjaW5zdGFsbC5wYWNrYWdlcyhcImFwZVwiKVxuI2luc3RhbGwucGFja2FnZXMoXCJwaGFuZ29yblwiKVxubGlicmFyeShhcGUpXG5saWJyYXJ5KHBoYW5nb3JuKSJ9 35.24.1.2 Plotting libraries eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjaW5zdGFsbC5wYWNrYWdlcyhcInBsb3RyaXhcIilcbmxpYnJhcnkocGxvdHJpeCkifQ== 35.24.2 Custom function we’ll use To help us understand clustering and UPGMA I’ve written a cusome function. This function, plot_dist_as_nmds(), will make a 2-dimensional (2D) representation of the distance matrices we’ll be working with. This is only an approximation and will occassionally result in distorions. What this function does is take a distance matix and attempt to plot the data as if they were in 2-dimensional space. If we were giving it the distance between building on campus it would plot a reasonable map. Since we’ll be plotting data that isn’t physical distance but genetic distances this will not be a real evolutionary tree. The intent here is to help you build your intuition about what a distane matrix is. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIyBMb2FkIEFMTCBvZiB0aGlzIGNvZGVcblxuIyBUT0RPOiB5bGltIGFuZCB4bGltIGFyZSBjdXJyZW50IGhhcmQgY29kZWRcblxucGxvdF9kaXN0X2FzX25tZHMgPC0gZnVuY3Rpb24obWF0LCB4LmxpbSA9IGMoLTIwLDIwKSwgeS5saW0gPSBjKC0yMCwyMCkpe1xuICBtYXRubzAgPC0gbWF0XG4gIFxubWF0bm8wW2lzLm5hKG1hdG5vMCldIDwtIDBcblxuXG5kMiAgPC0gc3RhdHM6OmNtZHNjYWxlKG1hdG5vMCwgYWRkID1UKVxueCA8LSBkMiRwb2ludHNbLDFdXG55IDwtIGQyJHBvaW50c1ssMl1cbnBsb3QoeCx5LCBtYWluID0gXCJBUFBST1hJTUFURSAyRCBkaXN0YW5jZXNcIixcbiAgICAgeGxpbSA9IHgubGltLCBcbiAgICAgeWxpbSA9IHkubGltKVxudGV4dCh4LCB5LCBsYWJlbHMgPSByb3cubmFtZXMoZDIkcG9pbnRzKSwgY2V4PTMpXG5cbnJldHVybihkMilcblxufSJ9 35.25 Data matrix We’ll use data from a study that built a tree using rRNA from bacteria. The data and a worked example are available at https://en.wikipedia.org/wiki/UPGMA#First_step This particular matrix is set up as the number of bases that are different between each sequence. (In the next unit we’ll discuss how they didn’t use just a simple count of the differences). 35.25.1 Building the matrix One way to make the data is to use the rbind() individual vectors as rows eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIFRoZSBkYXRhXG4jICAgICAgYSAgIGIgICBjICAgZCAgIGVcbmEgPC0gYygwLFx0IDE3LCAyMSwgMzEsIDIzKVxuYiA8LSBjKDE3LCAwLFx0IDMwLCAzNCwgMjEpXG5jXHQ8LSBjKDIxLCAzMCwgMCwgIDI4LCAzOSlcbmRcdDwtIGMoMzEsIDM0LCAyOCxcdDAsIDQzKVxuZVx0PC0gYygyMywgMjEsIDM5LCA0MyxcdDApXG5cbiMgQmluZCBpbnRvIGEgbWF0cml4XG5kbWF0MSA8LSByYmluZChhLGIsYyxkLGUpIn0= rbind() takes each vector (a through e) and glues them together into a matrix eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpcyhkbWF0MSkifQ== As a challenge, can you take these data and make these data into a matrix using the matrix() function? The finished matrix looks like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkbWF0MSJ9 Add names using colnames() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjb2xuYW1lcyhkbWF0MSkgPC0gYyhcImFcIixcImJcIixcImNcIixcImRcIixcImVcIikifQ== The matrix is symmetrical. Challenge questions: How would we interpret the diagonal? Why is it not 1? Why is this matrix symmetrical? Its easier if you make redundant elements NA because we don’t need them. We can access the diagonal of the matrix directly and set it to NA using the diag() function eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkaWFnKGRtYXQxKSA8LSBOQSJ9 Now the matrix looks like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkbWF0MSJ9 We only need the lower left-hand part of the matrix. We can set the upper right-hand part of the matrix to NA like this: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkbWF0MVt1cHBlci50cmkoZG1hdDEpXSA8LSBOQSJ9 (don’t worry about exactly what’s going on here) Matrix now looks like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkbWF0MSJ9 35.26 What does this distance matrix represent? 35.26.1 Genetic distances conceptualized as pairwise linear distances Each element of the matrix is a pairwise distance. These distances were computed using pairwise alignments of each sequence. In this case, it is the number of nucleotides that are different between two sequences. As is standard, these alginments ignored any indels. There are 5 sequences, and if each is compared against the other then there are 10 total distances. Mathematically these are called Hamming distances. Each distance is the distance between two species, and it can be conceptualized on its own as a linear distance. You could visualize a single pairwise distance like a linear distance like this: (note: you don’t need to understand all of this code, but you do need to understand how it relates to the distance amtrix) eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwYXIobWZyb3cgPSBjKDEsMSkpXG5wbG90KDAsIDAsIHhsaW0gPSBjKDAsbWF4KGRtYXQxLG5hLnJtID0gVCkpLCBcbiAgICAgeWxpbSA9IGMoMCwxMiksIFxuICAgICB0eXBlID0gXCJsXCIsXG4gICAgIHhsYWIgPSBjKFwiRGlzdGFuY2UgKG51bWJlciBvZiBtdXRhdGlvbnMpXCIpLFxuICAgICB5bGFiID0gXCJQYWlyd2lzZSBjb21wYXJpc29uXCIsXG4gICAgIG1haW4gPSBcIkxpbmVhciBkaXN0YW5jZSBhIHZzLiBiXCIpXG5wb2ludHMoMCwgMSwgcGNoID0gXCJhXCIpXG5wb2ludHMoZG1hdDFbMiwxXSwgMSwgcGNoID0gXCJiXCIpXG5zZWdtZW50cyh4MCA9IDAsIHkwID0gMSwgXG4gICAgICAgICB4MSA9IGRtYXQxWzIsMV0seTEgPSAxKVxuYWJsaW5lKGggPSAxLjUsIGNvbCA9IDIpIn0= We can look at all of the distance Note that each line is independent and cannot be compared (the y axis has no meaning). This is NOT a 2D map! eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIFRoaXMgY29kZSBpcyBjb21wbGV4IGFuZCB0aGUgZ29hbCBpcyB0byBhc3Nlc3MgdGhlIHBsb3QsIG5vdCB1bmRlcnN0YW5kIHRoZSBjb2RlXG5wbG90KDAsIDAsIHhsaW0gPSBjKDAsbWF4KGRtYXQxLG5hLnJtID0gVCkpLCBcbiAgICAgeWxpbSA9IGMoMCwxMiksIFxuICAgICB0eXBlID0gXCJsXCIsXG4gICAgIHhsYWIgPSBjKFwiRGlzdGFuY2UgKG51bWJlciBvZiBtdXRhdGlvbnMpXCIpLFxuICAgICB5bGFiID0gXCJQYWlyd2lzZSBjb21wYXJpc29uXCIpXG5wYWlyLmsgPC0wXG5mb3IoaSBpbiAxOm5yb3coZG1hdDEpKXtcbiAgZm9yKGogaW4gMTpucm93KGRtYXQxKSl7XG5cbmRpc3QuaWogPC0gZG1hdDFbaSxqXSBcbmlmKGlzLm5hKGRpc3QuaWopID09IEZBTFNFKXtcbiAgcGFpci5rIDwtIHBhaXIuaysxICAgIFxuXG4gICAgICAgXG5zcHAuaSA8LSByb3duYW1lcyhkbWF0MSlbaV1cbnNwcC5qIDwtIGNvbG5hbWVzKGRtYXQxKVtqXVxucG9pbnRzKC0wLjUsICAgICAgICAgICAgICAgcGFpci5rLCBwY2ggPSBzcHAuaiwgY29sID0gd2hpY2goTEVUVEVSUyAlaW4lIHRvdXBwZXIoc3BwLmopKSwgY2V4ID0gMS43NSlcbnBvaW50cyhkaXN0LmlqKzAuNzUsICAgICAgIHBhaXIuaywgcGNoID1zcHAuaSwgY29sID0gd2hpY2goTEVUVEVSUyAlaW4lIHRvdXBwZXIoc3BwLmkpKSwgY2V4ID0gMS43NSlcbnNlZ21lbnRzKHgwID0gMCwgeTAgPSBwYWlyLmssIFxuICAgICAgICAgeDEgPSBkaXN0LmlqLCB5MSA9IHBhaXIuaylcbmFibGluZShoID0gcGFpci5rKzAuNSwgY29sID0gMilcbn1cblxuICB9XG59In0= We can see that the distance between a and b is the smallest, at 17 amino acid changes. UPGMA, WPGMA and related algorithms all begin by identifying the two taxa that are closest together. These 2 taxa form a clade (cluster). THe algorithm then proceeds by finding the next taxa (eg, c, d or e) which is closest to that clade of a and b We can summarize this first clad using Newick notation as: (a, b) 35.26.2 Genetic distances conceptualized as 2D map of linear distances We can extend the analogy of linear distance to two dimensions. With some fancy math we can make a 2D plot where the distances in 2D space are similar to the distances in the matrix. This is NOT exact and should not be taken literally. (See Pevsner Chapter 7 for a similar use of a 2D map) This is just a tool for teaching and not something done as part of an actual analysis. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwYXIobWZyb3cgPSBjKDEsMSksIG1hcj0gYygyLDIsMiwyKSlcbmRtYXQxbm8wIDwtIGRtYXQxXG4gIFxuZG1hdDFubzBbaXMubmEoZG1hdDFubzApXSA8LSAwXG5cbmQyICA8LSBjbWRzY2FsZShkbWF0MW5vMCwgYWRkID1UKVxueCA8LSBkMiRwb2ludHNbLDFdXG55IDwtIGQyJHBvaW50c1ssMl1cbnBsb3QoeCx5LCBtYWluID0gXCJBUFBST1hJTUFURSAyRCBkaXN0YW5jZXNcIix4bGltID0gYygtMjAsMjApLCB5bGltID0gYygtMjAsMjApKVxudGV4dCh4LCB5LCBsYWJlbHMgPSByb3cubmFtZXMoZDIkcG9pbnRzKSwgY2V4PTMpIn0= In this plot, things appear to have been distorted a bit. a and b are close to each other as expect, but b looks closest than e (to me). It does show how a and b are close, and d and e are further apart. 35.27 From linear distances to “tree distances” Genetic distances aren’t actually linear - we are assuming a “tree shape” to represent the divergence of two species genetically (and possibly geographically). The simplest methods of building trees assume that all branch lengths terminate at the same distance from the root, and the total mutational distance traversed by each species is the same. (This is the assumption or constraint related to ultrametricity). The distance between a and b is 17. We assume that both species a and species b have undergone the same number of mutations since they split, so the branch lengths for each are 17/2 = 8.5. (You obviously can’t have 8.5 mutations, but this is how the math works). The following plots shows how the linear distnace of 17 between a and b (bottom) gets split into two branches, each of 8.5. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIFRoaXMgY29kZSBpcyBkZW5zZTsgcnVuIGl0IGFuZCBmb2N1cyBvbiB0aGUgcGxvdFxucGFyKG1mcm93ID0gYygxLDEpLCBtYXI9IGMoMiwyLDIsMikpXG5wbG90KDAsIDAsIHhsaW0gPSBjKDAsbWF4KGRtYXQxLG5hLnJtID0gVCkpLCBcbiAgICAgeWxpbSA9IGMoMCwxMiksIFxuICAgICB0eXBlID0gXCJsXCIsXG4gICAgIHhsYWIgPSBjKFwiRGlzdGFuY2UgKG51bWJlciBvZiBtdXRhdGlvbnMpXCIpLFxuICAgICB5bGFiID0gXCJQYWlyd2lzZSBjb21wYXJpc29uXCIpXG5wb2ludHMoMCwgMSwgcGNoID0gXCJhXCIpXG5wb2ludHMoZG1hdDFbMiwxXSwgMSwgcGNoID0gXCJiXCIpXG5zZWdtZW50cyh4MCA9IDAsIHkwID0gMSwgXG4gICAgICAgICB4MSA9IGRtYXQxWzIsMV0seTEgPSAxKVxuYWJsaW5lKGggPSAxLjUsIGNvbCA9IDIpXG5cblxuYnJhbmNoLmxlbmd0aCA8LSBkbWF0MVsyLDFdLzJcbnBvaW50cygwLCA0KVxucG9pbnRzKGJyYW5jaC5sZW5ndGgrMC43NSwgNCwgcGNoID0gXCJhXCIpXG5wb2ludHMoMCwgNilcbnBvaW50cyhicmFuY2gubGVuZ3RoKzAuNzUsIDYsIHBjaCA9IFwiYlwiKVxuXG5zZWdtZW50cyh4MCA9IDAsIHkwID0gNCwgXG4gICAgICAgICB4MSA9IGJyYW5jaC5sZW5ndGgseTEgPSA0KVxuc2VnbWVudHMoeDAgPSAwLCB5MCA9IDYsIFxuICAgICAgICAgeDEgPSBicmFuY2gubGVuZ3RoLHkxID0gNilcblxuc2VnbWVudHMoeDAgPSAwLCB5MCA9IDQsIFxuICAgICAgICAgeDEgPSAwLCB5MSA9IDYsIGNvbCA9IDEsIGx0eSA9IDIpXG5cbmFibGluZShoID0gOCwgY29sID0gMikifQ== Again, in Newick notation, we’d write (a, b) to indicate that a and b are a clade. 35.28 The UPGMA algorithm The UPGMA algorithm is described by Swofford et al (1996?, page 486) as below. The word “cluster” means “taxa” in some cases and “clade” in others. * This is a bit tricky at first but once you get a sense for the whole algorithm it will make more sense. * To keep track of everything we’ll use subscripts i and j, represented in plain text as e.g. d.ij for the distance (d) in row i and column j. 35.28.1 Step 1: find the 2 taxa that are currently closest together “Given a matrix of pairwise distances, find the clusters (taxa) i and j such the d.ij is the minmum value in the table.” (d.ij is the distance between taxa i and taxa j) In our example, d.ij = d.ba = 17, with i = b and j = a. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkbWF0MVtcImJcIixcImFcIl0ifQ== 35.28.2 Step 2: calculate the branch lengths connect the taxa to their shared node “Define the depth of the branching between i and j (l.ij) to be d.ij/2” (“depth of branching” = branch length; so i is attached to a branch of d.ij/2 and j is attached to a separate branch of d.ij/2) d.ab/2 = 8.5 35.28.3 Step 3a: determine if the algorithm is done “If i and j were the last two clusters, the tree is complete” 35.28.4 Step 3a: Continue on if needed and combine the previous cluster into cluster “u” If there is more to do, “create a new cluster called u”. This new cluster is a clade of a and b will represent the combined features of a and b. What this means is that now that we’ve mapped taxa a and b into a clade we need to update our matrix to determine how far all the remaining taca (c, d and e) are from that clade. 35.28.5 Step 4: Determine the distance from u to the other remaining clusters. “Define the distance from [the new cluster] u to each other [remaining] cluster (k, with k==i or j) [here cluster = clade in the first part of the sentence and taxa in the other] to be an average of the distnace d.ki and d.jk”. That is, calculate the distance from the new clade u to all the remaining taxa, which we’ll generically call “k”. The new distance will be called d.ku, for “distance from taxa k to clade u.” The exact calculation of the average can take different forms. This will be unpacked below. 35.28.6 Step 5: Create a new matrix “Go back to step 1 with one less cluster; cluster i and j have been eliminated, and cluster u has been added.” The distance matrix is now shrunk with all distance related to i and j removed and replaced by information about u. 35.28.7 Key step: calculating the distance from a clade to the remaining taxa For step 4, UPGMA uses the equation below to calculate distances. This will require some notation: Ti = the number of taxa in cluster i. This is 1 if the “cluster” is a single taxa (eg. 1 species), or it can be &gt;1 if a previous iteration has created a clade. Tj = the number of taxa in cluster j. d.ku = the distance from k to u. k and u can be individual taxa OR clades created by the algorithm. The key quantity d.ku is calculated as: d.ku = (Ti x d.ki + Tj x d.kj)/(Ti + Tj) (You should know this equation AND you should be able to write R code to calcualte it) You can think of this as a weighted mean where the weights are the number of taxa in each clade. Its a very annoying that the “U” in UPGMA means “un-weighted” even though there is, from one perspective weighting, but this is how the math people say we should think about it (the un-weighted part has to do with some other aspect of the math). In the above outline of the algorithm, if i and j are the first two taxa grouped then the equation would be d.ku = (Ti x d.ki + Tj x d.kj)/(Ti + Tj) Ti = 1, Tj = 1, so d.ku = (1 x d.ki + 1 x d.kj)/(1 + 1) d.ku = (d.ki + d.kj)/2 35.29 Calculate 2D representation We can think about this using a 2D representation. First, plot the 2D map. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkbWF0MS5vdXQ8LSBwbG90X2Rpc3RfYXNfbm1kcyhkbWF0MSkifQ== a and b are closest together, so we group them I’ll show this in the code below; you don’t need to understand exactly how this code works. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkbWF0MS5vdXQ8LSBwbG90X2Rpc3RfYXNfbm1kcyhkbWF0MSlcblxuI2dldCB4IHkgY29vcmQgb2YgYSBhbmQgYlxuXG5hLjwtZG1hdDEub3V0JHBvaW50c1tcImFcIixdXG5iLjwtZG1hdDEub3V0JHBvaW50c1tcImJcIixdXG5cbnBsb3RfZGlzdF9hc19ubWRzKGRtYXQxKVxuZHJhdy5lbGxpcHNlKHggPSBtZWFuKGMoYS5bMV0sYi5bMV0pKSwgXG4gICAgICAgICAgICAgeSA9IG1lYW4oYyhhLlsyXSxiLlsyXSkpLFxuICAgICAgICAgICAgIGEgPTMsIFxuICAgICAgICAgICAgIGIgPSAxMCwgXG4gICAgICAgICAgICAgYW5nbGUgPSAzMFxuICAgICAgICAgICAgICkifQ== Once we have created a cluster (clade) we can consider the distance from the members of clade to all the remaining points. For example, here’s the distnace from a and b to c eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIGRpc3RhbmNlIGZyb20gYWIgdG8gY1xuYy48LWRtYXQxLm91dCRwb2ludHNbXCJjXCIsXVxuXG5wbG90X2Rpc3RfYXNfbm1kcyhkbWF0MSlcbnNlZ21lbnRzKHgwID0gYS5bMV0seDEgPSBjLlsxXSxcbiAgICAgICAgIHkwID0gYS5bMl0seTEgPSBjLlsyXSlcbnNlZ21lbnRzKHgwID0gYi5bMV0seDEgPSBjLlsxXSxcbiAgICAgICAgIHkwID0gYi5bMl0seTEgPSBjLlsyXSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAifQ== In UPGMA, we first define a clade. We then need to see which taxa is closest to that clade. Visually it looks like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwYXIobWZyb3cgPSBjKDIsMiksIG1hciA9IGMoMiwyLDIsMikpXG5cbiMgYWIgdG8gY1xucGxvdF9kaXN0X2FzX25tZHMoZG1hdDEpXG5cbiNnZXQgeCB5IGNvb3JkIG9mIGEgYW5kIGJcbmEuPC1kbWF0MS5vdXQkcG9pbnRzW1wiYVwiLF1cbmIuPC1kbWF0MS5vdXQkcG9pbnRzW1wiYlwiLF1cblxuZHJhdy5lbGxpcHNlKHggPSBtZWFuKGMoYS5bMV0sYi5bMV0pKSwgXG4gICAgICAgICAgICAgeSA9IG1lYW4oYyhhLlsyXSxiLlsyXSkpLFxuICAgICAgICAgICAgIGEgPTMsIFxuICAgICAgICAgICAgIGIgPSAxMCwgXG4gICAgICAgICAgICAgYW5nbGUgPSAzMClcbmMuPC1kMiRwb2ludHNbXCJjXCIsXVxuc2VnbWVudHMoeDAgPSBhLlsxXSx4MSA9IGMuWzFdLFxuICAgICAgICAgeTAgPSBhLlsyXSx5MSA9IGMuWzJdKVxuc2VnbWVudHMoeDAgPSBiLlsxXSx4MSA9IGMuWzFdLFxuICAgICAgICAgeTAgPSBiLlsyXSx5MSA9IGMuWzJdKSAgXG5cbiMgYWIgdG8gZFxucGxvdF9kaXN0X2FzX25tZHMoZG1hdDEpXG5kcmF3LmVsbGlwc2UoeCA9IG1lYW4oYyhhLlsxXSxiLlsxXSkpLCBcbiAgICAgICAgICAgICB5ID0gbWVhbihjKGEuWzJdLGIuWzJdKSksXG4gICAgICAgICAgICAgYSA9MywgXG4gICAgICAgICAgICAgYiA9IDEwLCBcbiAgICAgICAgICAgICBhbmdsZSA9IDMwKVxuZC48LWQyJHBvaW50c1tcImRcIixdXG5zZWdtZW50cyh4MCA9IGEuWzFdLHgxID0gZC5bMV0sXG4gICAgICAgICB5MCA9IGEuWzJdLHkxID0gZC5bMl0pXG5zZWdtZW50cyh4MCA9IGIuWzFdLHgxID0gZC5bMV0sXG4gICAgICAgICB5MCA9IGIuWzJdLHkxID0gZC5bMl0pICBcblxuIyBhYiB0byBlXG5wbG90X2Rpc3RfYXNfbm1kcyhkbWF0MSlcbmRyYXcuZWxsaXBzZSh4ID0gbWVhbihjKGEuWzFdLGIuWzFdKSksIFxuICAgICAgICAgICAgIHkgPSBtZWFuKGMoYS5bMl0sYi5bMl0pKSxcbiAgICAgICAgICAgICBhID0zLCBcbiAgICAgICAgICAgICBiID0gMTAsIFxuICAgICAgICAgICAgIGFuZ2xlID0gMzApXG5lLjwtZDIkcG9pbnRzW1wiZVwiLF1cbnNlZ21lbnRzKHgwID0gYS5bMV0seDEgPSBlLlsxXSxcbiAgICAgICAgIHkwID0gYS5bMl0seTEgPSBlLlsyXSlcbnNlZ21lbnRzKHgwID0gYi5bMV0seDEgPSBlLlsxXSxcbiAgICAgICAgIHkwID0gYi5bMl0seTEgPSBlLlsyXSkgIn0= 35.30 Algorithm - round 1 We will now implement the algorithm. NOTE: I am not using a consistent system of nomeclature - I am mixing my own conventions with hose of Swofford et al. Sorry :( First we’ll need a dataframe to hold tings it = iteration clust.i, clust.j = the two taxa or clades being combined dist.ij = value from distnace matrix between the taxa clust.u = name of the new combined cluster (clade) branch.l.ij = branch lengths A matrix to hold things as I work eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJuLnRheGEgPC0gbnJvdyhkbWF0MSlcblVQR01BX291dHB1dCA8LSBkYXRhLmZyYW1lKGl0ID0gYygxOm4udGF4YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbHVzdC5pID0gTkEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbHVzdC5qID0gTkEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0LmlqID0gTkEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbHVzdC51ID0gTkEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBicmFuY2gubC5paiA9IE5BKSJ9 35.30.1 Determine minimum value in current matrix The minimum distance using the min() function eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkaXN0Lm1pbi5pIDwtIG1pbihkbWF0MSwgbmEucm0gPSBUKSJ9 The index value of the minimum, using which() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpbmRleC5taW4uaSA8LSB3aGljaChkbWF0MSA9PSBkaXN0Lm1pbi5pLCBhcnIuaW5kID1UKVxuaW5kZXgucm93LmkgPC0gaW5kZXgubWluLmlbMV1cbmluZGV4LmNvbC5pIDwtIGluZGV4Lm1pbi5pWzJdIn0= We can get the names of our taxa using rownames() and colnames() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjbHVzdGVyLmkyIDwtIHJvd25hbWVzKGRtYXQxKVtpbmRleC5yb3cuaV1cbmNsdXN0ZXIuaTEgPC0gY29sbmFtZXMoZG1hdDEpW2luZGV4LmNvbC5pXSJ9 Add output to dataframe eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHRoZSBjbHVzdGVycyB3ZSdyZSB3b3JraW5nIGl3dGhcblVQR01BX291dHB1dFsxLFwiY2x1c3QuaVwiXSA8LSBjbHVzdGVyLmkxXG5VUEdNQV9vdXRwdXRbMSxcImNsdXN0LmpcIl0gPC0gY2x1c3Rlci5pMlxuXG4jIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZW1cblVQR01BX291dHB1dFsxLFwiZGlzdC5palwiXSA8LSBkaXN0Lm1pbi5pIn0= 35.30.2 Combine species into clade Combine the two taxa names into a new name. This can be done a couple ways. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIG5hbWUgb2Ygb3VyIGNsYWRlXG5cbiMjIGhhcmQtY29kZSBcImFiXCJcbmNsYWRlLmkgPC0gXCJhYlwiXG5cbiMjIHVzZSBwYXN0ZSgpIHRvIGdlbmVyYXRlIG5hbWVcbmNsYWRlLmkgPC0gcGFzdGUoXCJhXCIsXCJiXCIsc2VwID0gXCJcIilcblxuIyMgZ2VuZXJhbCwgcmUtdXNhYmxlIGNvZGUgdXNpbmcgcGFzdGUoKSBhbmQgb2JqZWN0IG5hbWVzXG5jbGFkZS5pIDwtIHBhc3RlKGNsdXN0ZXIuaTEsY2x1c3Rlci5pMiwgc2VwID0gXCJcIikifQ== We’ll add this to the dataframe eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXRbMSxcImNsdXN0LnVcIl0gPC0gY2xhZGUuaSJ9 Look at things so far eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXQifQ== 35.30.3 Calculate branch length Branch length is the distance between the two taxa: distance/2 or d.ij/2 We can access the distance in our first row of the matrix like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXRbMSxcImRpc3QuaWpcIl0ifQ== We can divided the distance betyween a and b by 2 to get our branch length like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXRbMSxcImRpc3QuaWpcIl0vMiJ9 Now store the distance d in the dataframe eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXRbMSxcImJyYW5jaC5sLmlqXCJdIDwtIFVQR01BX291dHB1dFsxLFwiZGlzdC5palwiXS8yIn0= We’ve now completed our first round of calculations eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXQifQ== 35.30.4 Calculate distance from clade to all other points Distance (ab) to all other points ab to c ab to d ab to e 35.30.4.1 ab to c This is calculated at the average of the distance from a to c, and from b to c. In the Wikipedia article the math is framed like this D(ab to c) = [D(a to c) + D(b to c)] / 2 D(ab to c) = [ 21 + 30 ] / 2 D(ab to c) = [ 21 + 30 ] / 2 D(ab to c) = 25.5 Dab_c = [Da_c + Db_c] / 2 Dab_c = 25.5 The math in the wikipedia article is more accurately written out as this, which is more similar to Swofford’s notation. D(ab to c) = [T.iD(a to c) + T.jD(b to c)] / 2 D(ab to c) = [1D(a to c) + 1D(b to c)] / (1+1) D(ab to c) = [ 121 + 130 ] / (1+1) D(ab to c) = [ 121 + 130 ] / (1+1) D(ab to c) = 25.5 Dab_c = [1Da_c + 1Db_c] / (1+1) Dab_c = 25.5 Using Swofford et al’s notation we’d do this: d.ku = (Ti x d.ki + Tj x d.kj)/(Ti + Tj) I’ll just switch the subscripts to be consistent with the Wikipedia notation d.uk = (Ti x d.ik + Tj x d.jk)/(Ti + Tj) where u = our new cluster ab k = the remaining clusters; we’ll start with c Ti, Tj = the number of clusters the constitute the clusters that were just combined. This starts out at 1. Ti = Ta = 1 Tj = Tb = 1 d.ik = the distance from cluster i to the reamining clusters; we’ll start with c d.ik = d.ac = 21 d.jk = d.bc = 30 d.ku = (Ti x d.ik + Tj x d.jk)/(Ti + Tj) d.ku = (1 x 21 + 1 x 30 )/( 1 + 1 ) d.ku = ( 21 + 30 )/(2) d.ku = 51/2 d.ku = 25.5 The Swofford notation is more generic and useful because in the next iteration we’ll have a cluster of ab which will have two taxa in it. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJUYSA8LSAxXG5UYiA8LSAxXG5EYV9jIDwtIDIxXG5EYl9jIDwtIDMwXG5EYWJfYyA8LSAoVGEqRGFfYytUYipEYl9jKS8yIn0= 35.30.4.2 ab to d We now continue for the other distances. I’ll stick to the wikipedia notation for now. D(ab to d) = [D(a to d) + D(b to d)] / 2 D(ab to d) = [ 31 + 34 ] / 2 D(ab to d) = [ 31 + 34 ] / 2 D(ab to d) = 32.5 Dab_d = [Da_d + Db_d] / 2 Dab_d = 32.5 eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJEYV9kIDwtIDMxXG5EYl9kIDwtIDM0XG5EYWJfZCA8LSAoRGFfZCtEYl9kKS8yIn0= 35.30.4.3 ab to e D(ab to d) = [D(a to d) + D(b to d)] / 2 D(ab to d) = [ 23 + 21 ] / 2 D(ab to d) = [ 23 + 21 ] / 2 D(ab to d) = Dab_e Dab_d = [Da_d + Db_d] / 2 Dab_d = Dab_e eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJEYV9lIDwtIDIzXG5EYl9lIDwtIDIxXG5EYWJfZSA8LSAoRGFfZStEYl9lKS8yIn0= 35.30.5 Update matrix with new distance Old matrix has distances from a and b to all other points: we want to replace these. distances among c, d, and e are still the same values. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkbWF0MSJ9 35.30.5.1 Illustration Values in parenthesese will be REPLACED eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJhIDwtIGMoTkEsIE5BLCBOQSwgTkEsIE5BKVxuYiA8LSBjKFwiKDE3KVwiLCBOQSwgTkEsIE5BLCBOQSlcbmNcdDwtIGMoXCIoMjEpXCIsIFwiKDMwKVwiLCBOQSwgTkEsIE5BKVxuZFx0PC0gYyhcIigzMSlcIiwgXCIoMzQpXCIsIFwiMjhcIiwgTkEsIE5BKVxuZVx0PC0gYyhcIigyMylcIiwgXCIoMjEpXCIsIFwiMzlcIiwgXCI0M1wiLFx0TkEpXG5kbWF0MS5hbHQgPC0gcmJpbmQoYSxiLGMsZCxlKVxuY29sbmFtZXMoZG1hdDEuYWx0KSA8LSBjKFwiYVwiLFwiYlwiLFwiY1wiLFwiZFwiLFwiZVwiKVxuZG1hdDEuYWx0In0= Create smaller matrix with clade ab eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjICAgICAgIGFiICAgICAgYyAgIGQgICBlXG5hYiAgPC0gYyhOQSwgICAgTkEsICBOQSwgTkEpXG5jXHQgIDwtIGMoRGFiX2MsIE5BLCAgTkEsIE5BKVxuZFx0ICA8LSBjKERhYl9kLCAyOCxcdCBOQSwgTkEpXG5lXHQgIDwtIGMoRGFiX2UsIDM5LCAgNDMsIE5BKVxuXG5kbWF0MiA8LSByYmluZChhYixjLGQsZSlcbmNvbG5hbWVzKGRtYXQyKSA8LSBjKFwiYWJcIixcImNcIixcImRcIixcImVcIikifQ== 35.30.5.2 Estimate 2 D Estimate of 2D representation of the new matrix. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90X2Rpc3RfYXNfbm1kcyhkbWF0MikifQ== 35.31 Algorithm - next round We’ve combined a and b and calculated the disnace of this clade (a,b) to the remaining taxa. What is now the minimum distance? The minimum distance of the current matrix eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkaXN0Lm1pbi5pIDwtIG1pbihkbWF0MiwgbmEucm0gPSBUKSJ9 The index value of the current minimum eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpbmRleC5taW4uaSA8LSB3aGljaChkbWF0MiA9PSBkaXN0Lm1pbi5pLCBhcnIuaW5kID1UKVxuaW5kZXgucm93LmkgPC0gaW5kZXgubWluLmlbMV1cbmluZGV4LmNvbC5pIDwtIGluZGV4Lm1pbi5pWzJdIn0= We can get the names of our taxa using the eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjbHVzdGVyLmkyIDwtIHJvd25hbWVzKGRtYXQyKVtpbmRleC5yb3cuaV1cbmNsdXN0ZXIuaTEgPC0gY29sbmFtZXMoZG1hdDIpW2luZGV4LmNvbC5pXSJ9 Add output to dataframe eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXRbMixcImNsdXN0LmlcIl0gPC0gY2x1c3Rlci5pMVxuVVBHTUFfb3V0cHV0WzIsXCJjbHVzdC5qXCJdIDwtIGNsdXN0ZXIuaTJcblVQR01BX291dHB1dFsyLFwiZGlzdC5palwiXSA8LSBkaXN0Lm1pbi5pIn0= 35.31.1 Combine species into clade Combine the two taxa names into a new name. This can be done a couple ways. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjbGFkZS5pIDwtIFwiYWJlXCJcbmNsYWRlLmkgPC0gcGFzdGUoXCJhYlwiLFwiZVwiLHNlcCA9IFwiXCIpXG5cbmNsYWRlLmkgPC0gcGFzdGUoY2x1c3Rlci5pMSxjbHVzdGVyLmkyLCBzZXAgPSBcIlwiKSJ9 We’ll add this to the dataframe eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXRbMixcImNsdXN0LnVcIl0gPC0gY2xhZGUuaSJ9 35.31.2 Calculate branch length Branch length is distance/2 or d.ij/2 = d.ab.e = 22/2 eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXRbMixcImJyYW5jaC5sLmlqXCJdIDwtIFVQR01BX291dHB1dFsyLFwiZGlzdC5palwiXS8yIn0= 35.31.3 Recalculate distance from abe to all remainign taxa In the current matrix, the smallest distance is between ab and e We therefore want to form a clade between ab and e (abe), the measure the distance from this clade to allthe other species. Visualize this as an approximate 2D situation eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwYXIobWZyb3cgPSBjKDEsMSkpXG5kbWF0Mi5vdXQgPC0gcGxvdF9kaXN0X2FzX25tZHMoZG1hdDIpXG5cbiNnZXQgeCB5IGNvb3JkIG9mIGFiIGFuZCBlXG5hYi48LWRtYXQyLm91dCRwb2ludHNbXCJhYlwiLF1cbmUuPC1kbWF0Mi5vdXQkcG9pbnRzW1wiZVwiLF1cblxuZHJhdy5lbGxpcHNlKHggPSBtZWFuKGMoYWIuWzFdLGUuWzFdKSksIFxuICAgICAgICAgICAgIHkgPSBtZWFuKGMoYWIuWzJdLGUuWzJdKSksXG4gICAgICAgICAgICAgYSA9NywgXG4gICAgICAgICAgICAgYiA9IDcsIFxuICAgICAgICAgICAgIGFuZ2xlID0gMClcbmMuPC1kbWF0Mi5vdXQkcG9pbnRzW1wiY1wiLF1cblxuc2VnbWVudHMoeDAgPSBhYi5bMV0seDEgPSBjLlsxXSxcbiAgICAgICAgIHkwID0gYWIuWzJdLHkxID0gYy5bMl0pXG5zZWdtZW50cyh4MCA9IGUuWzFdLHgxID0gYy5bMV0sXG4gICAgICAgICB5MCA9IGUuWzJdLHkxID0gYy5bMl0pICJ9 35.31.3.1 abe to c NOTE: calculations are “weighted” in proportion number of species in clade. So D(ab to c) is multiplied by two because ab is 2 species The denominators is 3 because of the weights used in the numerator. The notation in the Wikipedia article is: D(abe to c) = [D(ab to c)2 + D(e to c)1] / (2+1) D(abe to c) = [ 25.52 + 391 ] / (2+1) D(abe to c) = [ 25.52 + 391 ] / (2+1) D(abe to c) = 32.5 Dabe_c = [Dab_c2 + De_c1] / (2+1) Dabe_c = 32.5 eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJEYWJfYyA8LSAyNS41XG5EZV9jICA8LSAzOVxuRGFiZV9jIDwtIChEYWJfYyoyICsgRGVfYyoxKS8oMisxKSJ9 35.31.3.2 abe to c For abe to d eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJEYWJfZCA8LSAzMi41XG5EZV9kICA8LSA0M1xuRGFiZV9kIDwtIChEYWJfZCoyICsgRGVfZCoxKS8oMisxKSJ9 35.31.4 Update the matrix eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJhYmUgPC0gYyhOQSwgICAgIE5BLCAgTkEpXG5jXHQgICA8LSBjKERhYmVfYywgTkEsICBOQSlcbmRcdCAgIDwtIGMoRGFiZV9kLCAyOCxcdCBOQSlcblxuXG5kbWF0MyA8LSByYmluZChhYmUsYyxkKVxuY29sbmFtZXMoZG1hdDMpIDwtIGMoXCJhYmVcIixcImNcIixcImRcIikifQ== 35.32 Next iteration 35.32.0.1 Estimate 2 D a, b, e are now combined into a clade eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwYXIobWZyb3cgPSBjKDEsMSkpXG5kbWF0My5vdXQgPC0gcGxvdF9kaXN0X2FzX25tZHMoZG1hdDMpXG5cbiNnZXQgeCB5IGNvb3JkIG9mIGFiIGFuZCBlXG5jLiA8LWRtYXQzLm91dCRwb2ludHNbXCJjXCIsXVxuZC48LWRtYXQzLm91dCRwb2ludHNbXCJkXCIsXVxuXG5kcmF3LmVsbGlwc2UoeCA9IG1lYW4oYyhjLlsxXSxkLlsxXSkpLCBcbiAgICAgICAgICAgICB5ID0gbWVhbihjKGMuWzJdLGQuWzJdKSksXG4gICAgICAgICAgICAgYSA9MTQsIFxuICAgICAgICAgICAgIGIgPSA0LCBcbiAgICAgICAgICAgICBhbmdsZSA9IDEwNSlcbmFiZS48LWRtYXQzLm91dCRwb2ludHNbXCJhYmVcIixdXG5cbnNlZ21lbnRzKHgwID0gYy5bMV0seDEgPSBhYmUuWzFdLFxuICAgICAgICAgeTAgPSBjLlsyXSx5MSA9IGFiZS5bMl0pXG5zZWdtZW50cyh4MCA9IGQuWzFdLHgxID0gYWJlLlsxXSxcbiAgICAgICAgIHkwID0gZC5bMl0seTEgPSBhYmUuWzJdKSAifQ== 35.32.1 Calculate branch lengths The minimum distance of the current matrix eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkaXN0Lm1pbi5pIDwtIG1pbihkbWF0MywgbmEucm0gPSBUKSJ9 The index value of the current minimum eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpbmRleC5taW4uaSA8LSB3aGljaChkbWF0MyA9PSBkaXN0Lm1pbi5pLCBhcnIuaW5kID1UKVxuaW5kZXgucm93LmkgPC0gaW5kZXgubWluLmlbMV1cbmluZGV4LmNvbC5pIDwtIGluZGV4Lm1pbi5pWzJdIn0= We can get the names of our taxa using the eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjbHVzdGVyLmkyIDwtIHJvd25hbWVzKGRtYXQzKVtpbmRleC5yb3cuaV1cbmNsdXN0ZXIuaTEgPC0gY29sbmFtZXMoZG1hdDMpW2luZGV4LmNvbC5pXSJ9 Add output to dataframe eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXRbMyxcImNsdXN0LmlcIl0gPC0gY2x1c3Rlci5pMVxuVVBHTUFfb3V0cHV0WzMsXCJjbHVzdC5qXCJdIDwtIGNsdXN0ZXIuaTJcblVQR01BX291dHB1dFszLFwiZGlzdC5palwiXSA8LSBkaXN0Lm1pbi5pIn0= 35.32.2 Combine species into clade Combine the two taxa names into a new name. This can be done a couple ways. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjbGFkZS5pIDwtIFwiY2RcIlxuY2xhZGUuaSA8LSBwYXN0ZShcImNcIixcImRcIixzZXAgPSBcIlwiKVxuXG5jbGFkZS5pIDwtIHBhc3RlKGNsdXN0ZXIuaTEsY2x1c3Rlci5pMiwgc2VwID0gXCJcIikifQ== We’ll add this to the dataframe eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXRbMyxcImNsdXN0LnVcIl0gPC0gY2xhZGUuaSJ9 35.32.3 Calculate branch length Branch length is distance/2 or d.ij/2 = d.d.e = 28/2 eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXRbMyxcImJyYW5jaC5sLmlqXCJdIDwtIFVQR01BX291dHB1dFszLFwiZGlzdC5palwiXS8yIn0= 35.32.4 Distance of c to abe and d to abe eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJEY19hYmUgPC0gMzBcbkRkX2FiZSA8LSAzNlxuXG4jIGFiZSBpcyBjb21wb3N0ZWQgb2YgMyBcbkRkY19hYmUgPC0gKERjX2FiZSozICsgRGRfYWJlKjMpLygzKzMpXG5cbiMgZmFjdG9yIG91dCAzXG5EZGNfYWJlIDwtIDMqKERjX2FiZSoxICsgRGRfYWJlKjEpLzZcblxuIyBzaW1wbGlmeVxuRGRjX2FiZSA8LSAxKihEY19hYmUqMSArIERkX2FiZSoxKS8yXG5EZGNfYWJlIDwtIChEY19hYmUqMSArIERkX2FiZSkvMiJ9 Create matrix eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJhYmUgPC0gYyhOQSwgICAgIE5BKVxuY2RcdCA8LSBjKERkY19hYmUsIE5BKVxuXG5cblxuZG1hdDQgPC0gcmJpbmQoYWJlLGNkKVxuY29sbmFtZXMoZG1hdDQpIDwtIGMoXCJhYmVcIixcImNkXCIpIn0= 35.33 Finish up The final entry of the matrix is 33. This means that the distnace from the clade abe to the clade de is 33, with branch length of 33/2 = 16.5 The minimum distance eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkaXN0Lm1pbi5pIDwtIG1pbihkbWF0NCwgbmEucm0gPSBUKSJ9 The index value of the minimum eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpbmRleC5taW4uaSA8LSB3aGljaChkbWF0NCA9PSBkaXN0Lm1pbi5pLCBhcnIuaW5kID1UKVxuaW5kZXgucm93LmkgPC0gaW5kZXgubWluLmlbMV1cbmluZGV4LmNvbC5pIDwtIGluZGV4Lm1pbi5pWzJdIn0= We can get the names of our taxa using the eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjbHVzdGVyLmkyIDwtIHJvd25hbWVzKGRtYXQ0KVtpbmRleC5yb3cuaV1cbmNsdXN0ZXIuaTEgPC0gY29sbmFtZXMoZG1hdDQpW2luZGV4LmNvbC5pXSJ9 Add output to dataframe eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXRbNCxcImNsdXN0LmlcIl0gPC0gY2x1c3Rlci5pMVxuVVBHTUFfb3V0cHV0WzQsXCJjbHVzdC5qXCJdIDwtIGNsdXN0ZXIuaTJcblVQR01BX291dHB1dFs0LFwiZGlzdC5palwiXSA8LSBkaXN0Lm1pbi5pIn0= 35.33.1 Combine species into clade Combine the two taxa names into a new name. This can be done a couple ways. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjbGFkZS5pIDwtIHBhc3RlKGNsdXN0ZXIuaTEsY2x1c3Rlci5pMiwgc2VwID0gXCJcIikifQ== We’ll add this to the dataframe eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXRbNCxcImNsdXN0LnVcIl0gPC0gY2xhZGUuaSJ9 35.33.2 Calculate branch length Branch length is distance/2 or d.ij/2 eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXRbNCxcImJyYW5jaC5sLmlqXCJdIDwtIFVQR01BX291dHB1dFs0LFwiZGlzdC5palwiXS8yIn0= 35.34 Finalizing branch lengths We now have a final tree structure. In Newick format it would be eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJmdWxsLnRyZWUgPC0gXCIoKGMsZCksKGUsKGIsIGEpKSk7XCIgIyBzZW1pIGNvbG9uIVxuZnVsbC50cmVlIDwtcmVhZC50cmVlKHRleHQ9ZnVsbC50cmVlKVxucGxvdChmdWxsLnRyZWUsIG1haW4gPSBcIjMtdGF4YSB0cmVlXCIpIn0= While we’ve done our clustering we’ve calcualte branch lengths and put them in the column branch.l.ij of the dataframe UPGMA_output eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJVUEdNQV9vdXRwdXQifQ== The following code adds them to the tree. First, the brnach lenghts from a to b eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KGZ1bGwudHJlZSwgbWFpbiA9IFwiXCIpXG4jIGEtYiBicmFuY2ggbGVuZ3Rocz0gOC41XG50ZXh0KHggPSAzLjUseSA9IDUuMSxsYWJlbHMgPSA4LjUpXG50ZXh0KHggPSAzLjUseSA9IDQuMSxsYWJlbHMgPSA4LjUpIn0= now a to b, and ab to e eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KGZ1bGwudHJlZSwgbWFpbiA9IFwiXCIpXG4jIGEtYiBicmFuY2ggbGVuZ3Rocz0gOC41XG50ZXh0KHggPSAzLjUseSA9IDUuMSxsYWJlbHMgPSA4LjUpXG50ZXh0KHggPSAzLjUseSA9IDQuMSxsYWJlbHMgPSA4LjUpXG4jIGFiLWUgYnJhbmNoIGxlbmd0aHM9IDFcbnRleHQoeCA9IDMuNSx5ID0gMy4xLGxhYmVscyA9IDExKSJ9 There’s a branch between the clade ab and the node that connects with e. What’s its length? FOr a simple ultrametric tree calcualted with UPGMA we can calculate this by subtraction eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIxMS04LjUifQ== We’ll added this short branch of 2.5. Note this things ARE NOT to scale. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KGZ1bGwudHJlZSwgbWFpbiA9IFwiXCIpXG4jIGEtYiBicmFuY2ggbGVuZ3Rocz0gOC41XG50ZXh0KHggPSAzLjUseSA9IDUuMSxsYWJlbHMgPSA4LjUpXG50ZXh0KHggPSAzLjUseSA9IDQuMSxsYWJlbHMgPSA4LjUpXG4jIGFiLWUgYnJhbmNoIGxlbmd0aHM9IDFcbnRleHQoeCA9IDMuNSx5ID0gMy4xLGxhYmVscyA9IDExKVxuXG4jIHNob3J0IGJyYW5jaFxudGV4dCh4ID0gMi41LHkgPSA0LjYsbGFiZWxzID0gMi41KSJ9 To visualize exactly what is going on here its useful to add this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwYXIobWFyID0gYygxLDEsMSwxKSlcbnBsb3QoZnVsbC50cmVlLCBtYWluID0gXCJcIilcbiMgYS1iIGJyYW5jaCBsZW5ndGhzPSA4LjVcbnRleHQoeCA9IDMuNSx5ID0gNC45LGxhYmVscyA9IDguNSlcbnRleHQoeCA9IDMuNSx5ID0gNC4xLGxhYmVscyA9IDguNSlcbiMgYWItZSBicmFuY2ggbGVuZ3Rocz0gMVxudGV4dCh4ID0gMy41LHkgPSAzLjEsbGFiZWxzID0gMTEpXG5cbiMgc2hvcnQgYnJhbmNoXG50ZXh0KHggPSAyLjUseSA9IDQuNixsYWJlbHMgPSAyLjUpXG5cbmFycm93cyh4MCA9IDIseDEgPSA0LHkwID01LjE1LHkxPTUuMTUsIGNvZGUgPTMsYW5nbGUgPSA5MCxsZW5ndGggPTAuMSwgbHR5ID0yLCBjb2wgPSAyKVxudGV4dCh4ID0gMi41LHkgPSA1LGxhYmVscyA9IFwiMi41KzguNT0xMVwiKSJ9 We can now add the d-e branch of 14 (note again - not to scale!) eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KGZ1bGwudHJlZSwgbWFpbiA9IFwiXCIpXG4jIGEtYiBicmFuY2ggbGVuZ3Rocz0gOC41XG50ZXh0KHggPSAzLjUseSA9IDUuMSxsYWJlbHMgPSA4LjUpXG50ZXh0KHggPSAzLjUseSA9IDQuMSxsYWJlbHMgPSA4LjUpXG4jIGFiLWUgYnJhbmNoIGxlbmd0aHM9IDFcbnRleHQoeCA9IDMuNSx5ID0gMy4xLGxhYmVscyA9IDExKVxuXG4jIHNob3J0IGJyYW5jaFxudGV4dCh4ID0gMi41LHkgPSA0LjYsbGFiZWxzID0gMi41KVxuXG4jIGQtZSBicmFuY2hcbnRleHQoeCA9IDMuNSx5ID0gMS4xLGxhYmVscyA9IDE0KVxudGV4dCh4ID0gMy41LHkgPSAyLjEsbGFiZWxzID0gMTQpIn0= The distance from abe to de is 16.5 We can visualize this as eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KGZ1bGwudHJlZSwgbWFpbiA9IFwiXCIpXG4jIGEtYiBicmFuY2ggbGVuZ3Rocz0gOC41XG50ZXh0KHggPSAzLjUseSA9IDUuMSxsYWJlbHMgPSA4LjUpXG50ZXh0KHggPSAzLjUseSA9IDQuMSxsYWJlbHMgPSA4LjUpXG4jIGFiLWUgYnJhbmNoIGxlbmd0aHM9IDFcbnRleHQoeCA9IDMuNSx5ID0gMy4xLGxhYmVscyA9IDExKVxuXG4jIHNob3J0IGJyYW5jaFxudGV4dCh4ID0gMi41LHkgPSA0LjYsbGFiZWxzID0gMi41KVxuXG4jIGQtZSBicmFuY2hcbnRleHQoeCA9IDMuNSx5ID0gMS4xLGxhYmVscyA9IDE0KVxudGV4dCh4ID0gMy41LHkgPSAyLjEsbGFiZWxzID0gMTQpXG5cblxuYXJyb3dzKHgwID0gMCx4MSA9IDQseTAgPTAuODUseTE9MC44NSwgY29kZSA9MyxhbmdsZSA9IDkwLGxlbmd0aCA9MC4xLCBsdHkgPTIsIGNvbCA9IDIpXG50ZXh0KHggPSAxLHkgPSAxLGxhYmVscyA9IDE2LjUpIn0= We can calcualte the distance of the remaining short branch from de to the root as 16.5-14 = 2.5. When we plot this again, it won’t be to scale eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KGZ1bGwudHJlZSwgbWFpbiA9IFwiXCIpXG4jIGEtYiBicmFuY2ggbGVuZ3Rocz0gOC41XG50ZXh0KHggPSAzLjUseSA9IDUuMSxsYWJlbHMgPSA4LjUpXG50ZXh0KHggPSAzLjUseSA9IDQuMSxsYWJlbHMgPSA4LjUpXG4jIGFiLWUgYnJhbmNoIGxlbmd0aHM9IDFcbnRleHQoeCA9IDMuNSx5ID0gMy4xLGxhYmVscyA9IDExKVxuXG4jIHNob3J0IGJyYW5jaFxudGV4dCh4ID0gMi41LHkgPSA0LjYsbGFiZWxzID0gMi41KVxuXG4jIGQtZSBicmFuY2hcbnRleHQoeCA9IDMuNSx5ID0gMS4xLGxhYmVscyA9IDE0KVxudGV4dCh4ID0gMy41LHkgPSAyLjEsbGFiZWxzID0gMTQpXG5cblxuYXJyb3dzKHgwID0gMCx4MSA9IDQseTAgPTAuODUseTE9MC44NSwgY29kZSA9MyxhbmdsZSA9IDkwLGxlbmd0aCA9MC4xLCBsdHkgPTIsIGNvbCA9IDIpXG50ZXh0KHggPSAxLHkgPSAxLGxhYmVscyA9IFwiMTYuNSAtIDE0ID0gMi41XCIpIn0= We can calculate the remaining short branch from abe to the root as 16.5-8.5-2.5 =16.5-11 =5.5 eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KGZ1bGwudHJlZSwgbWFpbiA9IFwiXCIpXG4jIGEtYiBicmFuY2ggbGVuZ3Rocz0gOC41XG50ZXh0KHggPSAzLjUseSA9IDUuMSxsYWJlbHMgPSA4LjUpXG50ZXh0KHggPSAzLjUseSA9IDQuMSxsYWJlbHMgPSA4LjUpXG4jIGFiLWUgYnJhbmNoIGxlbmd0aHM9IDFcbnRleHQoeCA9IDMuNSx5ID0gMy4xLGxhYmVscyA9IDExKVxuXG4jIHNob3J0IGJyYW5jaFxudGV4dCh4ID0gMi41LHkgPSA0LjYsbGFiZWxzID0gMi41KVxuXG4jIGQtZSBicmFuY2hcbnRleHQoeCA9IDMuNSx5ID0gMS4xLGxhYmVscyA9IDE0KVxudGV4dCh4ID0gMy41LHkgPSAyLjEsbGFiZWxzID0gMTQpXG5cblxuYXJyb3dzKHgwID0gMCx4MSA9IDQseTAgPTAuODUseTE9MC44NSwgY29kZSA9MyxhbmdsZSA9IDkwLGxlbmd0aCA9MC4xLCBsdHkgPTIsIGNvbCA9IDIpXG50ZXh0KHggPSAxLHkgPSAxLGxhYmVscyA9IFwiMTYuNSAtIDE0ID0gMi41XCIpXG5cbmFycm93cyh4MCA9IDAseDEgPSA0LHkwID01LjEseTE9NS4xLCBjb2RlID0zLGFuZ2xlID0gOTAsbGVuZ3RoID0wLjEsIGx0eSA9MiwgY29sID0gMilcbnRleHQoeCA9IDEseSA9IDUsbGFiZWxzID0gXCIxNi41IC0gOC41IC0gMi41ID0gNS41XCIpIn0= So the final tree has branch lengths (not to scale!) of eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KGZ1bGwudHJlZSwgbWFpbiA9IFwiXCIpXG4jIGEtYiBicmFuY2ggbGVuZ3Rocz0gOC41XG50ZXh0KHggPSAzLjUseSA9IDUuMSxsYWJlbHMgPSA4LjUpXG50ZXh0KHggPSAzLjUseSA9IDQuMSxsYWJlbHMgPSA4LjUpXG4jIGFiLWUgYnJhbmNoIGxlbmd0aHM9IDFcbnRleHQoeCA9IDMuNSx5ID0gMy4xLGxhYmVscyA9IDExKVxuXG4jIHNob3J0IGJyYW5jaFxudGV4dCh4ID0gMi41LHkgPSA0LjYsbGFiZWxzID0gMi41KVxuXG4jIGQtZSBicmFuY2hcbnRleHQoeCA9IDMuNSx5ID0gMS4xLGxhYmVscyA9IDE0KVxudGV4dCh4ID0gMy41LHkgPSAyLjEsbGFiZWxzID0gMTQpXG5cblxuXG50ZXh0KHggPSAxLHkgPSAxLjYsbGFiZWxzID0gXCIyLjVcIilcblxuXG50ZXh0KHggPSAxLHkgPSA0LGxhYmVscyA9IFwiNS41XCIpIn0= Most of the time we don’t include branch lengths in Newick format, but there is a way to do it. You don’t need to know how to do this - this is just for illustration eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJmdWxsLnRyZWUgPC0gXCIoKGM6MTQsZDoxNCk6Mi41LChlOjExLChiOjguNSwgYTo4LjUpOjIuNSk6NS41KTtcIiAjIHNlbWkgY29sb24hXG5mdWxsLnRyZWUgPC1yZWFkLnRyZWUodGV4dD1mdWxsLnRyZWUpXG5wbG90KGZ1bGwudHJlZSwgbWFpbiA9IFwiXCIpXG5cbnRleHQoeCA9IDEwLHkgPSA1LjEsbGFiZWxzID0gOC41KVxudGV4dCh4ID0gMTAseSA9IDQuMSxsYWJlbHMgPSA4LjUpXG4jIGFiLWUgYnJhbmNoIGxlbmd0aHM9IDFcbnRleHQoeCA9IDEwLHkgPSAzLjEsbGFiZWxzID0gMTEpXG5cbiMgc2hvcnQgYnJhbmNoXG50ZXh0KHggPSA3LHkgPSA0LjYsbGFiZWxzID0gMi41KVxuXG4jIGQtZSBicmFuY2hcbnRleHQoeCA9IDEwLHkgPSAxLjEsbGFiZWxzID0gMTQpXG50ZXh0KHggPSAxMCx5ID0gMi4xLGxhYmVscyA9IDE0KVxuXG5cblxudGV4dCh4ID0gMS41LHkgPSAxLjYsbGFiZWxzID0gXCIyLjVcIilcblxuXG50ZXh0KHggPSAxLjUseSA9IDMuOSxsYWJlbHMgPSBcIjUuNVwiKSJ9 "],["representing-phylogenetic-trees-in-newick-format.html", "Chapter 36 Representing phylogenetic trees in Newick format 36.1 Vocab 36.2 Introduction 36.3 Trees with three taxa 36.4 Trees with four taxa", " Chapter 36 Representing phylogenetic trees in Newick format **By*: Nathan Brouwer ## ## Attaching package: &#39;ape&#39; ## The following objects are masked from &#39;package:igraph&#39;: ## ## edges, mst, ring ## The following object is masked from &#39;package:Biostrings&#39;: ## ## complement ## ## Attaching package: &#39;phangorn&#39; ## The following object is masked from &#39;package:igraph&#39;: ## ## diversity 36.1 Vocab Newick notation topology clade 36.2 Introduction Newick format is a common way to store information about rooted phylogenetic trees in a compact, written format. In its standard format, Newick does not store information about branch lengths, though it can be augmented to include lengths. 36.3 Trees with three taxa A simple phylogenetic tree with three species can be represented in Newick as: \\[((Human, Chimp), Gorilla)\\] In Newick format, clades are enclosed in parentheses. So, in the example above, “(Human, Chimp)” means that humans and chimps are a clade and are each other’s closest neighbors on the tree. The general mathematical rules of parentheses apply to Newick format. Therefore, the order within the parentheses doesn’t matter: “(Human, Chimp)” is the same as “(Chimp, Human)”. The two version of the trees result in differences in the order the taxa appear from top to bottom, but do not change its toplogy or interpretation. Similarly, “((Human, Chimp), Gorilla)” is the same as “(Gorilla, (Human, Chimp))”. These rules for Newick are analogous to the rules for using parentheses in math: (1+2) is the same as (2+1), and ((2+1) * 2) is the same as (2*(2+1)). 36.4 Trees with four taxa If we split Gorillas into the two major groups, western Gorillas in Gabon and eastern Gorillas in the Democratic Republic of Congo, we would put them in a clade: “(Gorilla-W, Gorilla-E)”. We’ll now have two separate clades of two taxa. We would then build up the full tree as \\[((Human, Chimp), (Gorilla-W, Gorilla-E))\\] This has two clades of two taxa each Humans-Chimps Western gorillas-Eastern Gorillas If wanted to represent a tree with humans, chimps, gorillas and orangutan we would represent it like this: \\[(((Human, Chimp),Gorilla), Orangutan)\\] The parenthesis to the right of Gorilla indicates that Gorilla falls within the human-chimp clade. Just as in math, the number of parentheses needs to balance out. In this case, there are three parentheses open to the right, all next to human. There therefore needs to be 3 parentheses open to the right. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIDMyMSAgICAgICAgICAgIDEgICAgICAgIDIgICAgICAgICAgIDNcbiMgKCgoSHVtYW4sIENoaW1wKSxHb3JpbGxhKSwgT3Jhbmd1dGFuKSJ9 "],["plotting-trees-from-newick-notation-in-r.html", "Chapter 37 Plotting trees from Newick notation in R 37.1 Preliminaries 37.2 Note 37.3 3 taxa tree in Newick 37.4 4 taxa tree in Newick 37.5 5 taxa in Newick Format 37.6 Many-taxa tree 37.7 Newick and Branch lengths 37.8 Additional Reading", " Chapter 37 Plotting trees from Newick notation in R In R, a phylogenetic tree in Newick format can be input as a character string and plotted using the ape package. 37.1 Preliminaries eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGFwZSlcbmxpYnJhcnkocGhhbmdvcm4pIn0= 37.2 Note Throughout this lesson I use the par() command to set up plots. You can ignore this command because its pretty tricky to use. 37.3 3 taxa tree in Newick We input the tree as quoted text; note the semi colon at the end! eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHR3byB0YXhhIGluIGNsYWRlXG5cIihILEMpXCJcblxuIyB0aGlyZCB0YXhhXG5cIiggKEgsQykgLCBHIClcIlxuXG4jIGZ1bGwgc3RyaW5nXG5zdHIxIDwtIFwiKChILCBDKSwgRyApO1wiICMgc2VtaSBjb2xvbiEifQ== We then convert the tree using read.tree() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlMSA8LWFwZTo6cmVhZC50cmVlKHRleHQ9c3RyMSkifQ== We plot with plot() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KHRyZWUxLCBtYWluID0gXCIzLXRheGEgdHJlZVwiKSJ9 We can change the orientation of the tree by changing the order within the parentheses. For example, if we want Gorillas to appear at the bottom of the graph eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHIyPC0gXCIoRywoSCwgQykpO1wiICAgICAgICAgIyBzZW1pIGNvbG9uIVxudHJlZTIgPC1yZWFkLnRyZWUodGV4dD1zdHIyKVxucGxvdCh0cmVlMiwgbWFpbiA9IFwiMy10YXhhIHRyZWVcIikifQ== Perhaps we want humans at the top eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHIzPC0gXCIoRywoQywgSCkpO1wiICAgICAgICAgICAjIHNlbWkgY29sb24hXG50cmVlMyA8LXJlYWQudHJlZSh0ZXh0PXN0cjMpXG5wbG90KHRyZWUzLCBtYWluID0gXCIzLXRheGEgdHJlZVwiKSJ9 Note that all of these trees have the same branching order and therefore the exact same topology. Challenge: Try to add the forth possible format of the tree that has the same topology. TODO doesnt render eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwYXIobWZyb3cgPSBjKDIsMikpXG5wbG90KHRyZWUxLCBtYWluID0gXCIzLXRheGEgdHJlZSAxXCIpXG5wbG90KHRyZWUyLCBtYWluID0gXCIzLXRheGEgdHJlZSAyXCIpXG5wbG90KHRyZWUzLCBtYWluID0gXCIzLXRheGEgdHJlZSAzXCIpIn0= 37.4 4 taxa tree in Newick When there are four taxa, there are two main topologies. The first is a simple ladder branching typology. This is represented like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHI0PC0gXCIoKChIdW1hbiwgQ2hpbXApLEdvcmlsbGEpLCBPcmFuZ3V0YW4pO1wiXG50cmVlNCA8LXJlYWQudHJlZSh0ZXh0PXN0cjQpXG5cbnBhcihtZnJvdyA9IGMoMSwxKSwgbWFyID0gYygyLDIsMiwyKSlcbnBsb3QodHJlZTQsIG1haW4gPSBcIjQtdGF4YSBsYWRkZXIgdHJlZVwiKSJ9 The second major topology is when there are two major clades, each with two taxa eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHI1PC0gXCIoKEh1bWFuLCBDaGltcCksIChHb3JpbGxhLVcsIEdvcmlsbGEtRSkpO1wiXG50cmVlNSA8LXJlYWQudHJlZSh0ZXh0PXN0cjUpXG5wbG90KHRyZWU1LCBtYWluID0gXCI0LXRheGEsIDIgY2xhZGUgdHJlZVwiKSJ9 Within each of the topologies, the grouping of species can be switched depending on what the evidence suggests. For example, some researchers have proposed the humans are more closely related to Orangutans. Their hypothesis has a ladder branching typology with the order of the species switched. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHI2PC0gXCIoKChIdW1hbiwgT3Jhbmd1dGFuKSxDaGltcCksIEdvcmlsbGEpO1wiXG50cmVlNiA8LXJlYWQudHJlZSh0ZXh0PXN0cjYpXG5wbG90KHRyZWU2LCBtYWluID0gXCJcIikifQ== 37.5 5 taxa in Newick Format Five taxa can occur in a number of general typologies. The most basic is a continuous ladder. After Orangutans, humans next-most distantly related “cousin” are the Gibbons. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwYXIobWZyb3cgPSBjKDEsMSksIG1hciA9IGMoMiwyLDIsMikpXG5zdHI3PC0gXCIoKCgoSHVtYW4sIENoaW1wKSxHb3JpbGxhKSwgT3Jhbmd1dGFuKSxHaWJib25zKTtcIlxudHJlZTcgPC1yZWFkLnRyZWUodGV4dD1zdHI3KVxucGxvdCh0cmVlNywgbWFpbiA9IFwiNS10YXhhIGxhZGRlciB0cmVlXCIpIn0= Let’s say there’s a hypothesis that Gibbons and Orangutans form a clade (there’s no actual evidence of this). This typology would create a tree with two main clades, one with 3 species and one with two. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHI4IDwtIFwiKCgoKEh1bWFuLCBDaGltcCksR29yaWxsYSksIChPcmFuZ3V0YW4sR2liYm9ucykpKTtcIlxudHJlZTggPC1yZWFkLnRyZWUodGV4dD1zdHI4KVxucGxvdCh0cmVlOCwgbWFpbiA9IFwiNS10YXhhLCAyIGJpZyBjbGFkZXMgdHJlZVwiKSJ9 A third major typology occurs if there are four taxa in a clade on a branch. Let’s say there’s a hypothesis that Orangutans and Gorillas are sister species (they aren’t), and Gibbons are there more distantly related cousins. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHI5IDwtIFwiKCgoSHVtYW4sIENoaW1wKSwgKE9yYW5ndXRhbiwgR29yaWxsYSkpLCBHaWJib25zKTtcIlxudHJlZTkgPC1yZWFkLnRyZWUodGV4dD1zdHI5KVxucGxvdCh0cmVlOSwgbWFpbiA9IFwiNS10YXhhLCB3aXRoIDQtdGF4YSBjbGFkZSBcIikifQ== Here’s another example of this format, dropping Gibbons and adding the two Gorilla subspecies (unlike many of the previous examples, this one is true). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHIxMDwtIFwiKCgoSHVtYW4sIENoaW1wKSwoR29yaWxsYS1XLCBHb3JpbGxhLUUpKSwgT3Jhbmd1dGFuKTtcIlxudHJlZTEwIDwtcmVhZC50cmVlKHRleHQ9c3RyMTApXG5wbG90KHRyZWU5LCBtYWluID0gXCJcIikifQ== 37.6 Many-taxa tree Newick format can be used to represent any kind of tree, though in practice this can be very difficult to write out by hand. Here is an example of a number of vertebrates eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwYXIobWZyb3cgPSBjKDEsMSksIG1hciA9IGMoMiwyLDIsMikpXG5zdHIudmVydDwtICAgIFwiKCgoKCgoKGNvdywgcGlnKSx3aGFsZSksKGJhdCwobGVtdXIsaHVtYW4pKSksKHJvYmluLGlndWFuYSkpLGNvZWxhY2FudGgpLGdvbGRfZmlzaCksc2hhcmspO1wiXG52ZXJ0LnRyZWU8LXJlYWQudHJlZSh0ZXh0PXN0ci52ZXJ0KVxucGxvdCh2ZXJ0LnRyZWUsbm8ubWFyZ2luPVRSVUUsZWRnZS53aWR0aD0yKSJ9 37.7 Newick and Branch lengths Below is an example of a BIG tree which also has branch lengths represented. The original analysis was in Miyamoto and Goodman (1986) “Biomolecular Systematics of Eutherian Mammals: Phylogenetic Patterns and Classification.” eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHIudmVydDwtICBcIihFZGVudGF0YTo1NSwgKCgoT3J5Y3Rlcm9wdXM6MTIsIFRyaWNoZWNodXM6NDMpOjEsIChQcm9jYXZpYToyOSwgKEVsZXBoYXM6MTgsIExveG9kb250YTo1KTo1NSk6MTApOjE1LCAoKChDaGlyb3B0ZXJhOjI3LCAoVHVwYWlhOjQzLCAoKFRhbHBhOjI0LCAoU3VuY3VzOjI0LCBFcmluYWNldXM6NTgpOjYpOjQsIChNYW5pczo1LCAoKEZlbGlzOjEzLCBMZW86Nyk6MzIsICgoQ2FuaXM6MzcsIFVyc2lkYWU6MTIpOjQsICgoUGhvY2lkYWU6MTksIFphbG9waHVzOjE3KTo3LCAoUHJvY3lvbmlkYWU6MTIsIE11c3RlbGlkYWU6MjIpOjkpOjUpOjE3KToxMyk6Myk6MTApOjYpOjgsICgoKExlbXVyaWRhZTo0NiwgKEdhbGFnbzoxNiwgTnljdGljZWJ1czoyNyk6MTApOjgsIChUYXJzaXVzOjE1LCAoKENlYnVzOjEwLCAoQXRlbGluYWU6NSwgKEFvdHVzOjYsIENhbGxpdGhyaXg6OSk6Myk6Myk6MTgsICgoSHlsb2JhdGVzOjYsIChQb25nbzoxLCAoR29yaWxsYToyLCAoSG9tbzoyMiwgUGFuOjEpOjIpOjYpOjIpOjUsIChQcmVzYnl0aXM6MSwgKENlcmNvcGl0aGVjdXM6MSwgKEVyeXRocm9jZWJ1czowLCAoJ01hY2FjYSBmYXNjaWN1bGFyaXMnOjIsICgnTWFjYWNhIG11bGF0dGEnOjUsICdNYWNhY2EgZnVzY2F0YSc6MCk6MSwgKFRoZXJvcGl0aGVjdXM6MiwgUGFwaW86NCk6MTUpOjIpOjEpOjgpOjYpOjkpOjIyKToxMCk6MTMsICgoT2Nob3RvbmE6NywgT3J5Y3RvbGFndXM6NTQpOjQsIChDYXZpb21vcnBoYToxMDcsIChTcGVybW9waGlsdXM6MjksIChTcGFsYXg6MjMsICgoUmF0dHVzOjcxLCBNdXM6MTkpOjE1LCAoT25kYXRyYToyNywgTWVzb2NyaWNldHVzOjMyKToyNyk6MjApOjgpOjEyKToxNSk6MTEpOjkpOjEyLCAoKFN1czo1MCwgKChMYW1hOjEwLCBDYW1lbHVzOjI0KTozMSwgKEhpcHBvcG90YW11czozMSwgKCgoT3Zpczo5LCBDYXByYTo4KToxOSwgKChBbnRpbG9jYXByYToxMywgR2lyYWZmYToxNCk6NywgKENlcnZ1czo4LCBBbGNlczo5KToxMSk6Mik6OSwgKFRyYWdlbGFwaGluYWU6NiwgKCdCb3MgZ3J1bm5pZW5zJzo2LCAoQmlzb246NSwgJ0JvcyB0YXVydXMnOjE1KTo3KToxMSk6Nik6NDcpOjEwKToxOSk6MTgsICgoKCdFcXV1cyAoQXNpbnVzKSc6NiwgJ0VxdXVzIGNhYmFsbHVzJzozMSk6MjQsIChUYXBpcnVzOjE5LCBSaGlub2Nlcm90aWRhZToyMyk6MTEpOjIyLCAoKFBob2NvZW5hOjQsIFR1cnNpb3BzOjE3KTo1LCAoQmFsYWVub3B0ZXJhOjM2LCBFc2NocmljaHRpdXM6Mik6OCk6MjkpOjEyKToxMik6MTYpOjU1KTtcIlxudmVydC50cmVlPC1yZWFkLnRyZWUodGV4dD1zdHIudmVydClcbnBsb3QodmVydC50cmVlLG5vLm1hcmdpbj1UUlVFLGVkZ2Uud2lkdGg9MikifQ== 37.8 Additional Reading The Wikipedia article on Newick format shows how it can be extended for more complex scenarios, including annotation of branch lengths. https://en.wikipedia.org/wiki/Newick_format Newick format is briefly mentioned on page 47 of Baum &amp; Smith Tree Thinking. "],["phylogenetic-trees-using-the-upgma-clustering-algoirthm.html", "Chapter 38 Phylogenetic trees using the UPGMA clustering algoirthm 38.1 Introduction 38.2 Preliminaries 38.3 Sequence comparisons 38.4 Distance matrices 38.5 From a distance matrix to phylogenetic tree 38.6 Distance matrix in R from raw sequences 38.7 Distance matrix in R from normal matrix 38.8 UPGMA in R 38.9 How UPGMA clustering works 38.10 Further information", " Chapter 38 Phylogenetic trees using the UPGMA clustering algoirthm By: Nathan Brouwer 38.1 Introduction UPGMA is a method for constructing phylogenetic trees using genetic distances. It is an old, outmoded method that is rarely ever used any more for building final versions of trees. Instead of UPGMA, the neighbor-joining (NJ) algorithm is used when a distance-based phylogeny is made. UPGMA’s relative simplicity, however, makes it a useful starting point for thinking about how to construct phylogenetic trees and code up algorithms to build them. UPGMA has also been used in the past in statistics, machine learning, transcriptomics, and community ecology as a general clustering algorithm and so is a useful starting point when understanding current algorithms in those fields. 38.2 Preliminaries eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIFBvdGVudGlhbGx5IG5ldyBwYWNrYWdlc1xuIyMgaW5zdGFsbC5wYWNrYWdlcyhcInBoYW5nb3JuXCIpXG4jIyBpbnN0YWxsLnBhY2thZ2VzKFwiYXBlXCIpXG5cbmxpYnJhcnkoYXBlKVxubGlicmFyeShwaGFuZ29ybikifQ== 38.2.1 Vocab matrix, matrices diagonal of matrix symmetrical matrix lower triangle of matrix Newick format character string function, argument branch, edge, clade 38.2.2 General R functions c() matrix() colnames, rownames cbind, rbind class as.dist() par min str 38.2.3 Specific functions phangorn::phangorn() ape::read.tree ape::as.DNAbin ape::dist.dna() 38.3 Sequence comparisons Let’s consider three short, hypothetical DNA sequences. We’ll put each into a vector using c(...): eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJodW1hbiAgIDwtIGMoXCJhXCIsXCJ0XCIsXCJjXCIsXCJnXCIsXCJhXCIsXCJ0XCIsXCJjXCIsXCJnXCIpXG5jaGltcCAgIDwtIGMoXCJhXCIsXCJ0XCIsXCJjXCIsXCJhXCIsXCJhXCIsXCJ0XCIsXCJjXCIsXCJhXCIpXG5nb3JpbGxhIDwtIGMoXCJhXCIsXCJhXCIsXCJhXCIsXCJhXCIsXCJhXCIsXCJhXCIsXCJhXCIsXCJhXCIpIn0= The sequences are each 8 bases long. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsZW5ndGgoZ29yaWxsYSkifQ== This means we’ll have 8 loci, or unique homologous positions, to consider. We can examine each pair of sequences and count up the number of differences between each one. This gives us a preliminary estimate of how diverged the sequences are. Humans and chimps have 2 differences, at the 4th and 8th loci eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyYmluZChodW1hbiwgY2hpbXApIn0= Chimps and gorillas have 4 differences (2nd, 3rd, 6th, and 7th loci): eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyYmluZChjaGltcCwgZ29yaWxsYSkifQ== Humans and gorillas have 6 differences (all but 1st and 6th different) eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyYmluZChodW1hbiwgZ29yaWxsYSkifQ== 38.4 Distance matrices Having counted up the number pairwise differences between each pair of sequences, we can represent this data as a genetic distance matrix like this. First, make the matrix using the matrix() command. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIG1ha2UgdGhlIG1hdHJpeFxuZGlzdF9tYXQgPC0gbWF0cml4KGRhdGEgPSBjKE5BLCBOQSwgTkEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMiwgTkEsTkEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNiwgNCwgTkEpLFxuICAgICAgICAgICAgICAgICAgbnJvdyA9IDMsIFxuICAgICAgICAgICAgICAgICAgYnlyb3cgPSBUKSJ9 Now, label the rows and columns. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIGxhYmVsIHRoZSBtYXRyaXhcbmNvbG5hbWVzKGRpc3RfbWF0KSA8LSBjKFwiSFwiLFwiQ1wiLFwiR1wiKVxucm93bmFtZXMoZGlzdF9tYXQpIDwtIGMoXCJIXCIsXCJDXCIsXCJHXCIpIn0= The final matrix looks like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIGxvb2sgYXQgdGhlIG91dHB1dFxuZGlzdF9tYXQifQ== ASIDE: Building matrices: Alternatively, we could make each row of the matrix into a vector and then stack them with rbind(). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIG1ha2UgdmVjdG9yc1xuaHVtYW4ucm93IDwtIGMoTkEsTkEsTkEpXG5jaGltcC5yb3cgPC0gYyggMixOQSxOQSlcbmdvcmlsbGEucm93IDwtIGMoNiw0LE5BKVxuXG4jIHN0YWNrIHZlY3RvcnMgYnkgcm93IHVzaW5nIHJiaW5kKClcbmRpc3RfbWF0IDwtIHJiaW5kKGh1bWFuLnJvdywgXG4gICAgICAgICAgICAgICAgICBjaGltcC5yb3csIFxuICAgICAgICAgICAgICAgICAgZ29yaWxsYS5yb3cpXG5cbiMgYWRkIG5hbWVzXG5zcHAubmFtZXMgPC0gYyhcImh1bWFuXCIsXCJjaGltcFwiLFwiZ29yaWxsYVwiKVxuY29sbmFtZXMoZGlzdF9tYXQpIDwtIHNwcC5uYW1lc1xucm93bmFtZXMoZGlzdF9tYXQpIDwtIHNwcC5uYW1lc1xuXG4jIGxvb2sgYXQgb3V0cHV0XG5kaXN0X21hdCJ9 End ASIDE Note that we leave the values on the diagonal of the matrix as NA because the genetic distance between humans and humans, or chimps and chimps, is 0 and isn’t helpful. A matrix like this is also symmetrical, where the lower triangle portion is the same as the upper portion We could build an upper triangular matrix like the one below if we wanted, but the convention is to use the lower. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIEFuIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4XG4jIyBtYWtlIGRhdGEgaW4gdmVjdG9yc1xuaHVtYW4ucm93IDwtIGMoTkEsMiw2KVxuY2hpbXAucm93IDwtIGMoIE5BLE5BLDQpXG5nb3JpbGxhLnJvdyA8LSBjKE5BLE5BLE5BKVxuXG4jIHN0YWNrIHdpdGggcmliaW5kKClcbmRpc3RfbWF0X3VwcGVyIDwtIHJiaW5kKGh1bWFuLnJvdywgXG4gICAgICAgICAgICAgICAgICAgICAgIGNoaW1wLnJvdywgXG4gICAgICAgICAgICAgICAgICAgICAgIGdvcmlsbGEucm93KVxuXG4jIGFkZCBuYW1lc1xuY29sbmFtZXMoZGlzdF9tYXRfdXBwZXIpIDwtIHNwcC5uYW1lc1xucm93bmFtZXMoZGlzdF9tYXRfdXBwZXIpIDwtIHNwcC5uYW1lcyJ9 Compare lower triangular matrix form of these data to the upper triangular for: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4OlxuZGlzdF9tYXRcblxuIyB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeFxuZGlzdF9tYXRfdXBwZXIifQ== In both matrices the distance from humans to gorillas is 6 differences, humans to chimps is 2, and chimps to gorillas is 4. Make sure you understand why this is true. Again, the lower triangular form is the form usually used. Because NA occurs in the entire top row and last column, people often omit it by dropping the row and column of all NAs. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkaXN0X21hdFstMSwgLTNdIn0= 38.5 From a distance matrix to phylogenetic tree These calculations imply that humans and chimps are more closely related (the sequences are made up, but this is true). Using data like this, [phylogenetic algorithms therefore cluster humans and chimps into a clade. In Newick Format this would be (H,C). Since we have just three taxa, we add G outside the first clade: ((H,C),G). We can plot a tree from Newick like this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIGRlZmluZSB0cmVlXG4jIyBOT1RFOiB0aGUgc3RyaW5nIGVuZHMgd2l0aCBhIHNlbWktY29sb24hXG5zdHIxPC0gYyhcIihHLChDLCBIKSApO1wiKVxuXG4jIyBjb252ZXJ0IGNoYXJhY3RlciBzdHJpbmcgdG8gdHJlZVxudHJlZTE8LWFwZTo6cmVhZC50cmVlKHRleHQ9c3RyMSlcblxuIyMgcGxvdCB0cmVlXG5wbG90LnBoeWxvKHRyZWUxLGVkZ2Uud2lkdGg9MiwgbWFpbiA9IFwiXCIpIn0= Newick format does not represent genetic distances and therefore the branch length of phylogenetic, only the clade structure and branching pattern of the tree. We can calculate branch lengths using the UPGMA algorithm. 38.6 Distance matrix in R from raw sequences To make a distance matrix in R from the original sequences we first need to put our original sequences into a matrix with the rbind() command. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteV9zZXFzIDwtIHJiaW5kKGh1bWFuLCBcbiAgICAgICAgICAgICAgICAgY2hpbXAsIFxuICAgICAgICAgICAgICAgICBnb3JpbGxhKSJ9 This is what it looks like eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteV9zZXFzIn0= We then need to do some fancy processing (this has to do with how the packages we’re going to use works, which is picky about formats because its optimized to accommodate real sequences which can be very very long). We’ll use the as.DNAbin() function. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJteV9zZXFzX2JpbiA8LSBhcGU6OmFzLkROQWJpbihteV9zZXFzKSJ9 We then can calculate the distance between each sequence in terms of the number (N) of mutations. This uses the dist.dna() function. We set the argument model = \"N\". This is the most basic and naive model of mutation and ignores the possibility of back mutations. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfZGlzdDAgPC0gYXBlOjpkaXN0LmRuYShteV9zZXFzX2JpbiwgbW9kZWwgPSBcIk5cIikifQ== This gives us a distance matrix eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfZGlzdDAifQ== Note that there is a subtle difference in how R looks at the matrix we made earlier with the matrix() command and this matrix. Them matrices have the same data, but slightly different formats. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkaXN0X21hdFxuc2VxX2Rpc3QwIn0= They also each have a different class eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJjbGFzcyhkaXN0X21hdClcbmNsYXNzKHNlcV9kaXN0MCkifQ== 38.7 Distance matrix in R from normal matrix Sometimes we already have a distance matrix computed that we want to enter directly into R. For example, perhaps it was reported in a paper and we want to explore the matrix on our own. In this case we can convert our normal matrix we made initially into a properly formatted distance matrix. This requires the base R as.dist() function. I’ll call this object “seq_dist_from_mat” to indicate that it came “from a matrix”. Note that I’m going to give it the full 3 x 3 matrix, dist_mat. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIGlucHV0IG1hdHJpeFxuZGlzdF9tYXRcblxuIyBjb3ZlcnQgdG8gZGlzdGFuY2UgbWF0cml4XG5zZXFfZGlzdF9mcm9tX21hdCA8LSBhcy5kaXN0KGRpc3RfbWF0KVxuXG4jIG5ldyBmb3JtYXRcbnNlcV9kaXN0X2Zyb21fbWF0In0= I’ll now compare the two ways of making the matrix: seq_dist0, which was build from the original sequences, and seq_dist_from_mat, which was built from the hand-entered matrix. First, let’s compare their structure eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfZGlzdDBcbnNlcV9kaXN0X2Zyb21fbWF0In0= Then check them out with is() and class() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJpcyhzZXFfZGlzdDApID09IGlzKHNlcV9kaXN0X2Zyb21fbWF0KVxuY2xhc3Moc2VxX2Rpc3QwKSA9PSBjbGFzcyhzZXFfZGlzdF9mcm9tX21hdCkifQ== Now I’ll confirm that that have the same content (Note that distance matrices are not indexed internally by rows and columns, but by the order that the values appear. The following code therefore returns only 3 responses, not 4.) eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfZGlzdDAgPT0gc2VxX2Rpc3RfZnJvbV9tYXQifQ== Cool, so we can make a matrix either from the raw sequences or from a hand-entered matrix. 38.8 UPGMA in R Once you have a distance matrix, UPGMA is easy in R with the upgma() function eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfdXBnbWEwIDwtIHVwZ21hKHNlcV9kaXN0MCkifQ== Now plot it with plot() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KHNlcV91cGdtYTAsIG1haW4gPSBcIk9yaWdpbmFsIGRhdGFcIikifQ== This doesn’t look too different than the phylogeny produced from Newick. Let’s play with the distance matrix to see what happens. First, make some more copies of the distance matrix eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXEuZGlzdDEgPC0gc2VxX2Rpc3QwXG5zZXEuZGlzdDIgPC0gc2VxX2Rpc3QwXG5zZXEuZGlzdDMgPC0gc2VxX2Rpc3QwIn0= The relationship between humans and chimps in in the upper left hand cell of the matrix. Internally, R is calling this the first cell of the matrix eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXEuZGlzdDFbMV0ifQ== Let’s increase and decrease this value eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXEuZGlzdDFbMV0gPC0gMjAgICAjY2hhbmdlIGZyb20gMiB0byAyMFxuc2VxLmRpc3QyWzFdIDwtIDAuNSAgI2NoYW5nZSBmcm9tIDIgdG8gMC41XG5zZXEuZGlzdDNbMV0gPC0gMC4wNSAjY2hhbmdlIGZyb20gMiB0byAwLjA1In0= Now we’ll build trees with our original matrix and the news ones to compare them. Note: We’ll make a grid of plots using some fancy-looking code par(mfrow = c(2,2), mar = c(2,2,2,2)). Don’t worry about what exactly this means; it just sets up some graphical parameters to make things look nice. I’ve also added some code to make the plot of the original data look a little different eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIHNldCB1cCBncmFwaGljYWwgcGFyYW1ldGVyc1xucGFyKG1mcm93ID0gYygyLDIpLCBtYXIgPSBjKDIsMiwyLDIpKVxuXG4jIGJ1aWxkIDFzdCB0cmVlIGFuZCBwbG90XG4jIyBidWlsZCB0cmVlXG5zZXFfdXBnbWEwIDwtIHVwZ21hKHNlcV9kaXN0MClcblxuIyMgcGxvdCwgaW4gdXBwZXIgbGVmdC1oYW5kIGNvcm5lclxucGxvdC5waHlsbyhzZXFfdXBnbWEwLCBcbiAgICAgICAgICAgbWFpbiA9IFwiT3JpZ2luYWwgZGF0YVwiLFxuICAgICAgICAgICBlZGdlLmNvbG9yID0gXCJkYXJrZ3JlZW5cIixcbiAgICAgICAgICAgZWRnZS53aWR0aCA9IDQpXG5cbiMgYnVpbGQgMm5kIHRyZWUgYW5kIHBsb3RcbnNlcS51cGdtYTEgPC0gdXBnbWEoc2VxLmRpc3QxKVxucGxvdChzZXEudXBnbWExLCBtYWluID0gXCJWZXJ5IGxvbmcgZGlzdGFuY2UgaHVtYW5zIHZzLiBjaGltcHMhXCIpXG5cbnNlcS51cGdtYTIgPC0gdXBnbWEoc2VxLmRpc3QyKVxucGxvdChzZXEudXBnbWEyLCBtYWluID0gXCJTaG9ydGVyIGRpc3RhbmNlIGh1bWFucyB2cy4gY2hpbXBzXCIpXG5cblxuc2VxLnVwZ21hMyA8LSB1cGdtYShzZXEuZGlzdDMpXG5wbG90KHNlcS51cGdtYTMsIG1haW4gPSBcIk11Y2ggc2hvcnRlciBkaXN0YW5jZSBodW1hbnMgdnMuIGNoaW1wcyFcIikifQ== 38.9 How UPGMA clustering works UPGMA and other clustering algorithms work by finding looking at a distance matrix and finding the two things that are closet together. Human and chimps are closest eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfZGlzdDAifQ== UPGAM therefore extracts the this minimum distance. We’ll extract it by hand using the min() function. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkLm1pbiA8LSBtaW4oc2VxX2Rpc3QwKSJ9 When two individual taxa are grouped into a clade the branch lengths are set at 1/2 the distance between them. So, the total distance is 2, so the branch lengths will be 1. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkLm1pbi8yIn0= We can confirm that this is correct by checking what R calculated via the upgma() function. We can access R’s calculations by looking at the object we saved the UPGMA output too eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfdXBnbWEwIn0= On its own this isn’t helpful. But what we can do is use the str() command to look under the hood of the object eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHIoc2VxX3VwZ21hMCkifQ== The output tells us there is something called edge.length associated with the seq_upgma0 object, and the smallest two values are 1. This looks promising, since edge is the math term for branches in a tree. Next, UPGMA builds a new matrix that replace the Human and Chimp columns with a combined Humans-chimp column. The algorithm then re-calculates the distance from this human-chimp clade to the remaining gorilla group The distance from this human-chimp group to gorillas is the average distance from humans to gorillas and chimps to gorillas. The original distance from humans to gorillas was 6, and the distance from chimps to gorillas was 4, as shown by the distance matrix eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzZXFfZGlzdDAifQ== Let’s store these values in R objects. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjZGlzdGFuY2UgaHVtYW5zIHRvIGdvcmlsbGFzXG5EaF9nIDwtIDZcblxuI2Rpc3RhbmNlIGNoaW1wcyB0byBnb3JpbGxhc1xuRGNfZyA8LSA0In0= Now, we’ll take the average of these two distance. The math written out in explicit detail is: eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJEaGNfZyA8LSAoRGhfZyoxICsgRGNfZyoxKS8oMSsxKVxuRGhjX2cifQ== The result is total distance between our new human-chimp clade and gorillas. 38.9.1 Challenge This new distance allows us to calculate the branch lengths for the rest of the tree. The branch length from the human-chimp (h-c) clade to the gorillas (g) is 1/2 half the distance we just calculated: Dhc_g/2 = 5/2 = 2.5 The remaining branch length is 2.5 - 1 = 1.5. See if you can figure out why this is done by sketching out the tree. These values match what is in the upgma object eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzdHIoc2VxX3VwZ21hMCkifQ== 38.10 Further information 38.10.1 General info A good, no-math overview of the general ideas of UPGMA is at this blog post Wikipedia provides a good overview with math that isn’t too daunting (though it could be improved). https://en.wikipedia.org/wiki/UPGMA 38.10.2 Worked examples: An excellent worked example is at this site. http://www.slimsuite.unsw.edu.au/teaching/upgma/ This example breaks down the math into basic steps, but there’s a lot of taxa so its still complicated. A worked example showing the limits of UPGMA is here: https://www.icp.ucl.ac.be/~opperd/private/upgma.html Another, dense-looking example is here: http://www.nmsr.org/upgma.htm Another worked example is https://www.mun.ca/biology/scarr/2900_UPGMA.htm 38.10.3 Additional notes: Some useful but terse notes are here: https://www.sequentix.de/gelquest/help/upgma_method.htm If you want to understand what the ultrametricity assumption is, check out this site (however, I don’t get hung up on this): https://www.sequentix.de/gelquest/help/explanation_of_the_term_ultrametric.htm Explanation of the convoluted meaning of “Un-weighted” is here https://www.mun.ca/biology/scarr/UPGMA_vs_WPGMA.html "],["tutorial-writing-functions-to-calculate-the-number-of-phylogenetic-trees.html", "Chapter 39 Tutorial: Writing functions to calculate the number of phylogenetic trees 39.1 Repliminaries 39.2 Concepts 39.3 Introduction 39.4 Number of rooted trees 39.5 Number of rooted trees in R 39.6 Functions in R 39.7 Function to calculate the number of possible phylogenetic trees 39.8 Vectorized inputs to functions 39.9 Adding conditional statements 39.10 Adding multiple conditional statements 39.11 Adding additional arguments 39.12 Assignment: _un_rooted trees 39.13 Assignment part 1 39.14 Assignment part 2", " Chapter 39 Tutorial: Writing functions to calculate the number of phylogenetic trees By Nathan Brouwer 39.1 Repliminaries 39.1.1 Functions factorial() seq() print() c() if() function() args() 39.2 Concepts 39.2.0.1 Biology Concepts: Number of possible phylogenetics trees 39.2.0.2 Programming concepts vectorized inputs to functions conditional statements Role of arguments in writing function Role of { and } in writing functions function source code functions with defaults functions with 1 arguments functions with 2 arguments 39.2.1 Vocab: 39.2.1.1 Programming vocab function function argument function default conditional statement 39.2.2 Packages: None 39.3 Introduction 39.4 Number of rooted trees The number of possible rooted phylogenetic trees is calculated using the equation below, where n is the number of taxa: \\(\\frac{(2*n-3)!}{2^{n-2} * (n-2)!}\\) 39.5 Number of rooted trees in R In R we take factorials using the factorial() function eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJmYWN0b3JpYWwoMylcbjMqMioxXG5cbmZhY3RvcmlhbCg0KVxuNCozKjIqMSJ9 We can re-write our text equation above as: factorial(2n-3)/(2^(n-2))*(factorial(n-2)) In R would be for n = 3 eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJuPC0zXG5mYWN0b3JpYWwoMipuLTMpLygoMl4obi0yKSkqZmFjdG9yaWFsKG4tMikpIn0= For n = 4 eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJuPC00XG5mYWN0b3JpYWwoMipuLTMpLygoMl4obi0yKSkqZmFjdG9yaWFsKG4tMikpIn0= All of the parentheses make this a bit nutty. Let me write this out as a separate numerator and denominator eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjbnVtZXJhdG9yXG5udW1lcmF0b3IgICA8LSBmYWN0b3JpYWwoMipuLTMpXG5cbiNkZW5vbWluYXRvclxuZGVub21pbmF0b3IgPC0gMl4obi0yKSpmYWN0b3JpYWwobi0yKVxuXG4jZGl2aXNpb25cbm51bWVyYXRvci9kZW5vbWluYXRvciJ9 39.6 Functions in R Functions in R have the general format eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJmdW5jdGlvbl9uYW1lIDwtIGZ1bmN0aW9uKGFyZ3VtZW50cyA9IC4uLil7XG4gb3V0cHV0IDwtIC4uLiAgIyBtYXRoIGV0YyBzYXZlZCB0byBvYmplY3RcbiBwcmludChvdXRwdXQpXG59In0= The function_name can be any valid R object name. The function function() creates the function. A function can have any number of arguments. Note that the arguments are enclosed in parentheses, and after the last ) there is a }. After all the stuff inside the function (e.g. the math we want the function to do) its finished with a }. 39.7 Function to calculate the number of possible phylogenetic trees We can set up a function to encapsulate this. We’ll call the function tree_count(). It has one argument (n), the number of taxa on the tree. We’ll set the default value of the argument to be n = 3 taxa. I use the function print() at the end so that the function actually returns output. If this isn’t included then nothing will be returned by the function. In the code below note the locations of the following things function name function-making command The opening parenthesis ( the argument the default the closing parenthesis ) the opening curly bracket { the math the print() command the closing curly bracket } eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjICAgICAgICAgICAgIFsgXWZ1bmN0aW9uLW1ha2luZyBjb21tYW5kXG4jICAgICAgICAgICAgIHxcbiMgWyBdRnVuY3Rpb24gfCAgICAgICAgIFsgXSBhcmd1bWVudFxuIyBuYW1lICAgICAgICB8ICAgICAgICAgIHxcbiMgfCAgICAgICAgICAgfCAgICAgICAgICB8ICAgIFsgXWNsb3NpbmcgXCIpXCJcbiMgfCAgICAgICAgICAgfCAgICAgICAgICB8ICAgICB8XG4jIHwgICAgICAgICAgIHwgWyBdIFwiKFwiICB8ICAgICB8ICBbIF1cIntcIlxuIyB8ICAgICAgICAgICB8ICAgICAgXFwgICB8ICAgICB8IC9cbnRyZWVfY291bnQgPC0gZnVuY3Rpb24oICBuID0gMyApeyAgICAjIG5vdGUgdGhlIFwifVwiXG4gIFxuICAjIFsgXSBtYXRoXG4gIG51bWVyYXRvciAgIDwtIGZhY3RvcmlhbCgyKm4tMylcbiAgZGVub21pbmF0b3IgPC0gMl4obi0yKSpmYWN0b3JpYWwobi0yKVxuICB0cmVlcyAgPC0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3IgXG4gIFxuICAjIFsgXSBwcmludCBvdXRwdXRcbiAgcHJpbnQodHJlZXMpXG4gIFxufSAgIyBlbmQgd2l0aCB0aGUgXCJ9XCJcbiNcXFxuIyBbIF0gXCJ9XCIifQ== Does it work? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50KClcbnRyZWVfY291bnQobiA9IDMpIn0= When working on a function its also good to check your output against against a source with the correct results. Tables with the number of trees per taxa are in many books, and also available here: https://en.wikipedia.org/wiki/Phylogenetic_tree We can view the function source code by just running the name of the function without any parentheses (or arguments) eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50In0= We can see just the arguments, and any defaults, for a function using args() eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJhcmdzKHRyZWVfY291bnQpIn0= ASIDE: The print() function is key. Make and run this function and see what happens. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjLyBkb24ndCBmb3JnZXQgdGhpcyFcbnRyZWVfY291bnRfYmFkIDwtIGZ1bmN0aW9uKG4gPSAzKXtcbiAgXG4gICMgbWF0aFxuICBudW1lcmF0b3IgICA8LSBmYWN0b3JpYWwoMipuLTMpXG4gIGRlbm9taW5hdG9yIDwtIDJeKG4tMikqZmFjdG9yaWFsKG4tMilcbiAgdHJlZXMgIDwtIG51bWVyYXRvciAvIGRlbm9taW5hdG9yIFxuICBcbn1cbiNcXCBkb24ndCBmb3JnZXQgdGhpcyFcblxudHJlZV9jb3VudF9iYWQoKSJ9 END ASIDE How rapidly does the number of possible trees grow? eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50KG4gPSAzKVxudHJlZV9jb3VudChuID0gNClcbnRyZWVfY291bnQobiA9IDUpXG50cmVlX2NvdW50KG4gPSA2KSJ9 One of my favorite example data sets has 11 taxa. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50KG4gPSAxMSkifQ== This number grows very rapidly. According to Bianconi et al (2012) there are 3.72*10^13 cells in the body (37,200,000,000,000, or 3.72e13). eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIyMgd2l0aCBhbGwgdGhlIHplcm9zXG4zNzIwMDAwMDAwMDAwMFxuXG4jIyMgXCJlXCIgc2NpZW50aWZpYyBub3RhdGlvblxuMy43MmUxM1xuXG4zLjcyZSsxMyJ9 If we put 14 taxa on a tree there are this many possible trees eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50KG4gPSAxNCkifQ== If we put 15 taxa on the tree eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50KG4gPSAxNSkifQ== 39.8 Vectorized inputs to functions One of R’s most powerful features is that it works on vectors. I want to make a plot of the the number of possible trees for 3 to 11 taxa. I can make a vector any way I chose eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjdHlwaW5nIG91dCBhbGwgbnVtYmVyc1xubi50YXhhIDwtIGMoMyw0LDUsNiw3LDgsOSwxMSlcblxuIyB1c2luZyBzZXEgd2l0aCBhcmd1bWVudHMgc3BlbGxlZCBvdXRcbm4udGF4YSA8LSBzZXEoZnJvbSA9IDMsdG8gPSAxMSxieSA9IDEpXG5cbiN1c2luZyBzZXEgdy9vIGFyZ3VtZW50c1xubi50YXhhIDwtIHNlcSgzLCAxMSwgMSlcblxuI3Nob3J0Y3V0c1xubi50YXhhIDwtIGMoMzoxMSlcbm4udGF4YSA8LSAzOjExIn0= I can then put the vector as an input into my function eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50KG4gPSBuLnRheGEpIn0= I can save this output to a vector eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJuLnRyZWVzIDwtIHRyZWVfY291bnQobiA9IG4udGF4YSkifQ== And plot things. type = “b” plots points and a line. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJwbG90KG4udHJlZXMgfiBuLnRheGEsIHR5cGUgPSBcImJcIikifQ== 39.9 Adding conditional statements The equation above is only valid for 2 or more taxa. If we put in a lower number the result doesn’t make sense eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50KG4gPSAwKVxudHJlZV9jb3VudChuID0gMSkifQ== Only when we put in 2 or more taxa does it work eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50KG4gPSAyKVxudHJlZV9jb3VudChuID0gMykifQ== Additionally, we can input non-integers and get a result. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50KG4gPSAzLjUpIn0= We can add a conditional statement so that if 0 or 1 are input then an warning is given. Conditional statements test a logical condition which, if false, can be used to throw a warning, error, etc. I’ll use the conditional statement if(n &lt; 3) to test if the number of taxa entered into my tree_count() function is going to be valid. The warning() function allows me to remind the user of the function of what they should enter. Note that the conditional statement has the logical operation in parentheses, eg (n &lt;2), and then what to do if n &lt; 2 is true in curly brackets eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50MiA8LSBmdW5jdGlvbihuID0gMyl7XG4gIFxuICAjIGNvbmRpdGlvbmFsIHN0YXRlbWVudFxuICAjIyBpcyBuIGEgdmFsaWQgbnVtYmVyIGZvciB1c2luZyBpbiB0aGlzIGVxdWF0aW9uP1xuICAjIyBpZiBpdCBpcyBOT1QsIHRocm93IGEgd2FybmluZ1xuICAjIyBpZiBpdCBpcyBhIHZhbGlkIG51bWJlciwgc2tpcCBldmVyeXRoaW5nIGluIHRoZSBcbiAgIyMgeyB9IGFuZCBnbyB0byB0aGUgbWF0aFxuICBpZihuIDwgMyl7XG4gICAgXG4gICAgIyB3YXJuaW5nIGlmIHRlc3QgaXMgVFJVRVxuICAgIHdhcm5pbmcoXCJUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdmFsaWQgZm9yIDIgb3IgbW9yZSB0YXhhLlwiKVxuICB9XG4gIFxuICAjIElmIHRlc3QgaXMgRkFMU0UgKG4gPSAzIG9yIG4gPiAzKVxuICAjIyBjb250aW51ZSB3aXRoIHRoZSBtYXRoXG4gIG51bWVyYXRvciAgIDwtIGZhY3RvcmlhbCgyKm4tMylcbiAgZGVub21pbmF0b3IgPC0gMl4obi0yKSpmYWN0b3JpYWwobi0yKVxuICB0cmVlcyAgPC0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3IgXG4gIFxuICAjIHByaW50IHRoZSByZXN1bHRzXG4gIHByaW50KHRyZWVzKVxufSJ9 Now we can test this eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50MihuID0gMClcbnRyZWVfY291bnQyKG4gPSAxKSJ9 39.10 Adding multiple conditional statements The tree_count2() function above is still throwing error messages because even though it doesn’t work with n &lt;2, and even though its now giving us a warning, its still dong the math. We can add a second conditional statement around the math to remedy this. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50MmIgPC0gZnVuY3Rpb24obiA9IDMpe1xuICBcbiAgIyBjb25kaXRpb25hbCBzdGF0ZW1lbnQgd2l0aCBpZigpey4uLn1cbiAgIyMgdGhlIGNvbmRpdGlvbjogaWYgbiA8IDIsIFxuICBpZihuIDwgMil7XG4gICAgXG4gICAgIyB0aGUgcmVzdWx0IFxuICAgIHdhcm5pbmcoXCJUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdmFsaWQgZm9yIDIgb3IgbW9yZSB0YXhhLlwiKVxuICAgIFxuICB9XG4gIFxuICAjZG8gdGhlIG1hdGhcbiAgaWYobiA+IDIpe1xuICAgIG51bWVyYXRvciAgIDwtIGZhY3RvcmlhbCgyKm4tMylcbiAgZGVub21pbmF0b3IgPC0gMl4obi0yKSpmYWN0b3JpYWwobi0yKVxuICB0cmVlcyAgPC0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3IgXG4gIFxuICAjcmV0dXJuIHRoZSByZXN1bHRcbiAgcmV0dXJuKHRyZWVzKVxuICB9XG4gIFxufSJ9 Now we just get the warning we wrote but nothing else eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50MmIoMClcbnRyZWVfY291bnQyYigxKSJ9 39.11 Adding additional arguments Perhaps we want provide the option of always printing the results in scientific notation. We can another argument to our tree_count() function called “format”. If the argument is set to “sci”, “scientific” or “e”, the function will change the options for how numbers are printed. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50IDwtIGZ1bmN0aW9uKG4gPSAzLCAgICAgICAgICAgICAgICAjIDFzdCBhcmd1bWVudDogbnVtYmVyIG9mIHRheGFcbiAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gXCJzdGFuZGFyZFwiKXsgIyAybmQgYXJndW1lbnQ6IGZvcm1hdFxuICBcbiAgIyBjb25kaXRpb25hbCBzdGF0ZW1lbnQgd2l0aCBpZigpey4uLn1cbiAgIyMgdGhlIGNvbmRpdGlvbjogaWYgbiA8IDIsIFxuICBpZihuIDwgMil7XG4gICAgXG4gICAgIyB0aGUgcmVzdWx0IFxuICAgIHdhcm5pbmcoXCJUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdmFsaWQgZm9yIDIgb3IgbW9yZSB0YXhhLlwiKVxuICB9XG4gIFxuICAjIHRoZSBtYXRoXG4gIG51bWVyYXRvciAgIDwtIGZhY3RvcmlhbCgyKm4tMylcbiAgZGVub21pbmF0b3IgPC0gMl4obi0yKSpmYWN0b3JpYWwobi0yKVxuICB0cmVlcyAgPC0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3IgXG4gIFxuICAjIGFub3RoZXIgY29uZGl0aW9uYWwgc3RhdGVtZW50OlxuICAjIyBzZXQgZm9ybWF0dGluZ1xuICBpZihmb3JtYXQgJWluJSBjKFwic2NpXCIsXCJzY2llbnRpZmljXCIsXCJlXCIpKXtcbiAgICBvcHRpb25zKHNjaXBlbiA9IC0yLGRpZ2l0cyA9IDMpXG4gIH1cbiAgXG4gICMgcHJpbnQgdGhlIG91dHB1dFxuICBwcmludCh0cmVlcylcbiAgXG4gICMgcmUtc2V0IHRoZSBmb3JtYXR0aW5nXG4gIG9wdGlvbnMoc2NpcGVuID0gMCxkaWdpdHMgPSA3KVxufSJ9 Check out the source code eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50In0= Check out the agruements eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJhcmdzKHRyZWVfY291bnQpIn0= Check the output eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50KG4gPSAxMClcbnRyZWVfY291bnQobiA9IDEwLCBmb3JtYXQgPSBcInNjaVwiKVxudHJlZV9jb3VudChuID0gMTAsIGZvcm1hdCA9IFwic2NpZW50aWZpY1wiKVxudHJlZV9jb3VudChuID0gMTAsIGZvcm1hdCA9IFwiZVwiKSJ9 39.12 Assignment: _un_rooted trees We often don’t root phylogenetic trees. This reduces the number of possible trees and is described by the equation Text (note: this had a typo in previous version of assignmen!) (2n-5)!/(2^(n-3))(n-3)! Rendered: \\(\\frac{(2*n-5)!}{2^{n-3} * (n-3)!}\\) 39.13 Assignment part 1 Modify the equation used above to work for unrooted trees. Call the function tree_count_unrooted() Compare your results to http://carrot.mcb.uconn.edu/mcb396_41/tree_number.html You can use the simplest form of the function which doesn’t have any additional argument, eg eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjTk9URTogdGhpcyBpcyBmb3IgYSBST09URUQgVFJFRVxuIyMgY2hhbmdlIG1hdGggdG8gYmUgZm9yIFVOLVJPT1RFRCBUUkVFXG4jIyBjaGFuZ2UgbmFtZSBvZiBmdW5jdGlvbiB0byB0KClyZWVfY291bnRfdW5yb290ZWRcbnRyZWVfY291bnRfcm9vdGVkIDwtIGZ1bmN0aW9uKG4gPSAzKXtcbiAgbnVtZXJhdG9yICAgPC0gZmFjdG9yaWFsKDIqbi0zKVxuICBkZW5vbWluYXRvciA8LSAyXihuLTIpKmZhY3RvcmlhbChuLTIpXG4gIHRyZWVzICA8LSBudW1lcmF0b3IgLyBkZW5vbWluYXRvciBcbiAgcmV0dXJuKHRyZWVzKVxufVxuXG4jQWx3YXlzIHRlc3QhXG50cmVlX2NvdW50X3Jvb3RlZCg0KSJ9 39.13.1 Part 1 answer eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50X3Vucm9vdGVkIDwtIGZ1bmN0aW9uKG4gPSAzKXtcbiAgbnVtZXJhdG9yICAgPC0gZmFjdG9yaWFsKDIqbi01KVxuICBkZW5vbWluYXRvciA8LSAyXihuLTMpKmZhY3RvcmlhbChuLTMpXG4gIHRyZWVzICA8LSBudW1lcmF0b3IgLyBkZW5vbWluYXRvciBcbiAgcmV0dXJuKHRyZWVzKVxufSJ9 CHeck against eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50X3Vucm9vdGVkKG4gPSAzKVxudHJlZV9jb3VudF91bnJvb3RlZChuID0gNClcbnRyZWVfY291bnRfdW5yb290ZWQobiA9IDUpIn0= Compare rooted and unrooted eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50X3Vucm9vdGVkKG4gPSA1KVxudHJlZV9jb3VudF9yb290ZWQobiA9IDUpIn0= 39.14 Assignment part 2 Create a function that will work for rooted OR unrooted trees. Do this by adding an additional argument like type = “rooted” and conditional statements like if(type == “rooted”){ #do this } if(type == “unrooted”){ #do something else } Again, you can use the simplest form of the argument. (Note: there was a typo in the original version of this where there were missing quotation marks around “rooted” and “unrooted” eg \"rooted, so if you copy and pasted the code - which is what I would’ve done! - it wouldn’t have worked). 39.14.1 Answer here is one way this could be written. eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50MyA8LSBmdW5jdGlvbihuID0gMywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJyb290ZWRcIil7XG4gIFxuaWYodHlwZSA9PSBcInJvb3RlZFwiKXtcbiAgI3J1biByb290ZWQgdnMuIG9mIHRoZSBjYWxjdWxhdGlvblxuICBudW1lcmF0b3IgICA8LSBmYWN0b3JpYWwoMipuLTMpXG4gIGRlbm9taW5hdG9yIDwtIDJeKG4tMikqZmFjdG9yaWFsKG4tMilcbiAgdHJlZXMgIDwtIG51bWVyYXRvciAvIGRlbm9taW5hdG9yIFxuICB9XG5cbmlmKHR5cGUgPT0gXCJ1bnJvb3RlZFwiKXtcbiAgI3Vucm9vdGVkIHZlcnNpb24gb2YgdGhlIGVxdWF0aW9uXG4gIG51bWVyYXRvciAgIDwtIGZhY3RvcmlhbCgyKm4tNSlcbiAgZGVub21pbmF0b3IgPC0gMl4obi0zKSpmYWN0b3JpYWwobi0zKVxuICB0cmVlcyAgPC0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3IgXG4gIHJldHVybih0cmVlcylcbiB9XG4gIFxucmV0dXJuKHRyZWVzKSAgXG5cbn0ifQ== Check the answer eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0cmVlX2NvdW50MyhuPSA1LCB0eXBlID0gXCJyb290ZWRcIilcbnRyZWVfY291bnQzKG49IDUsIHR5cGUgPSBcInVucm9vdGVkXCIpIn0= We can plot rooted vs unrooted eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJuLnRheGEgPC0gc2VxKDMsOSwxKVxueS5yb290ZWQgPC0gdHJlZV9jb3VudDMobj0gbi50YXhhLCB0eXBlID0gXCJyb290ZWRcIilcbnkudW5yb290ZWQgPC0gdHJlZV9jb3VudDMobj0gbi50YXhhLCB0eXBlID0gXCJ1bnJvb3RlZFwiKVxuXG5wbG90KHkucm9vdGVkIH4gbi50YXhhLCB0eXBlID0gXCJiXCIpXG5wb2ludHMoeS51bnJvb3RlZCB+IG4udGF4YSwgdHlwZSA9IFwiYlwiLCBjb2wgPSAzLCBsdHkgPSAyKSJ9 "]]
