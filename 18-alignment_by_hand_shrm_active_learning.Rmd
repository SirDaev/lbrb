---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Alignment by eye in R

**By** Nathan Brouwer

## Preliminaries

### Packages

```{r}
library(compbio4all)
library(Biostrings)
```

### Data

```{r}
data("BLOSUM62")
```




Let's do an alignment between two parts of a shroom protein.  We'll look at part of the ASD2 domain of Shroom 3.  We'll look at human shroom (hShrm3) and call this the "Query" sequence.  We'll use mouse shroom (mShrm3) as the "subject" or "target".  (The accession number for human shroom 3 is NP_065910.3)

```{r}
hShrm3  <- "EPEREPEWRDRPGSP"

mShrm3   <- "EAEREASWSEDRPGT"
```


Use nchar() to see how many characters are in them

```{r}



```


We can make a little matrix and look at how they align using the rbind() function, which stands for "row bind"

```{r}
rbind(hShrm3,
      mShrm3)
```

Assign this to an object called shrms

```{r}
shrms <- rbind(hShrm3, mShrm3)

```


What type of object is shrms?

```{r}



```

How big is it?  See if you can guess first before using R to check

```{r}


```


If we want to do an alignment by eye it would help if instead of having all the letters stuck together they were separated.  We would do this by hand but it would require a lot of typing:

```{r}
hShrm3_alt <- c("E","P","E","R","E","P","E","W","R","D","R","P","G","S","P")

mShrm3_alt <- c("E","A","E","R","E","A","S","W","S","E","D","R","P","G","T")
```



One thing that is annoying about R is that vectors have "length" but no dimension.  Compare the output of the length() command and dim() command when called on hShrm3_alt
```{r}
# run length()


# run dim()



```


Use is,  is.vector, length, is.character, and n.char on hShrm3 and hShrm3_alt.  How is hShrm3 ("EPEREPEWRDRPGSP") different from hShrm3_alt?  Can you figure out why nchar() is doing what its doing?
```{r}
# run is() on hShrm3 AND hShrm3_alt


# run is.vector on hShrm3 AND hShrm3_alt


# do this for the rest of the commands



```


Typing all this stuff out is a pain.  Instead of typing all those commas to make hShrm3_alt we could take hShrm3 and have *R* do the work for us.  Lots of people work with **character data** (data make up of alphabetic and other characters that can NOT be interpreted as numbers) so there are lots of functions for manipulating characters. We'll use the `strsplit()` function.

If we just all strsplit() on the hShrm3 object we get something a little annoying.  
```{r}
strsplit(hShrm3, split = "")
```

Note that the output above is on too lines, and the first line is `[[1]]`.

Ok, what's up?

Assign the thing we just made to an object called hShrm3_vec for "hShrm3 vector".

```{r}
hShrm3_vec <- strsplit(hShrm3, split = "")

```

Now figure out what the heck it "is":
```{r}


```

If you used the right command to figure out what it **is** (hint) the first thing you see is "list."  Lists are rather complex **data structures** in R because they aren't the kind of thing you run in to if you just have experience working in a spreadsheet.  Lists allow you to make collections of different R objects.  For now you just need to know that they exist; we'll run into them again later.  For now, we want to get rid of this listy-ness of our R object.  We can do this with the function unlist().  Call unlist() on your hShrm3_vec object and re-assign it to the same object hShrm3_vec, eg, run 
hShrm3_vec <- unlist(hShrm3_vec)


```{r}
hShrm3_vec <- unlist(hShrm3_vec)
```


Now we need to repeat these steps for the mouse shroom sequence.  
```{r}
# split up mShrm3 with strsplit()
mShrm3_vec <- strsplit(mShrm3, split = "")

# unlist it with unlist()
mShrm3_vec <- unlist(mShrm3_vec)

```


Something that is useful once you get good at reading R code is that you can wrap functions within functions.  So instead of doing this in separate steps I could just do this:

```{r}
hShrm3_vec <- unlist(strsplit(hShrm3, split = ""))
mShrm3_vec <- unlist(strsplit(mShrm3, split = ""))
```

Before moving on confirm that these two factors are the same length.  If they aren't R will get angry
```{r}
# length of hShrm3_vec

# length of mShrm3_vec

```


Now let's make a little matrix so we can think about aligning these sequences.  The rbind() function binds two rows together into a matrix.

```{r}
rbind(hShrm3_vec, mShrm3_vec)
```


For what we want to do next aligning them vertically will actually work better.  We can align them as columns using cbind(), which stands for "column bind"

```{r}
cbind(hShrm3_vec, mShrm3_vec)
```


Save that to an object called shrm

```{r, echo = T}
cbind(hShrm3_vec, mShrm3_vec)
```


```{r, echo = T}
shrm <- cbind(hShrm3_vec, mShrm3_vec)
```

```{r}


```


The most basic way to do an alignment is to determine the which bases are identical and to score those as 1, and anything that is mismatched score as 0.  From this you can determine **percent identity**. 

A handy way to do this quickly in R is to use the ifelse() command.  What you can do is tell it to do this: "IF a base in the first sequence the same as the aligned base in the second sequence, return a value of 1, ELSE return a value of 0."

I'll do a really transparent example. First, let me make some very simple objects with just a single letter in them.

```{r}
aa1 <- "A"
aa2 <- "A"
aa3 <- "W"
```


What kind of object have I just made? Use is, is.vector, length, dim, and is.matrix.  Can you understand why you get the results that you do?
```{r}


```

Now let me use ifelse().  First, let me check if aa1 is the same as aa2, an if they R, return a value of 1, else return a value of 0
```{r}
ifelse(aa1 == aa2, yes =  1, no = 0)
```

The first part of the function asks a true/false question: is aa1 the same as aa2?  Note that it is TWO equals signs

This is a **logical comparison** or **logical test** in R. It would work on its own outside of ifelse, like this:

```{r}
aa1 == aa2
```

Now compare aa1 and aa2.  First try the logical test
```{r}


```


Now try the ifelse() command

```{r}



```


Something that is very hand in R is that it can process things in a series. First, let's turn our single amino acids into some sequences.

```{r}

seq1 <- c(aa1, aa2, aa3)
seq2 <- c(aa3, aa2, aa1)

```

Do you know what kind of R object we just made?  Run an appropriate check

```{r}


```


Now let's compare these two sequences. First a logical comparison. Can you tell what this code is doing?
```{r}

seq1 == seq2

```

What is going on here?  It might help to line everything up using rbind() to make a little matrix. First, save the output of the logical comparison to an R object

```{r}

identical <- seq1==seq2

```


Now stack the two sequences and the logical comparison into a matrix
```{r}

rbind(seq1, seq2, identical)

```


We can also run ifelse() on the two sequences
```{r}
ifelse(seq1 == seq2, yes = 1, no = 0)
```

Save this output to an object called align.score for "alignment score"

```{r, echo = T}
align.score <- ifelse(seq1 == seq2, yes = 1, no = 0)
```


```{r}



```


Now stack everything up into a matrix using rbind

```{r}

rbind(seq1, seq2, identical, align.score )


```


Now let's try this on our shroom vectors.  First, do a logical comparison of the hShrm3_vec vector and the mShrm3_vec vector.  Remember there are two equals signs (==)

```{r}


```


Now use ifelse() to assign a 1 to a match and a 0 to a mismatch.

```{r}



```


Again, can you describe what's going on here?

Again we can make a little matrix with rbind(). I'm going to embed the ifelse() function within rbind(); this might be a little dense but see if you can figure out what each separate command is.

```{r}
rbind(hShrm3_vec, 
      mShrm3_vec,
      identical = hShrm3_vec == mShrm3_vec,
      score= ifelse(hShrm3_vec == mShrm3_vec,yes = 1, no = 0 ))
```

If we want the total score we can assign the results of ifelse() to an object
```{r}
scores <-ifelse(hShrm3_vec == mShrm3_vec,yes = 1, no = 0 )
```

I can then total up the score with sum()

```{r}
sum(scores)
```


I can easily call up the number of amino acids with length().  Do that below

```{r}


```


Percent identity is a common statistic when comparing sequences.  If my score is 5 and my total number of residues is 15 my percent identity is:
```{r}

5/15

```


I can do this directly on the objects like this

```{r}

sum(scores)/length(scores)

```



We can do this sort of scoring on sequences in a matrix or data frame.  Remember that we made a matrix called shrm with our two sequences in it. Matrices and dataframes are very similar, but its usually easier to work with dataframes.  We can convert the matrix to a dataframe like this

```{r}
shrm <- data.frame(shrm, stringsAsFactors = F)
```


There's a lot relate to the "stringsAsFactors = F"; basically it makes sure we are working with raw character data.


Calling summary() on the shrm dataframe can confirm that its character data:

```{r}
summary(shrm)
```


You can call up the human shroom 3 columns with this code: shrm[, "hShrm3_vec"]. try it below

```{r}


```

How would you call up the other column with mouse shroom?

```{r}



```


One tricky thin about R is that you can access the column of dataframes in more than one way.  You can get the first column also using the dollar sign

```{r}
shrm$hShrm3_vec
```

Note that even though we're calling a column, R prints it out left to right like a row.

We can do a logical comparisons of the two columns like this:
```{r}

shrm[, "hShrm3_vec"] == shrm[,"mShrm3_vec"]

```


Can you re-write this using the dollar sign notation?  Try it below

```{r}



```


Now let's use ifelse() on these two columns
```{r}

ifelse(shrm[, "hShrm3_vec"] == shrm[,"mShrm3_vec"], yes = 1, no = 0)

```


Rewrite the code above using dollar sign notation

```{r}



```


We can add this information to the dataframe like this


```{r}
shrm$identical <- ifelse(shrm[, "hShrm3_vec"] == shrm[,"mShrm3_vec"], yes = 1, no = 0)
```


Now what do we have?  Call up the dataframe shrm we just made:

```{r}



```



Now call summary on it.  What types of data are each variable?

```{r}
 

```



Comparing an alignment to a scoring matrix by hand is a lot of work, so there's a function called `score_alignment()` in the `compbio4all` package which can do basic comparisons.  The function has the following arguments

* seq.df = A dataframe with aligned sequences in columns
* seq1 = the name of the column with a sequence in it; name must be in quotes
* seq2 = the other, aligned sequence
* gap.penalty = -10

Running the function returns a dataframe with a new column called "score".

```{r}

shrm <-score_alignment(seq.df = shrm, 
                seq1=  "hShrm3_vec",  #note the quotation marks
                seq2 = "mShrm3_vec",
                sub.mat = BLOSUM62,
                gap.penalty =  -10)
```



We can call the sum() function on the score column of the shrm dataframe to calculate the overall score for the alignment.  This is a metric that tells use how good the alignment is based on the number of identical residues in the sequence, how different any mutations are from the original residue, and how many gaps there are.
```{r}
sum(shrm$score)
```



I happen to know that we can make this alignment better if we add a gap.  I'll do it by hand because I don't have a function yet to do it automatically.  I'll put a gap into the human shroom 3 sequence (hShrm3_alt) after the "W" that's about in the middle of the sequence.


```{r}

hShrm3_alt  <- c("E","P","E","R","E","P","E","W","-","R","D","R","P","G","S","P")

```


Using an appropriate function, confirm that the insertion has made the sequence longer (hint: its not nchar)
```{r}


```

Now we'll do the other sequence.  To make this work we need to add an insertion to the end of the mouse sequence (mShrm3_alt) so that the two sequences are the same length.
```{r}

mShrm3_alt  <- c("E","A","E","R","E","A","S","W","S","E","D","R","P","G","T","-")

```


Again, check that this sequence is longer than it was before

```{r}


```


A handy trick is to do a **logical comparison** to check that the two vectors are the same.  Run the following code and see if you can interpret what is going on.  Remember that the double equals sign == carries out a logical comparison that returns TRUE if two values are the same.

```{r}

length(hShrm3_alt) == length(mShrm3_alt)

```



Now, for a challenge, see if you can figure out what's going on here
```{r}

hShrm3_alt == mShrm3_alt

```



It might be easier if we stack thing in to a little matrix with rbind().  I've put a lot of stuff in the rbind() function but see if you can figure it out.

```{r}

rbind(hShrm3_alt = hShrm3_alt,
      mShrm3_alt = mShrm3_alt,
      identical = hShrm3_alt == mShrm3_alt)

```


Now let's compare these two sequences by scoring them.  First, we'll put them into a dataframe using data.frame(). We'll call the object shrm.gap.

```{r}

shrm.gap <-data.frame(hShrm3_alt,
                      mShrm3_alt, 
                      stringsAsFactors = F)

```


Run an appropriate function to confirm that this is a dataframe
```{r}


```


Check what the size of the dataframe is:
```{r}



```


Now look at the full dataframe
```{r}



```

Now run a function to just look at the top of the dataframe:
```{r}



```



Run a function to just look at the bottom of the dataframe
```{r}



```



Ok, we have a sense of what we're working with.  Let's calculate the score
```{r}

shrm.gap <- score_alignment(shrm.gap, 
                     seq1=  "hShrm3_alt",
                     seq2 = "mShrm3_alt",
                     sub.mat= BLOSUM62,
                     gap.penalty =-10)

```


Look at the dataframe and make sure it looks right.  Note that each gap ("-") has a score of 10 as defined by the gap.penalty.
```{r}



```


Now calculate the total score

```{r}
  
sum(shrm.gap$score)

```


There is one issue here which I haven't yet resolved.  When alignment are scored we take into account two things: the creation of a gap (yes there is a gap there) and its length (how long it it).

Each gap that get's created gets scores -10 for occurring and -4 for each insertion in the gap.  So a gap of 1 insertion ("-") gets score -10 + -4

```{r}

-10 + -4

```


A gap of 2 insertions ("--") gets a score of

```{r}

(-10 + -4) + -4

```

A gap of 3 insertions ("---") gets a score of

```{r}

(-10 + -4) + -4 + -4

```


Our alignment has two separate insertions, one in the middle and one on the end.  In the logic of alignment this is two separate insertions each of length one, so each one gets scored -10 + -4 = -14


I haven't written a function yet to implement counting up the length of the insertions, so the score returned by score_alignment() is not correct.  Based on the description above, what is the correct score?  Write out R code using sum() to calculate the correct score.



```{r}



```





