---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Phylogenetic trees using the UPGMA clustering algoirthm

**By**: Nathan Brouwer

## Introduction

**UPGMA** is a method for constructing **phylogenetic trees** using **genetic distances**.  It is an old, outmoded method that is rarely ever used any more for building final versions of trees.  Instead of UPGMA, the **neighbor-joining** (NJ) algorithm is used when a distance-based phylogeny is made.  UPGMA's relative simplicity, however, makes it a useful starting point for thinking about how to construct phylogenetic trees and code up algorithms to build them.  UPGMA has also been used in the past in statistics, machine learning, transcriptomics, and community ecology as a general **clustering algorithm** and so is a useful starting point when understanding current algorithms in those fields.



## Preliminaries

```{r, message = FALSE}
# Potentially new packages
## install.packages("phangorn")
## install.packages("ape")

library(ape)
library(phangorn)
```


### Vocab

* matrix, matrices
* diagonal of matrix
* symmetrical matrix
* lower triangle of matrix
* Newick format
* character string
* function, argument
* branch, edge, clade



### General R functions
* `c()`
* `matrix()`
* colnames, rownames
* cbind, rbind
* class
* as.dist()
* par
* min
* str

### Specific functions
* phangorn::phangorn()
* ape::read.tree
* ape::as.DNAbin
* ape::dist.dna()

## Sequence comparisons

Let's consider three short, hypothetical DNA sequences.  We'll put each into a **vector** using `c(...)`:
```{r}
human   <- c("a","t","c","g","a","t","c","g")
chimp   <- c("a","t","c","a","a","t","c","a")
gorilla <- c("a","a","a","a","a","a","a","a")
```

The sequences are each 8 bases long.  
```{r}
length(gorilla)
```

This means we'll have 8 **loci**, or unique **homologous positions**, to consider.

We can examine each pair of sequences and count up the number of differences between each one.  This gives us a preliminary estimate of how **diverged** the sequences are.  
Humans and chimps have 2 differences, at the 4th and 8th loci
```{r}
rbind(human, chimp)
```

Chimps and gorillas have 4 differences (2nd, 3rd, 6th, and 7th loci):
```{r}
rbind(chimp, gorilla)
```


Humans and gorillas have 6 differences (all but 1st and 6th different)
```{r}
rbind(human, gorilla)
```

## Distance matrices

Having counted up the number **pairwise differences** between each pair of sequences, we can represent this data as a genetic **distance matrix** like this.

First, make the matrix using the `matrix()` command.
```{r}
# make the matrix
dist_mat <- matrix(data = c(NA, NA, NA,
                            2, NA,NA,
                            6, 4, NA),
                  nrow = 3, 
                  byrow = T)
```

Now, label the rows and columns.
```{r}
# label the matrix
colnames(dist_mat) <- c("H","C","G")
rownames(dist_mat) <- c("H","C","G")

```

The final matrix looks like this
```{r}
# look at the output
dist_mat
```


**ASIDE: Building matrices**:

Alternatively, we could make each row of the matrix into a vector and then stack them with `rbind()`.
```{r}
# make vectors
human.row <- c(NA,NA,NA)
chimp.row <- c( 2,NA,NA)
gorilla.row <- c(6,4,NA)

# stack vectors by row using rbind()
dist_mat <- rbind(human.row, 
                  chimp.row, 
                  gorilla.row)

# add names
spp.names <- c("human","chimp","gorilla")
colnames(dist_mat) <- spp.names
rownames(dist_mat) <- spp.names

# look at output
dist_mat
```

**End ASIDE**

Note that we leave the values on the **diagonal** of the matrix as `NA` because the genetic distance between humans and humans, or chimps and chimps, is 0 and isn't helpful.  A matrix like this is also **symmetrical**, where the **lower triangle** portion is the same as the upper portion  We could build an **upper triangular matrix** like the one below if we wanted, but the convention is to use the lower.

```{r}
# An upper triangular matrix
## make data in vectors
human.row <- c(NA,2,6)
chimp.row <- c( NA,NA,4)
gorilla.row <- c(NA,NA,NA)

# stack with ribind()
dist_mat_upper <- rbind(human.row, 
                       chimp.row, 
                       gorilla.row)

# add names
colnames(dist_mat_upper) <- spp.names
rownames(dist_mat_upper) <- spp.names
```

Compare lower triangular matrix form of these data to the upper triangular for: 
```{r}
# lower triangular matrix:
dist_mat

# upper triangular matrix
dist_mat_upper
```

In both matrices the distance from humans to gorillas is 6 differences, humans to chimps is 2, and chimps to gorillas is 4.  Make sure you understand why this is true.

Again, the lower triangular form is the form usually used.  Because `NA` occurs in the entire top row and last column, people often omit it by dropping the row and column of all NAs.

```{r, echo = T}
dist_mat[-1, -3]
```


## From a distance matrix to phylogenetic tree

These calculations imply that humans and chimps are more closely related (the sequences are made up, but this is true). Using data like this, **[phylogenetic algorithms**  therefore cluster humans and chimps into a **clade**.  In **Newick Format** this would be (H,C).

Since we have just three taxa, we add G outside the first clade: ((H,C),G).

We can plot a tree from Newick like this

```{r}
# define tree
## NOTE: the string ends with a semi-colon!
str1<- c("(G,(C, H) );")

## convert character string to tree
tree1<-ape::read.tree(text=str1)

## plot tree
plot.phylo(tree1,edge.width=2, main = "")
```

Newick format does not represent **genetic distances** and therefore the **branch length** of phylogenetic, only the clade structure and branching pattern of the tree.  We can calculate branch lengths using the UPGMA algorithm.


## Distance matrix in R from raw sequences

To make a distance matrix in R from the original sequences we first need to put our original sequences into a matrix with the `rbind()` command.

```{r}
my_seqs <- rbind(human, 
                 chimp, 
                 gorilla)
```

This is what it looks like
```{r}
my_seqs
```


We then need to do some fancy processing (this has to do with how the packages we're going to use works, which is picky about formats because its optimized to accommodate real sequences which can be very very long).  We'll use the `as.DNAbin()` function.

```{r}
my_seqs_bin <- ape::as.DNAbin(my_seqs)
```

We then can calculate the **distance** between each sequence in terms of the number (N) of mutations.  This uses the `dist.dna()` function.  We set the argument `model = "N"`.  This is the most basic and naive model of mutation and ignores the possibility of back mutations.

```{r}
seq_dist0 <- ape::dist.dna(my_seqs_bin, model = "N")
```

This gives us a distance matrix
```{r}
seq_dist0
```

Note that there is a subtle difference in how R looks at the matrix we made earlier with the matrix() command and this matrix.

Them matrices have the same data, but slightly different formats.
```{r}
dist_mat
seq_dist0
```

They also each have a different class

```{r}
class(dist_mat)
class(seq_dist0)
```


## Distance matrix in R from normal matrix

Sometimes we already have a distance matrix computed that we want to enter directly into R.  For example, perhaps it was reported in a paper and we want to explore the matrix on our own.  In this case we can convert our normal matrix we made initially into a properly formatted distance matrix.  This requires the base R `as.dist()` function.  I'll call this object "seq_dist_from_mat" to indicate that it came "from a matrix".  Note that I'm going to give it the full 3 x 3 matrix, `dist_mat`.
```{r}
# input matrix
dist_mat

# covert to distance matrix
seq_dist_from_mat <- as.dist(dist_mat)

# new format
seq_dist_from_mat
```



I'll now compare the two ways of making the matrix: `seq_dist0`, which was build from the original sequences, and `seq_dist_from_mat`, which was built from the hand-entered matrix.

First, let's compare their structure

```{r}
seq_dist0
seq_dist_from_mat
```

Then check them out with is() and class()

```{r}
is(seq_dist0) == is(seq_dist_from_mat)
class(seq_dist0) == class(seq_dist_from_mat)
```

Now I'll confirm that that have the same content (Note that distance matrices are not indexed internally by rows and columns, but by the order that the values appear.  The following code therefore returns only 3 responses, not 4.)
```{r}
seq_dist0 == seq_dist_from_mat
```

Cool, so we can make a matrix either from the raw sequences or from a hand-entered matrix.

## UPGMA in R

Once you have a distance matrix, UPGMA is easy in R with the `upgma()` function

```{r}
seq_upgma0 <- upgma(seq_dist0)
```

Now plot it with `plot()`
```{r}
plot(seq_upgma0, main = "Original data")

```

This doesn't look too different than the phylogeny produced from Newick.  Let's play with the distance matrix to see what happens.

First, make some more copies of the distance matrix
```{r}
seq.dist1 <- seq_dist0
seq.dist2 <- seq_dist0
seq.dist3 <- seq_dist0
```


The relationship between humans and chimps in in the upper left hand cell of the matrix.  Internally, *R* is calling this the first cell of the matrix

```{r}
seq.dist1[1]
```


Let's increase and decrease this value
```{r}
seq.dist1[1] <- 20   #change from 2 to 20
seq.dist2[1] <- 0.5  #change from 2 to 0.5
seq.dist3[1] <- 0.05 #change from 2 to 0.05
```


Now we'll build trees with our original matrix and the news ones to compare them. 

Note: We'll make a grid of plots using some fancy-looking code `par(mfrow = c(2,2), mar = c(2,2,2,2))`.  Don't worry about what exactly this means; it just sets up some graphical parameters to make things look nice.  I've also added some code to make the plot of the original data look a little different
```{r}
# set up graphical parameters
par(mfrow = c(2,2), mar = c(2,2,2,2))

# build 1st tree and plot
## build tree
seq_upgma0 <- upgma(seq_dist0)

## plot, in upper left-hand corner
plot.phylo(seq_upgma0, 
           main = "Original data",
           edge.color = "darkgreen",
           edge.width = 4)

# build 2nd tree and plot
seq.upgma1 <- upgma(seq.dist1)
plot(seq.upgma1, main = "Very long distance humans vs. chimps!")

seq.upgma2 <- upgma(seq.dist2)
plot(seq.upgma2, main = "Shorter distance humans vs. chimps")


seq.upgma3 <- upgma(seq.dist3)
plot(seq.upgma3, main = "Much shorter distance humans vs. chimps!")

```


## How UPGMA clustering works

UPGMA and other **clustering algorithms** work by finding looking at a distance matrix and finding the two things that are closet together. 

Human and chimps are closest
```{r}
seq_dist0
```

UPGAM therefore extracts the this minimum distance.  We'll extract it by hand using the `min()` function.
```{r}
d.min <- min(seq_dist0)
```

When two individual taxa are grouped into a clade the branch lengths are set at 1/2 the distance between them.  So, the total distance is 2, so the branch lengths will be 1.

```{r}
d.min/2
```

We can confirm that this is correct by checking what R calculated via the `upgma()` function.  We can access *R's* calculations by looking at the object we saved the UPGMA output too
```{r}
seq_upgma0
```

On its own this isn't helpful.  But what we can do is use the `str()` command to look under the hood of the object
```{r}
str(seq_upgma0)
```

The output tells us there is something called `edge.length` associated with the `seq_upgma0` object, and the smallest two values are 1. This looks promising, since **edge** is the math term for branches in a tree.

Next, UPGMA builds a new matrix that replace the Human and Chimp columns with a combined Humans-chimp column.  The algorithm then re-calculates the distance from this human-chimp clade to the remaining gorilla group  The distance from this human-chimp group to gorillas is the average distance from humans to gorillas and chimps to gorillas.

The original distance from humans to gorillas was 6, and the distance from chimps to gorillas was 4, as shown by the distance matrix
```{r}
seq_dist0
```

Let's store these values in R objects.
```{r}
#distance humans to gorillas
Dh_g <- 6

#distance chimps to gorillas
Dc_g <- 4
```

Now, we'll take the average of these two distance.  The math written out in explicit detail is:
```{r}
Dhc_g <- (Dh_g*1 + Dc_g*1)/(1+1)
Dhc_g
```

The result is total distance between our new human-chimp clade and gorillas.  


### Challenge

This new distance allows us to calculate the branch lengths for the rest of the tree.  The branch length from the human-chimp (h-c) clade to the gorillas (g) is 1/2 half the distance we just calculated:

Dhc_g/2 = 5/2 = 2.5

The remaining branch length is
2.5 - 1 = 1.5. 

See if you can figure out why this is done by sketching out the tree.

These values match what is in the upgma object

```{r}
str(seq_upgma0)
```



## Further information

### General info

A good, no-math overview of the general ideas of UPGMA is at this [blog post](https://medium.com/@sharma.ravit/upgma-method-designing-a-phylogenetic-tree-9a708de18419)

[Wikipedia](https://en.wikipedia.org/wiki/UPGMA) provides a good overview with math that isn't too daunting (though it could be improved).  https://en.wikipedia.org/wiki/UPGMA


### Worked examples: 

An excellent worked example is at [this site](http://www.slimsuite.unsw.edu.au/teaching/upgma/).  http://www.slimsuite.unsw.edu.au/teaching/upgma/
This example breaks down the math into basic steps, but there's a lot of taxa so its still complicated.

A worked example showing the limits of UPGMA is [here](https://www.icp.ucl.ac.be/~opperd/private/upgma.html):
https://www.icp.ucl.ac.be/~opperd/private/upgma.html

Another, dense-looking example is [here](http://www.nmsr.org/upgma.htm):
http://www.nmsr.org/upgma.htm

Another worked example is
https://www.mun.ca/biology/scarr/2900_UPGMA.htm


### Additional notes: 

Some useful but terse notes are [here](https://www.sequentix.de/gelquest/help/upgma_method.htm):
https://www.sequentix.de/gelquest/help/upgma_method.htm

If you want to understand what the **ultrametricity** assumption is, check out [this site](https://www.sequentix.de/gelquest/help/explanation_of_the_term_ultrametric.htm) (however, I don't get hung up on this):
https://www.sequentix.de/gelquest/help/explanation_of_the_term_ultrametric.htm

Explanation of the convoluted meaning of "Un-weighted" is [here](https://www.mun.ca/biology/scarr/UPGMA_vs_WPGMA.html)
https://www.mun.ca/biology/scarr/UPGMA_vs_WPGMA.html

```{r}

```

